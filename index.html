<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Abyss Alchemy - Water Sort Rogue</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg-color: #020617;
            --tube-border: #334155;
            --tube-bg: rgba(15, 23, 42, 0.4);
            --pour-speed: 0.3s;
            --segment-height: 40px;
            --tube-height: 220px;
            --primary-glow: #38bdf8;
            --rarity-common: #94a3b8;
            --rarity-rare: #3b82f6;
            --rarity-epic: #a855f7;
        }

        body {
            background: radial-gradient(circle at 50% 0%, #0f172a 0%, #020617 100%);
            color: white;
            font-family: 'Inter', system-ui, sans-serif;
            touch-action: manipulation;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            margin: 0;
            user-select: none;
            -webkit-user-select: none;
        }

        .glass-panel {
            background: rgba(15, 23, 42, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(12px);
            border-radius: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        /* ãƒãƒ¥ãƒ¼ãƒ–ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .tube {
            width: clamp(40px, 10vw, 56px);
            height: var(--tube-height);
            border: 3px solid var(--tube-border);
            border-top: 2px solid rgba(255,255,255,0.15);
            border-bottom-left-radius: 28px;
            border-bottom-right-radius: 28px;
            position: relative;
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1), box-shadow 0.3s ease, border-color 0.3s ease;
            background: var(--tube-bg);
            margin: 3px;
            z-index: 10;
            cursor: pointer;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            box-shadow: inset 2px 0 4px rgba(255,255,255,0.05), inset -2px 0 4px rgba(0,0,0,0.2);
            flex-shrink: 0;
        }

        .tube.selected {
            transform: translateY(-15px) scale(1.05);
            border-color: var(--primary-glow);
            box-shadow: 0 0 25px rgba(56, 189, 248, 0.25);
            z-index: 20;
        }
        
        .tube.target-mode {
            border-color: #a855f7;
            box-shadow: 0 0 20px rgba(168, 85, 247, 0.4);
            animation: pulse-purple 1.5s infinite;
        }
        
        .tube.source-mode {
            border-color: #fbbf24;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.4);
            animation: pulse-yellow 1.5s infinite;
        }

        @keyframes pulse-purple {
            0%, 100% { box-shadow: 0 0 20px rgba(168, 85, 247, 0.4); }
            50% { box-shadow: 0 0 30px rgba(168, 85, 247, 0.7); }
        }
        @keyframes pulse-yellow {
            0%, 100% { box-shadow: 0 0 20px rgba(251, 191, 36, 0.4); }
            50% { box-shadow: 0 0 30px rgba(251, 191, 36, 0.7); }
        }

        .tube-focused {
            border-color: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 0 4px rgba(255,255,255,0.3);
        }

        /* è©°ã¿è­¦å‘Š */
        .deadlock-glow {
            box-shadow: 0 0 0 4px rgba(244, 63, 94, 0.5) !important;
            border-color: rgba(244, 63, 94, 0.8) !important;
        }

        .water-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            flex-direction: column-reverse;
            padding: 0;
            gap: 0;
            pointer-events: none;
            width: 100%;
        }

        .water-segment {
            width: 100%;
            height: var(--segment-height);
            position: relative;
            transition: height 0.3s ease, opacity 0.3s ease;
        }

        .water-segment::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, 
                rgba(255,255,255,0.1) 0%, 
                rgba(255,255,255,0) 20%, 
                rgba(0,0,0,0.1) 50%, 
                rgba(255,255,255,0) 80%, 
                rgba(255,255,255,0.15) 100%);
            opacity: 0.6;
        }

        .water-segment:last-child {
            border-top: 1px solid rgba(255,255,255,0.3);
        }
        .water-segment:last-child::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(255,255,255,0.4);
            filter: blur(2px);
            border-radius: 50%;
            transform: scaleX(0.9);
        }
        
        @keyframes evaporate {
            0% { transform: scale(1); opacity: 1; filter: brightness(1); }
            50% { filter: brightness(2); background-color: white; }
            100% { transform: scale(1.2); opacity: 0; }
        }
        .evaporating .water-segment {
            animation: evaporate 0.6s forwards;
        }

        .lang-btn{
            padding: 6px 10px;
            font-weight: 800;
            font-size: 12px;
            border-radius: 12px;
            opacity: 0.55;
            transition: all .2s;
        }
        .lang-btn.active{ opacity: 1; background: rgba(56,189,248,0.15); border: 1px solid rgba(56,189,248,0.35); }

        .perk-card {
            transition: all 0.25s ease;
            border: 1px solid rgba(255,255,255,0.06);
            position: relative;
            overflow: hidden;
        }
        .perk-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            border-color: rgba(56,189,248,0.35);
        }

        .rarity-common{ border-left: 3px solid var(--rarity-common); }
        .rarity-rare{ border-left: 3px solid var(--rarity-rare); }
        .rarity-epic{ border-left: 3px solid var(--rarity-epic); }
        
        .skill-btn {
            position: relative;
            transition: all 0.2s;
            filter: grayscale(0.8);
            opacity: 0.7;
        }
        .skill-btn:not(:disabled):hover {
            filter: grayscale(0);
            opacity: 1;
            transform: translateY(-2px);
            z-index: 50;
        }
        .skill-btn.pending {
            filter: grayscale(0);
            opacity: 1;
            border-color: #fbbf24;
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.4);
            background: rgba(251, 191, 36, 0.1);
            animation: pulse-btn 1s infinite;
        }
        .skill-btn.active-mode {
            filter: grayscale(0);
            opacity: 1;
            border-color: #a855f7;
            box-shadow: 0 0 15px rgba(168, 85, 247, 0.4);
            background: rgba(168, 85, 247, 0.2);
        }
        .skill-btn.extracting {
            border-color: #22c55e;
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.4);
            background: rgba(34, 197, 94, 0.2);
            animation: pulse-btn 1.5s infinite;
        }
        .skill-btn.active {
            filter: grayscale(0);
            opacity: 1;
            border-color: var(--primary-glow);
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.4);
            background: rgba(56, 189, 248, 0.2);
        }
        
        @keyframes pulse-btn {
            0% { box-shadow: 0 0 5px currentColor; }
            50% { box-shadow: 0 0 15px currentColor; }
            100% { box-shadow: 0 0 5px currentColor; }
        }

        #global-tooltip {
            position: fixed;
            background: rgba(2, 6, 23, 0.98);
            border: 1px solid rgba(56, 189, 248, 0.3);
            padding: 8px 12px;
            border-radius: 8px;
            pointer-events: none;
            width: max-content;
            max-width: 220px;
            text-align: center;
            box-shadow: 0 4px 25px rgba(0,0,0,0.8);
            backdrop-filter: blur(8px);
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.15s ease;
            transform: translateX(-50%);
        }
        #global-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -6px;
            border-width: 6px;
            border-style: solid;
            border-color: rgba(56, 189, 248, 0.3) transparent transparent transparent;
        }

        #btn-undo {
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
            transition: all 0.2s;
        }
        #btn-undo:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.3);
        }
        #btn-undo:active {
            transform: scale(0.95);
        }

        #alert-banner {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(244, 63, 94, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 14px;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        #toast-container {
            pointer-events: none;
        }
        .toast-msg {
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(56, 189, 248, 0.3);
            color: white;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            animation: toast-in 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(4px);
        }
        .toast-msg.fade-out {
            animation: toast-out 0.3s forwards;
        }
        @keyframes toast-in {
            from { opacity: 0; transform: translateY(-20px) scale(0.9); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        @keyframes toast-out {
            to { opacity: 0; transform: translateY(-10px); }
        }

        .floating{
            animation: floaty 3.2s ease-in-out infinite;
        }
        @keyframes floaty{
            0%,100%{ transform: translateY(0); }
            50%{ transform: translateY(-10px); }
        }

        #board-scroll-area {
            width: 100%;
            height: 100%;
            overflow-x: scroll; /* autoã‹ã‚‰scrollã¸å¤‰æ›´ */
            overflow-y: hidden;
            display: flex;
            align-items: center; 
            /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼éè¡¨ç¤º */
            scrollbar-width: none;
            -ms-overflow-style: none;
            cursor: grab; /* ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ */
            mask-image: linear-gradient(to right, transparent 0%, black 20%, black 80%, transparent 100%);
        }
        #board-scroll-area:active {
            cursor: grabbing;
        }
        #board-scroll-area::-webkit-scrollbar {
            display: none;
        }

        #tubes-container {
            display: flex;
            flex-wrap: nowrap;
            gap: 6px;
            padding: 0 24px;
            width: max-content; 
            margin: auto; 
            transition: transform 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            transform-origin: center center;
        }
        
        #skills-container {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 0.75rem;
            overflow-x: auto;
            padding-left: 1rem;
            padding-right: 1rem;
            padding-bottom: 0.5rem;
            mask-image: linear-gradient(to right, transparent 0%, black 5%, black 95%, transparent 100%);
            -webkit-mask-image: linear-gradient(to right, transparent 0%, black 5%, black 95%, transparent 100%);
            -ms-overflow-style: none;
            scrollbar-width: none;
            position: relative;
            z-index: 30;
        }
        #skills-container::-webkit-scrollbar {
            display: none;
        }

        #dev-tests {
            display: none;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 8px;
        }
        .stat-item {
            padding: 8px;
            border-radius: 8px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.05);
            display: flex;
            flex-direction: column;
        }
    </style>
</head>
<body>

    <div>
        <div id="toast-container" class="fixed top-20 left-1/2 -translate-x-1/2 z-[200] flex flex-col gap-2 w-full max-w-sm px-4"></div>
        
        <div id="global-tooltip"></div>

        <div id="game-container" class="flex flex-col items-center justify-between h-screen w-screen p-2 md:p-4 overflow-hidden relative">
            <div id="alert-banner">NO MOVES LEFT</div>

            <!-- ãƒˆãƒƒãƒ—HUD -->
            <div id="top-hud" class="w-full max-w-5xl glass-panel p-3 md:p-4 flex items-center justify-between z-20 shrink-0 mb-2">
                <div class="flex items-center gap-4">
                    <div>
                        <div class="text-[10px] text-slate-400 uppercase tracking-[0.35em]" id="ui-subtitle">éŒ¬é‡‘è¡“ã®æ·±æ·µ</div>
                        <div class="text-xl md:text-2xl font-black tracking-tight leading-none bg-gradient-to-br from-white to-slate-400 bg-clip-text text-transparent" id="ui-title">Abyss Alchemy</div>
                    </div>
                    <div class="hidden md:flex items-center gap-3 ml-4">
                        <span class="px-4 py-2 rounded-xl glass-panel text-xl font-bold border border-white/5" id="ui-floor">FLOOR 1</span>
                        <span class="px-4 py-2 rounded-xl glass-panel text-xl font-bold text-sky-300 border border-white/5" id="ui-essence">0 âœ¨</span>
                        <span class="px-4 py-2 rounded-xl glass-panel text-xl font-bold text-rose-300 border border-white/5" id="ui-hp">HP 3</span>
                    </div>
                </div>

                <div class="flex items-center gap-2">
                    <!-- Status Button: å¤‰ç•°ã¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ç¢ºèª -->
                    <button id="btn-mutations" class="w-10 h-10 md:w-auto md:h-auto md:px-4 md:py-2 flex items-center justify-center glass-panel font-bold text-xs uppercase tracking-widest hover:bg-white/5 active:scale-95 transition-all text-sky-300 border-sky-500/30">
                        <span class="md:hidden">ğŸ§¬</span><span class="hidden md:inline">Status</span>
                    </button>
                    <button id="btn-help" class="w-10 h-10 md:w-auto md:h-auto md:px-4 md:py-2 flex items-center justify-center glass-panel font-bold text-xs uppercase tracking-widest hover:bg-white/5 active:scale-95 transition-all">
                        <span class="md:hidden">?</span><span class="hidden md:inline">Help</span>
                    </button>
                </div>
            </div>

            <!-- ç›®æ¨™/åœ§åŠ› è¡Œ -->
            <div id="status-bar" class="w-full max-w-5xl flex gap-2 shrink-0 z-20 mb-2">
                <div class="flex-1 glass-panel px-4 py-2 border-l-4 border-l-sky-500/50">
                    <div class="text-[10px] text-slate-400 uppercase tracking-[0.35em]" id="ui-goal-title">GOAL</div>
                    <div class="text-sm font-black tracking-tight text-white" id="ui-goal">â€”</div>
                    <div class="text-[10px] text-slate-500 mt-1 text-yellow-400" id="ui-goal-sub">â€”</div>
                </div>
                <div class="w-[180px] md:w-[220px] glass-panel px-4 py-2 border-l-4 border-l-rose-500/50">
                    <div class="text-[10px] text-slate-400 uppercase tracking-[0.35em]">PRESSURE</div>
                    <div class="flex items-center gap-2 mt-1">
                        <div class="flex-1 h-2 rounded-full bg-slate-800/80 overflow-hidden relative border border-white/5">
                            <div id="ui-pressure-bar" class="h-full rounded-full bg-gradient-to-r from-sky-400 via-purple-400 to-rose-500 transition-all duration-300" style="width:0%"></div>
                        </div>
                        <div class="text-xs font-black w-5 text-right" id="ui-pressure">0</div>
                    </div>
                    <div class="text-[10px] text-slate-500 mt-1 text-right" id="ui-pressure-sub">â€”</div>
                </div>
            </div>

            <!-- ç›¤é¢ã‚¨ãƒªã‚¢ -->
            <div id="board-area" class="flex-1 w-full relative z-10 overflow-hidden my-2">
                <div id="board-scroll-area">
                    <div id="tubes-container"></div>
                </div>
            </div>
            
            <!-- ã‚¹ã‚­ãƒ«ãƒãƒ¼ (Scrollable) -->
            <div id="skills-container" class="w-full max-w-2xl mb-2 min-h-[60px] shrink-0">
                <!-- JSã§ãƒœã‚¿ãƒ³ç”Ÿæˆ -->
            </div>

            <!-- ä¸‹HUD -->
            <div id="bottom-hud" class="w-full max-w-5xl glass-panel p-3 md:p-4 shrink-0 z-20 mb-safe">
                <div class="md:hidden flex items-center justify-between mb-3 px-1 gap-2 text-sm font-bold">
                    <span class="text-slate-300 bg-white/5 px-2 py-1 rounded border border-white/10" id="ui-floor-mobile">1F</span>
                    <div class="flex gap-3">
                        <span class="text-sky-300" id="ui-essence-mobile">0 âœ¨</span>
                        <span class="text-purple-300" id="ui-perks-mobile">ğŸ§¬ 0</span>
                    </div>
                    <span class="text-rose-300" id="ui-hp-mobile">HP 3</span>
                </div>

                <div class="flex items-center justify-between gap-3 relative">
                    <div class="flex items-center gap-2 md:gap-3 flex-wrap">
                        <span class="px-4 py-2 rounded-xl glass-panel text-sm font-black tracking-tight text-white border border-white/5" id="ui-turn">TURN 0</span>
                        <span class="px-4 py-2 rounded-xl glass-panel text-sm font-black tracking-tight text-white border border-white/5" id="ui-secondary">BONUS â€”</span>
                        <span class="px-4 py-2 rounded-xl glass-panel text-sm font-black tracking-tight text-sky-300 border border-white/5 hidden sm:block" id="ui-perks">PERKS 0</span>
                    </div>
                    
                    <button id="btn-undo" class="px-4 py-2 rounded-xl font-bold text-xs uppercase tracking-widest text-slate-300 flex items-center gap-2">
                        <span>â†º</span> UNDO (5âœ¨)
                    </button>
                </div>
            </div>
        </div>

        <!-- ç”»é¢ï¼šã‚¤ãƒ™ãƒ³ãƒˆ -->
        <div id="event-screen" class="fixed inset-0 z-[140] bg-slate-950/85 backdrop-blur-sm hidden items-center justify-center p-6 transition-opacity">
            <div class="glass-panel w-full max-w-2xl p-6 border border-sky-500/20 shadow-2xl shadow-sky-900/20">
                <div class="flex items-end justify-between gap-4">
                    <div>
                        <div class="text-[10px] text-sky-400 uppercase tracking-[0.35em] font-bold" id="event-kicker">EVENT</div>
                        <div class="text-3xl font-black tracking-tight text-white mt-1" id="event-title">â€”</div>
                        <div class="text-slate-300 text-sm mt-3 whitespace-pre-line leading-relaxed" id="event-desc">â€”</div>
                    </div>
                    <div class="text-right shrink-0">
                        <div class="px-3 py-1 bg-rose-500/10 border border-rose-500/30 rounded text-[10px] text-rose-300 uppercase tracking-[0.2em]">Unavoidable</div>
                    </div>
                </div>
                <div class="grid md:grid-cols-2 gap-4 mt-8" id="event-choices"></div>
            </div>
        </div>

        <!-- ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ -->
        <div id="start-screen" class="fixed inset-0 z-[100] flex flex-col items-center justify-center bg-slate-950 p-8">
            <div class="absolute top-8 right-8 flex gap-2 glass-panel p-1 z-50">
                <button onclick="setLang('en')" id="lang-en" class="lang-btn">EN</button>
                <button onclick="setLang('ja')" id="lang-ja" class="lang-btn active">JP</button>
            </div>

            <div class="text-center mb-16 floating relative">
                <div class="absolute inset-0 bg-sky-500/20 blur-[100px] rounded-full"></div>
                <h1 class="relative text-5xl md:text-7xl font-black tracking-tighter text-transparent bg-clip-text bg-gradient-to-b from-sky-300 via-sky-500 to-indigo-600 drop-shadow-2xl leading-tight">ABYSS<br>ALCHEMY</h1>
                <p id="start-subtitle" class="relative text-sky-200/60 font-medium tracking-[0.5em] uppercase text-xs mt-4">éŒ¬é‡‘è¡“ã®æ·±æ·µ</p>
            </div>
            
            <div class="flex flex-col gap-3 w-full max-w-xs">
                <button id="continue-run-btn" class="hidden w-full py-4 bg-emerald-600 rounded-2xl font-black text-white uppercase tracking-widest shadow-2xl shadow-emerald-500/20 hover:bg-emerald-500 hover:shadow-emerald-500/40 hover:-translate-y-1 transition-all active:scale-95 active:translate-y-0 flex items-center justify-center gap-2">
                    <span>â–¶</span> <span id="continue-btn-text">ã¤ã¥ãã‹ã‚‰</span>
                </button>
                <button id="start-run-btn" class="w-full py-4 bg-sky-600 rounded-2xl font-black text-white uppercase tracking-widest shadow-2xl shadow-sky-500/20 hover:bg-sky-500 hover:shadow-sky-500/40 hover:-translate-y-1 transition-all active:scale-95 active:translate-y-0">
                    æ¢ç´¢ã‚’é–‹å§‹
                </button>
            </div>

            <p class="text-slate-600 text-[10px] mt-8 tracking-widest uppercase">Alpha Ver 0.0.22 Scroll Update</p>
        </div>

        <!-- å¤‰ç•°é¸æŠ & ã‚·ãƒ§ãƒƒãƒ—ç”»é¢ -->
        <div id="perk-screen" class="fixed inset-0 z-[150] bg-slate-950 flex flex-col items-center justify-center p-4 md:p-8 hidden">
            <div class="w-full max-w-6xl h-full max-h-full flex flex-col glass-panel p-0 overflow-hidden relative border border-white/10 shadow-2xl shadow-black/80">
                
                <!-- Header -->
                <div class="flex justify-between items-center p-4 md:p-6 border-b border-white/5 shrink-0 bg-slate-900/40">
                    <div>
                        <h2 id="perk-title" class="text-xl md:text-3xl font-black text-white italic uppercase leading-none">å¤‰ç•°ã®å…†ã—</h2>
                        <p id="perk-subtitle" class="text-slate-400 text-[10px] md:text-xs mt-1 uppercase tracking-widest">ç„¡æ–™ã®å¼·åŒ–ã‚’1ã¤é¸æŠ</p>
                    </div>
                    <div class="flex items-center gap-4">
                        <button id="reroll-btn" class="px-4 py-1.5 glass-panel border border-white/10 text-base font-black uppercase tracking-widest hover:bg-white/5 active:scale-95 transition-all hidden">Reroll (-5âœ¨)</button>
                        <div class="text-base font-bold text-sky-400 bg-sky-900/30 px-3 py-1.5 rounded border border-sky-500/20 whitespace-nowrap" id="perk-essence">Essence: 0 âœ¨</div>
                    </div>
                </div>

                <!-- Main Content (Scrollable) -->
                <div class="flex-1 flex flex-col md:flex-row min-h-0 overflow-hidden">
                    
                    <!-- Left: Perks -->
                    <div class="flex-1 flex flex-col p-4 md:p-6 overflow-y-auto border-b md:border-b-0 md:border-r border-white/5 bg-slate-900/20">
                        <div class="text-sm font-bold mb-3 text-sky-300 uppercase tracking-widest flex items-center gap-2">
                            <span>ğŸ§¬ Mutations</span>
                            <span class="text-[10px] text-slate-500 font-normal normal-case">Pick One (Updates every level)</span>
                        </div>
                        <div class="grid gap-3" id="perk-cards">
                            <!-- Perks injected here -->
                        </div>
                    </div>

                    <!-- Right: Shop -->
                    <div class="flex-1 flex flex-col p-4 md:p-6 overflow-y-auto">
                        <div class="flex justify-between items-center mb-3">
                            <div class="text-sm font-bold text-yellow-500 uppercase tracking-widest flex items-center gap-2">
                                <span>â—ˆ Shop</span>
                                <span class="text-[10px] text-slate-500 font-normal normal-case">4 Random Items</span>
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-2 md:grid-cols-2 lg:grid-cols-2 gap-3" id="shop-cards">
                            <!-- Shop Items injected here -->
                        </div>
                    </div>
                </div>

                <!-- Footer: Fixed Continue Button -->
                <div class="p-4 border-t border-white/5 bg-slate-900/40 shrink-0 flex justify-center z-10">
                    <button id="continue-btn" class="w-full max-w-md py-3 bg-indigo-600 rounded-xl font-black text-white text-sm uppercase tracking-widest shadow-lg shadow-indigo-900/40 hover:bg-indigo-500 transition-all active:scale-95">Next Floor</button>
                </div>

            </div>
        </div>

        <!-- Help -->
        <div id="help-screen" class="fixed inset-0 z-[160] bg-slate-950/90 backdrop-blur hidden items-center justify-center p-6">
            <div class="glass-panel w-full max-w-2xl p-8 border border-white/10">
                <div class="flex justify-between items-center mb-6">
                    <div>
                        <div class="text-[10px] text-slate-400 uppercase tracking-[0.35em]">HELP</div>
                        <div class="text-3xl font-black tracking-tight">Guide</div>
                    </div>
                    <button id="help-close" class="px-4 py-2 glass-panel font-black text-xs uppercase tracking-widest hover:bg-white/10 active:scale-95 transition-colors">Close</button>
                </div>
                <div class="text-slate-300 text-sm leading-loose whitespace-pre-line font-medium" id="help-text"></div>
            </div>
        </div>

        <!-- Mutations Status Screen -->
        <div id="mutations-screen" class="fixed inset-0 z-[160] bg-slate-950/90 backdrop-blur hidden items-center justify-center p-6">
            <div class="glass-panel w-full max-w-3xl p-8 border border-white/10 flex flex-col h-[85vh]">
                <div class="flex justify-between items-center mb-6 shrink-0">
                    <div>
                        <div class="text-[10px] text-sky-400 uppercase tracking-[0.35em]">STATUS</div>
                        <div class="text-3xl font-black tracking-tight text-white">Mutations & Stats</div>
                    </div>
                    <button id="mutations-close" class="px-4 py-2 glass-panel font-black text-xs uppercase tracking-widest hover:bg-white/10 active:scale-95 transition-colors">Close</button>
                </div>
                
                <div class="flex-1 overflow-y-auto space-y-8 pr-2">
                    <!-- ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼è¦ç´„ -->
                    <div>
                        <div class="text-[10px] text-slate-500 uppercase tracking-widest mb-3">Total Parameters</div>
                        <div id="mutations-stats-summary" class="stat-grid">
                            <!-- JSã§æ³¨å…¥ -->
                        </div>
                    </div>

                    <!-- ç²å¾—å¤‰ç•°ãƒªã‚¹ãƒˆ -->
                    <div>
                        <div class="text-[10px] text-slate-500 uppercase tracking-widest mb-3">Acquired Mutations</div>
                        <div id="mutations-list-container" class="grid gap-2">
                            <!-- JSã§æ³¨å…¥ -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="dev-tests"></div>
    </div>
    <script>
        // --- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ---
        function clamp(val, min, max){ return Math.min(Math.max(val, min), max); }
        function randInt(n){ return Math.floor(Math.random()*n); }
        function pick(arr){ return arr[randInt(arr.length)]; }
        function deepCopy(x){ return JSON.parse(JSON.stringify(x)); }
        function ui(id){ return document.getElementById(id); }
        function setText(id, text){
            const el = document.getElementById(id);
            if(el) el.textContent = text;
        }

        // --- ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—åˆ¶å¾¡ (Global) ---
        const tooltipEl = document.getElementById('global-tooltip');
        
        function showGlobalTooltip(targetEl, title, desc) {
            if(!targetEl || !title) {
                hideGlobalTooltip();
                return;
            }
            
            tooltipEl.innerHTML = `
                <div class="font-bold text-sky-300 text-xs mb-1">${title}</div>
                <div class="text-slate-300 text-[10px] leading-tight whitespace-pre-wrap">${desc}</div>
            `;
            
            const rect = targetEl.getBoundingClientRect();
            tooltipEl.style.opacity = '1';
            const ttWidth = tooltipEl.offsetWidth;
            const ttHeight = tooltipEl.offsetHeight;
            let left = rect.left + (rect.width / 2);
            let top = rect.top - ttHeight - 8;
            if (left - (ttWidth/2) < 4) left = 4 + (ttWidth/2);
            if (left + (ttWidth/2) > window.innerWidth - 4) left = window.innerWidth - 4 - (ttWidth/2);
            tooltipEl.style.left = `${left}px`;
            tooltipEl.style.top = `${top}px`;
        }
        
        function hideGlobalTooltip() {
            tooltipEl.style.opacity = '0';
        }

        // --- ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥ ---
        function showToast(msg, color='sky'){
            const container = ui('toast-container');
            const el = document.createElement('div');
            el.className = `toast-msg text-${color}-300 border-${color}-500/30`;
            el.innerHTML = `<span>â—ˆ</span> ${msg}`;
            container.appendChild(el);
            setTimeout(() => {
                el.classList.add('fade-out');
                setTimeout(() => el.remove(), 300);
            }, 3000);
        }

        // --- ã‚»ãƒ¼ãƒ–æ©Ÿèƒ½ (LocalStorage) ---
        const SAVE_KEY = 'abyssal_alchemy_save_v1';
        function saveGame() {
            try {
                const data = JSON.stringify(gameState);
                localStorage.setItem(SAVE_KEY, data);
            } catch (e) {
                console.error("Save failed:", e);
                showToast("Save failed (Storage Full?)", "red");
            }
        }
        function loadGame() {
            try {
                const data = localStorage.getItem(SAVE_KEY);
                if (data) {
                    const loadedState = JSON.parse(data);
                    Object.assign(gameState, loadedState);
                    updateTubeLayout();
                    perkScreen.classList.add('hidden');
                    startScreen.classList.add('hidden');
                    renderHUD();
                    renderBoard();
                    showToast(currentLang==='ja'?'å†é–‹ã—ã¾ã—ãŸ':'Game Loaded', 'emerald');
                    return true;
                }
            } catch (e) {
                console.error("Load failed:", e);
            }
            return false;
        }
        function clearSave() {
            localStorage.removeItem(SAVE_KEY);
        }
        function hasSaveData() {
            return !!localStorage.getItem(SAVE_KEY);
        }

        // --- ç¿»è¨³ãƒ‡ãƒ¼ã‚¿ ---
        const translations = {
            en: {
                subtitle: "Abyss Alchemy",
                startBtn: "New Descent",
                continueBtn: "Continue",
                vitality: "HP",
                floor: "FLOOR",
                essence: "Essence",
                turn: "TURN",
                secondary: "BONUS",
                perks: "PERKS",
                hint: "Select a tube to pour",
                goalTitle: "GOAL",
                pressureTitle: "PRESSURE",
                eventKicker: "EVENT",
                unavoid: "Unavoidable",
                helpTitle: "How to play",
                helpText: [
                    "â€¢ Pour water: Click a tube, then click another to pour.",
                    "â€¢ Obsidian (Black Ink): Match 4 to evaporate them and clear the tube!",
                    "â€¢ Pressure: Rises with every move. If it fills, you take 1 Damage.",
                    "â€¢ Survival: No Move limit. Manage your HP and Pressure to survive.",
                    "â€¢ Artifacts: Buy skills in the shop. Use them from the bottom bar.",
                    "â€¢ Undo: Use the button below (Costs 5 Essence).",
                ].join("\n"),
                helpClose: "Close",
                settings: "Settings",
                continue: "Continue",
                shopTitle: "Shop",
                shopSub: "Trade Essence for survival",
                gameOver: "Consumed",
                gameOverSub: "The abyss claims another soul...",
                victory: "Mutation",
                victorySub: "Select a mutation to evolve",
                typeInstant: "Instant",
                typeItem: "Held Item"
            },
            ja: {
                subtitle: "éŒ¬é‡‘è¡“ã®æ·±æ·µ",
                startBtn: "æ–°ãŸãªæ¢ç´¢",
                continueBtn: "ã¤ã¥ãã‹ã‚‰",
                vitality: "HP",
                floor: "éšå±¤",
                essence: "ã‚¨ãƒƒã‚»ãƒ³ã‚¹",
                turn: "Turn",
                secondary: "Bonus",
                perks: "å¤‰ç•°",
                hint: "ãƒãƒ¥ãƒ¼ãƒ–ã‚’é¸æŠã—ã¦æ³¨ã",
                goalTitle: "ç›®æ¨™",
                pressureTitle: "åœ§åŠ›",
                eventKicker: "å¤‰è³ª",
                unavoid: "ä¸å¯é¿",
                helpTitle: "éŠã³æ–¹",
                helpText: [
                    "ãƒ»æ³¨ãï¼šãƒãƒ¥ãƒ¼ãƒ–ã‚’é¸æŠã—ã€åˆ¥ã®ãƒãƒ¥ãƒ¼ãƒ–ã¸æ³¨ãã¾ã™",
                    "ãƒ»é»’ã‚¤ãƒ³ã‚¯ï¼š4ã¤æƒãˆã‚‹ã¨è’¸ç™ºã—ã¦æ¶ˆãˆã€ç©ºãç“¶ã«ãªã‚Šã¾ã™ã€‚",
                    "ãƒ»åœ§åŠ›ï¼š1æ‰‹ã”ã¨ã«ä¸Šæ˜‡ã—ã¾ã™ã€‚æœ€å¤§ã«ãªã‚‹ã¨HPãŒ1æ¸›ã‚Šã¾ã™ã€‚",
                    "ãƒ»ç”Ÿå­˜ï¼šæ‰‹æ•°åˆ¶é™ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚HPãŒå°½ããªã„é™ã‚Šæ¢ç´¢ã‚’ç¶šã‘ã‚‰ã‚Œã¾ã™ã€‚",
                    "ãƒ»é“å…·ã¨ç§˜è¡“ï¼šã‚·ãƒ§ãƒƒãƒ—ã§ã‚¹ã‚­ãƒ«ã‚’è³¼å…¥ã—ã€ç”»é¢ä¸‹éƒ¨ã‹ã‚‰ä½¿ç”¨ã—ã¾ã™",
                    "ãƒ»ã‚„ã‚Šç›´ã—ï¼šå³ä¸‹ã®UNDOãƒœã‚¿ãƒ³ã‚’ä½¿ç”¨ã—ã¾ã™ï¼ˆæ¶ˆè²»ï¼š5ã‚¨ãƒƒã‚»ãƒ³ã‚¹ï¼‰",
                    "ãƒ»ã‚¢ã‚¤ãƒ†ãƒ ï¼šã‚¢ã‚¤ã‚³ãƒ³ã‚’1å›ã‚¿ãƒƒãƒ—ã§é¸æŠ(ç¢ºèª)ã€2å›ç›®ã§ä½¿ç”¨/ãƒ¢ãƒ¼ãƒ‰ç§»è¡Œã—ã¾ã™ã€‚",
                ].join("\n"),
                helpClose: "é–‰ã˜ã‚‹",
                settings: "è¨­å®š",
                continue: "æ¬¡ã¸é€²ã‚€",
                shopTitle: "ã‚·ãƒ§ãƒƒãƒ—",
                shopSub: "ã‚¨ãƒƒã‚»ãƒ³ã‚¹ã‚’æ¶ˆè²»ã—ã¦å®‰å®šã‚’å¾—ã‚‹",
                gameOver: "å¥ˆè½ã«å‘‘ã¾ã‚ŒãŸ",
                gameOverSub: "æ·±æ·µã¯ã¾ãŸä¸€ã¤é­‚ã‚’å–°ã‚‰ã£ãŸ...",
                victory: "å¤‰ç•°ã®å…†ã—",
                victorySub: "åŠ›ã‚’é¸ã‚“ã§é€²åŒ–ã™ã‚‹",
                typeInstant: "å³æ™‚å®Ÿè¡Œ",
                typeItem: "æ‰€æŒã‚¢ã‚¤ãƒ†ãƒ "
            }
        };
        let currentLang = 'ja';
        function updateStartScreenButtons(){
        const hasSave = hasSaveData();

        // ã€Œã¤ã¥ãã‹ã‚‰ã€ãƒœã‚¿ãƒ³ã®è¡¨ç¤º/éè¡¨ç¤º
        const cbtn = ui('continue-run-btn');
        if (cbtn) cbtn.classList.toggle('hidden', !hasSave);

        // æ–‡è¨€ã¯ applyLang() ãŒæ›´æ–°ã—ã¦ã„ã‚‹ãŒã€ä¿é™ºã§å†è¨­å®š
        setText('start-run-btn', t('startBtn'));
        setText('continue-btn-text', t('continueBtn'));
        }
        function setLang(lang){
            currentLang = lang;
            document.getElementById('lang-en').classList.toggle('active', lang==='en');
            document.getElementById('lang-ja').classList.toggle('active', lang==='ja');
            applyLang();
            updateStartScreenButtons();
            renderHUD();
        }
        function t(key){
            return translations[currentLang]?.[key] ?? translations.en[key] ?? key;
        }
        function applyLang(){
            setText('start-subtitle', t('subtitle'));
            setText('start-run-btn', t('startBtn'));
            setText('continue-btn-text', t('continueBtn'));
            setText('ui-subtitle', t('subtitle'));
            setText('ui-title', translations.en.subtitle);
            setText('ui-goal-title', t('goalTitle'));
            setText('help-text', t('helpText'));
            setText('help-close', t('helpClose'));
        }

        // --- ã‚²ãƒ¼ãƒ å®šç¾© ---
        const COLOR_POOL = [
            { key: 'R', name:{en:'Crimson', ja:'ç´…'}, hex:'#dc2626' }, 
            { key: 'B', name:{en:'Azure', ja:'è’¼'}, hex:'#3b82f6' },
            { key: 'Y', name:{en:'Amber', ja:'ç¥ç€'}, hex:'#fbbf24' },
            { key: 'W', name:{en:'Ivory', ja:'è±¡ç‰™'}, hex:'#e2e8f0' },
            { key: 'K', name:{en:'Obsidian', ja:'é»’'}, hex:'#0f172a' },
            { key: 'G', name:{en:'Emerald', ja:'ç¿ '}, hex:'#22c55e' }, 
            { key: 'P', name:{en:'Amethyst', ja:'ç´«'}, hex:'#a855f7' }, 
            { key: 'O', name:{en:'Orange', ja:'æ©™'}, hex:'#f97316' }, 
            { key: 'T', name:{en:'Teal', ja:'é’ç·‘'}, hex:'#06b6d4' }, 
            { key: 'M', name:{en:'Pink', ja:'æ¡ƒ'}, hex:'#d946ef' }, 
        ];

        const PERKS = {
            catalyst: {
                id:'catalyst',
                name:{en:'Catalyst', ja:'è§¦åª’åå¿œ'},
                rarity:'rare',
                desc:{en:'Completing a tube reduces Pressure by [4 + Lv].', ja:'è‰²ã‚’å®Œæˆã•ã›ã‚‹ã¨åœ§åŠ›ãŒ [4 + Lv] ä¸‹ãŒã‚‹ã€‚'},
            },
            efficiency: {
                id:'efficiency',
                name:{en:'Efficiency', ja:'æŠ½å‡ºåŠ¹ç‡'},
                rarity:'common',
                desc:{en:'Tube completion has [Lv x 20]% chance to grant +1 Essence.', ja:'è‰²å®Œæˆæ™‚ã€[Lv x 20]% ã®ç¢ºç‡ã§ +1 ã‚¨ãƒƒã‚»ãƒ³ã‚¹ã‚’ç²å¾—ã€‚'},
            },
            transmutation: {
                id:'transmutation',
                name:{en:'Transmutation', ja:'ç‰©è³ªå¤‰æ›'},
                rarity:'rare',
                desc:{en:'Start each floor with [Lv] random items.', ja:'éšå±¤é–‹å§‹æ™‚ã€[Lv] å€‹ã®ãƒ©ãƒ³ãƒ€ãƒ ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç²å¾—ã™ã‚‹ã€‚'},
            },
            momentum: {
                id:'momentum',
                name:{en:'Momentum', ja:'æ…£æ€§å¾‹'},
                rarity:'common',
                desc:{en:'After completing a tube, Pressure does not rise for [Lv] turns.', ja:'ãƒãƒ¥ãƒ¼ãƒ–å®Œæˆå¾Œã€[Lv] ã‚¿ãƒ¼ãƒ³ã®é–“ã€åœ§åŠ›ãŒä¸Šæ˜‡ã—ãªã„ã€‚'},
            },
            reflux: {
                id:'reflux',
                name:{en:'Reflux', ja:'é€†æµåˆ¶å¾¡'},
                rarity:'common',
                desc:{en:'First [Lv] undos each floor are free (Pressure +2 instead).', ja:'å„éšå±¤ã€æœ€åˆã® [Lv] å›ã®Undoã¯ã‚¨ãƒƒã‚»ãƒ³ã‚¹ç„¡æ–™ã€‚'},
            },
            steady_hand: {
                id:'steady_hand',
                name:{en:'Steady Hand', ja:'å®‰å®šã—ãŸæ‰‹'},
                rarity:'rare',
                desc:{en:'Pressure does not rise for the first [Lv x 3] turns of a floor.', ja:'éšå±¤é–‹å§‹ã‹ã‚‰ [Lv x 3] ã‚¿ãƒ¼ãƒ³ã®é–“ã€åœ§åŠ›ãŒä¸Šæ˜‡ã—ãªã„ã€‚'},
            },
            overflow: {
                id:'overflow',
                name:{en:'Overflow', ja:'ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼'},
                rarity:'common',
                desc:{en:'Pressure max +[Lv x 4].', ja:'åœ§åŠ›ã®æœ€å¤§è¨±å®¹é‡ãŒ +[Lv x 4] ã•ã‚Œã‚‹ã€‚'},
            },
            purification: {
                id:'purification',
                name:{en:'Purification', ja:'æµ„åŒ–ä½œç”¨'},
                rarity:'epic',
                desc:{en:'Clearing Obsidian reduces Pressure by [2 + Lv] and grants [1 + Lv] Essence.', ja:'é»’ã‚¤ãƒ³ã‚¯æ¶ˆæ»…æ™‚ã€åœ§åŠ›-[2 + Lv]ã€ã‚¨ãƒƒã‚»ãƒ³ã‚¹+[1 + Lv]ã€‚'},
            },
            scavenger: {
                id:'scavenger',
                name:{en:'Scavenger', ja:'ã‚¹ã‚«ãƒ™ãƒ³ã‚¸ãƒ£ãƒ¼'},
                rarity:'rare',
                desc:{en:'[10 + Lv x 5]% chance to find item on new floor.', ja:'éšå±¤ç§»å‹•æ™‚ã€[10 + Lv x 5]% ã®ç¢ºç‡ã§ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ‹¾ã†ã€‚'},
            },
            recycler: {
                id:'recycler',
                name:{en:'Recycler', ja:'ãƒªã‚µã‚¤ã‚¯ãƒ«'},
                rarity:'epic',
                desc:{en:'[Lv x 10]% chance to not consume item on use.', ja:'ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨æ™‚ã€[Lv x 10]% ã®ç¢ºç‡ã§æ¶ˆè²»ã—ãªã„ã€‚'},
            },
            bargain: {
                id:'bargain',
                name:{en:'Bargain', ja:'äº¤æ¸‰è¡“'},
                rarity:'common',
                desc:{en:'Shop prices reduced by [15 + Lv x 5]%.', ja:'ã‚·ãƒ§ãƒƒãƒ—ä¾¡æ ¼ [15 + Lv x 5]% OFFã€‚'},
            },
            heavy_mastery: {
                id:'heavy_mastery',
                name:{en:'Heavy Mastery', ja:'å¤§å®¹é‡ãƒœãƒ¼ãƒŠã‚¹'},
                rarity:'rare',
                desc:{en:'Clearing 5+ capacity tube reduces Pressure by [2 + Lv].', ja:'å®¹é‡5ä»¥ä¸Šã®ãƒãƒ¥ãƒ¼ãƒ–å®Œæˆã§åœ§åŠ› [2 + Lv] æ¸›å°‘ã€‚'},
            },
            void_shield: {
                id:'void_shield',
                name:{en:'Void Shield', ja:'è™šç©ºã®ç›¾'},
                rarity:'rare',
                desc:{en:'[Lv x 15]% chance to negate Pressure damage.', ja:'åœ§åŠ›ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸæ™‚ã€[Lv x 15]% ã§ç„¡åŠ¹åŒ–ã™ã‚‹ã€‚'},
            },
            deep_adapt: {
                id:'deep_adapt',
                name:{en:'Deep Adapt', ja:'æ·±å±¤é©å¿œ'},
                rarity:'epic',
                desc:{en:'Gain [Lv] Max HP if capacity > 4 at start of floor.', ja:'éšå±¤é–‹å§‹æ™‚ã€å®¹é‡5ä»¥ä¸Šãªã‚‰æœ€å¤§HP+[Lv]ã€‚'},
            },
            flow_mastery: {
                id:'flow_mastery',
                name:{en:'Flow Mastery', ja:'ãƒ•ãƒ­ãƒ¼ç†Ÿç·´'},
                rarity:'common',
                desc:{en:'Combo reduces Pressure by [Lv x 2].', ja:'ã‚³ãƒ³ãƒœç™ºç”Ÿæ™‚ã€åœ§åŠ›ãŒ [Lv x 2] ä¸‹ãŒã‚‹ã€‚'},
            },
            coupon: {
                id: 'coupon',
                name: {en:'Coupon', ja:'ã‚¯ãƒ¼ãƒãƒ³åˆ¸'},
                rarity: 'common',
                desc: {en:'Start each floor with [Lv] free Rerolls.', ja:'å„éšå±¤é–‹å§‹æ™‚ã€ç„¡æ–™ã§ãƒªãƒ­ãƒ¼ãƒ«ã§ãã‚‹ã‚¯ãƒ¼ãƒãƒ³ã‚’ [Lv] æšå¾—ã‚‹ã€‚'}
            },
            crimson_resonance: {
                id:'crimson_resonance',
                name:{en:'Crimson Resonance', ja:'ç´…ã®ç†±é‡'},
                rarity:'rare',
                desc:{en:'Completing Crimson heals 1 HP but adds [6 - Lv] Pressure.', ja:'ç´…ã‚’å®Œæˆã•ã›ã‚‹ã¨HPãŒ1å›å¾©ã™ã‚‹ãŒã€åœ§åŠ›ãŒ [6 - Lv] ä¸Šæ˜‡ã™ã‚‹ã€‚'},
            },
            azure_cycle: {
                id:'azure_cycle',
                name:{en:'Azure Cycle', ja:'è’¼ã®å¾ªç’°'},
                rarity:'common',
                desc:{en:'Azure completion reduces Pressure by [Lv x 3] additional.', ja:'è’¼å®Œæˆæ™‚ã€è¿½åŠ ã§åœ§åŠ›ãŒ [Lv x 3] æ¸›å°‘ã™ã‚‹ã€‚'},
            },
            amber_greed: {
                id:'amber_greed',
                name:{en:'Amber Alchemy', ja:'ç¥ç€ã®éŒ¬é‡‘'},
                rarity:'rare',
                desc:{en:'Amber completion grants [Lv x 2] Essence.', ja:'ç¥ç€å®Œæˆæ™‚ã€ã‚¨ãƒƒã‚»ãƒ³ã‚¹ã‚’ [Lv x 2] ç²å¾—ã™ã‚‹ã€‚'},
            },
            ivory_sanctuary: {
                id:'ivory_sanctuary',
                name:{en:'Ivory Sanctuary', ja:'è±¡ç‰™ã®è–åŸŸ'},
                rarity:'epic',
                desc:{en:'Ivory completion removes [Lv] Obsidian from random tubes.', ja:'è±¡ç‰™å®Œæˆæ™‚ã€ãƒ©ãƒ³ãƒ€ãƒ ãªãƒãƒ¥ãƒ¼ãƒ–ã‹ã‚‰é»’ã‚¤ãƒ³ã‚¯ã‚’ [Lv] å€‹é™¤å»ã™ã‚‹ã€‚'},
            },
            emerald_vitality: {
                id:'emerald_vitality',
                name:{en:'Emerald Vitality', ja:'ç¿ ã®æ´»åŠ›'},
                rarity:'common',
                desc:{en:'Emerald completion halves current Pressure.', ja:'ç¿ ã‚’å®Œæˆã•ã›ã‚‹ã¨ç¾åœ¨ã®åœ§åŠ›ãŒåŠåˆ†ã«ãªã‚‹ã€‚'},
            },
            amethyst_surge: {
                id:'amethyst_surge',
                name:{en:'Amethyst Surge', ja:'ç´«ã®è„ˆå‹•'},
                rarity:'rare',
                desc:{en:'Amethyst completion grants +[Lv] free Undo charges.', ja:'ç´«å®Œæˆæ™‚ã€ç„¡æ–™Undoã®å›æ•°ã‚’ [Lv] å›å¢—ã‚„ã™ã€‚'},
            },
            orange_drive: {
                id:'orange_drive',
                name:{en:'Orange Drive', ja:'æ©™ã®æ¨é€²'},
                rarity:'common',
                desc:{en:'Orange completion stops Pressure rise for [Lv x 2] turns.', ja:'æ©™å®Œæˆæ™‚ã€[Lv x 2] ã‚¿ãƒ¼ãƒ³ã®é–“åœ§åŠ›ãŒä¸Šæ˜‡ã—ãªããªã‚‹ã€‚'},
            },
            teal_equilibrium: {
                id:'teal_equilibrium',
                name:{en:'Teal Analysis', ja:'é’ç·‘ã®åˆ†æ'},
                rarity:'rare',
                desc:{en:'Teal completion progresses Secondary Goal by 1.', ja:'é’ç·‘ã‚’å®Œæˆã•ã›ã‚‹ã¨å‰¯ç›®æ¨™ã®é€²è¡Œåº¦ãŒ 1 é€²ã‚€ã€‚'},
            },
            pink_luck: {
                id:'pink_luck',
                name:{en:'Pink Luck', ja:'æ¡ƒã®å¹¸é‹'},
                rarity:'rare',
                desc:{en:'Pink completion has [Lv x 10]% chance to drop a random item.', ja:'æ¡ƒå®Œæˆæ™‚ã€[Lv x 10]% ã®ç¢ºç‡ã§ãƒ©ãƒ³ãƒ€ãƒ ãªã‚¢ã‚¤ãƒ†ãƒ ã‚’å¾—ã‚‹ã€‚'},
            }
        };

        const ITEMS = {
            // extractor: {
            //     id: 'extractor', type: 'consumable', cost: 12, icon: 'ğŸ’‰',
            //     name: {en:'Extractor', ja:'ã‚¹ãƒã‚¤ãƒˆæŠ½å‡º'},
            //     desc: {en:'Move top color to any empty space.', ja:'ä¸€ç•ªä¸Šã®è‰²ã‚’å¸ã„å–ã‚Šã€ç©ºããŒã‚ã‚‹å¥½ããªå ´æ‰€ã¸ç§»ã™'}
            // },
            // pipette: {
            //     id: 'pipette', type: 'tool', cost: 10, icon: 'âš—ï¸',
            //     name: {en:'Pipette', ja:'ç²¾å¯†ãƒ”ãƒšãƒƒãƒˆ'},
            //     desc: {en:'Toggle: Pour 1 segment.', ja:'åˆ‡æ›¿ï¼š1ç›®ç››ã‚Šã ã‘æ³¨ã'}
            // },
            inverter: {
                id: 'inverter', type: 'consumable', cost: 6, icon: 'ğŸ”„',
                name: {en:'Gravity Coil', ja:'é‡åŠ›åè»¢æ©Ÿ'},
                desc: {en:'Invert contents.', ja:'ä¸­èº«ã‚’ä¸Šä¸‹åè»¢'}
            },
            void_salt: {
                id: 'void_salt', type: 'consumable', cost: 8, icon: 'ğŸ§‚',
                name: {en:'Void Salt', ja:'è™šç„¡ã®å¡©'},
                desc: {en:'Remove top Black.', ja:'ä¸€ç•ªä¸Šã®ã€é»’ã€‘ã‚’é™¤å»'}
            },
            separator: {
                id: 'separator', type: 'consumable', cost: 12, icon: 'ğŸŒªï¸',
                name: {en:'Separator', ja:'é å¿ƒåˆ†é›¢æ©Ÿ'},
                desc: {en:'Sort tube contents.', ja:'ä¸­èº«ã‚’æ•´ç†ã™ã‚‹'}
            },
            summon_vial: {
                id: 'summon_vial', type: 'consumable', cost: 15, icon: 'ğŸ§ª',
                name: {en:'Extra Vial', ja:'äºˆå‚™ãƒ•ãƒ©ã‚¹ã‚³'},
                desc: {en:'Add empty tube.', ja:'ç©ºãç“¶ã‚’1ã¤è¿½åŠ '}
            },
            cycle_siphon: {
                id: 'cycle_siphon', type: 'consumable', cost: 9, icon: 'â«',
                name: {en:'Cycle Siphon', ja:'å¾ªç’°ã‚µã‚¤ãƒ•ã‚©ãƒ³'},
                desc: {en:'Move bottom to top.', ja:'ä¸€ç•ªä¸‹ã‚’ä¸€ç•ªä¸Šã¸'}
            },
            sediment: {
                id: 'sediment', type: 'consumable', cost: 10, icon: 'â¬',
                name: {en:'Sediment', ja:'æ²ˆæ®¿'},
                desc: {en:'Move top to bottom.', ja:'ä¸€ç•ªä¸Šã‚’ä¸€ç•ªä¸‹ã¸'}
            },
            sedative: {
                id: 'sedative', type: 'consumable', cost: 12, icon: 'ğŸ’¤',
                name: {en:'Sedative', ja:'é®é™å‰¤'},
                desc: {en:'Set Pressure to 0.', ja:'åœ§åŠ›ã‚’0ã«ã™ã‚‹'}
            },
            layer_swap: {
                id: 'layer_swap', type: 'consumable', cost: 12, icon: 'ğŸ”—',
                name: {en:'Layer Swap', ja:'å±¤äº¤æ›'},
                desc: {en:'Swap top 2 layers.', ja:'ä¸Š2ã¤ã®å±¤ã‚’å…¥ã‚Œæ›¿ãˆ'}
            },
            vacuum: {
                id: 'vacuum', type: 'consumable', cost: 14, icon: 'ğŸŒ€',
                name: {en:'Obsidian Vacuum', ja:'é»’å¸å¼•æ©Ÿ'},
                desc: {en:'Remove all top Obsidian.', ja:'ä¸€ç•ªä¸Šã®é»’ã‚¤ãƒ³ã‚¯ã‚’å…¨é™¤å»'}
            },
            midas: {
                id: 'midas', type: 'consumable', cost: 8, icon: 'ğŸ–ï¸',
                name: {en:'Alchemy Stone', ja:'å¯¾é»’å¤‰æˆ'},
                desc: {en:'Obsidian > Essence.', ja:'ä¸€ç•ªä¸Šã®é»’ã‚’ã‚¨ãƒƒã‚»ãƒ³ã‚¹ã«'}
            },
            shaker: {
                id: 'shaker', type: 'consumable', cost: 5, icon: 'ğŸ²',
                name: {en:'Shaker', ja:'ã‚·ã‚§ã‚¤ã‚«ãƒ¼'},
                desc: {en:'Shuffle tube.', ja:'ä¸­èº«ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«'}
            },
            cursed_sludge: {
                id: 'cursed_sludge', type: 'consumable', cost: 6, icon: 'âš«',
                name: {en:'Cursed Sludge', ja:'å‘ªã„ã®æ³¥'},
                desc: {en:'Add Obsidian if space.', ja:'ç©ºããŒã‚ã‚Œã°é»’ã‚’è¿½åŠ '}
            },
            scraper: {
                id: 'scraper', type: 'consumable', cost: 4, icon: 'ğŸª’',
                name: {en:'Scraper', ja:'ç…¤ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ‘ãƒ¼'},
                desc: {en:'Remove 1 top Black.', ja:'ä¸€ç•ªä¸Šã®é»’ã‚’1å±¤ã ã‘å‰Šã‚‹'}
            },
            transfer: {
                id: 'transfer', type: 'consumable', cost: 10, icon: 'ğŸ§´',
                name: {en:'Surface Transfer', ja:'æ°´é¢ç§»é€'},
                desc: {en:'Move top 1 segment anywhere.', ja:'æœ€ä¸Šæ®µã®1å±¤ã‚’è‰²ã‚’ç„¡è¦–ã—ã¦ç©ºãã®ã‚ã‚‹å ´æ‰€ã¸ç§»ã™'}
            },
            vaporizer: {
                id: 'vaporizer', type: 'consumable', cost: 7, icon: 'â™¨ï¸',
                name: {en:'Vaporizer', ja:'å¾®é‡è’¸ç™º'},
                desc: {en:'Delete top 1 segment.', ja:'æœ€ä¸Šæ®µã®1å±¤ã‚’æ¶ˆæ»…ã•ã›ã‚‹'}
            },
            // booster: {
            //     id: 'booster', type: 'consumable', cost: 6, icon: 'ğŸŒ¡ï¸',
            //     name: {en:'Condenser', ja:'é€†å¾®é‡å‡ç¸®'},
            //     desc: {en:'Add 1 top color (Pressure +3).', ja:'æœ€ä¸Šæ®µã¨åŒã˜è‰²ã‚’1å±¤è¿½åŠ ã™ã‚‹ã€‚ä»£å„Ÿï¼šåœ§åŠ›+3'}
            // }
        };

        const INSTANT_ITEMS = [
            { 
                id:'heal', type:'stat', cost:8, 
                name:{en:'Stabilizer', ja:'å®‰å®šå‰¤'}, 
                desc:{en:'Heal +1 HP', ja:'HP+1'}, 
                apply(gs){ 
                    gs.hp = Math.min(gs.maxHp, gs.hp + 1);
                    showToast('HP Recovered!', 'rose'); 
                } 
            },
            { 
                id:'panacea', type:'stat', cost:20, 
                name:{en:'Panacea', ja:'ä¸‡èƒ½è–¬'}, 
                desc:{en:'HP+2', ja:'HP+2'}, 
                apply(gs){ 
                    gs.hp = Math.min(gs.maxHp, gs.hp + 2);
                    showToast('Full Restore!', 'emerald'); 
                } 
            },
            { 
                id:'dark_pact', type:'stat', cost:0, 
                name:{en:'Dark Pact', ja:'é»’ã®å¥‘ç´„'}, 
                desc:{en:'HP-1, +20 Ess', ja:'HP-2, +20ã‚¨ãƒƒã‚»ãƒ³ã‚¹'}, 
                apply(gs){ 
                    if(gs.hp > 2){
                        gs.hp -= 2; gs.essence += 20; 
                        showToast('Power at a cost...', 'purple'); 
                    } else {
                        showToast('Too weak...', 'red');
                    }
                } 
            },
            { 
                id:'mystery_box', type:'stat', cost:8, 
                name:{en:'Mystery Box', ja:'ç¦è¢‹'}, 
                desc:{en:'Random Item', ja:'ãƒ©ãƒ³ãƒ€ãƒ ã‚¢ã‚¤ãƒ†ãƒ '}, 
                apply(gs){ 
                    const keys = Object.keys(ITEMS);
                    const gift = pick(keys);
                    if(!gs.inventory[gift]) gs.inventory[gift] = 0;
                    gs.inventory[gift]++;
                    showToast(`Got ${ITEMS[gift].name[currentLang==='ja'?'ja':'en']}!`, 'yellow');
                } 
            }
        ];

        const SHOP_POOL = [
            ...INSTANT_ITEMS,
            ...Object.values(ITEMS).map(i => ({ id: `buy_${i.id}`, type: 'item', ref: i }))
        ];

        // --- ã‚²ãƒ¼ãƒ çŠ¶æ…‹ ---
        const gameState = {
            floor: 1,
            essence: 0,
            hp: 3,
            maxHp: 3,
            turnCount: 0, 
            capacity: 4,
            tubeCount: 0,
            selectedIdx: null,
            tubes: [],
            busy: false,
            perks: {},
            inventory: {}, 
            pressure: 0,
            pressureMax: 14,
            catalystAvailable: true,
            refluxUses: 0,
            momentumTurns: 0,
            history: [],
            primaryGoal: null,
            secondaryGoal: null,
            secondaryProgress: 0,
            focusIdx: null, 
            currentPerkChoices: null,
            currentShopOffers: null,
            pipetteMode: false,
            targetMode: null, 
            pendingSkill: null, 
            extractorHeldColor: null, 
            rerollCoupons: 0,
            pendingPerkId: null, // Track selected perk before confirmation
        };

        // --- DOM ---
        const tubesContainer = ui('tubes-container');
        const boardArea = ui('board-area');
        const boardScrollArea = ui('board-scroll-area');
        const skillsContainer = ui('skills-container');
        const startScreen = ui('start-screen');
        const perkScreen = ui('perk-screen');
        const perkCards = ui('perk-cards');
        const shopCards = ui('shop-cards');
        const continueBtn = ui('continue-btn');
        const rerollBtn = ui('reroll-btn');
        const helpScreen = ui('help-screen');
        const mutationsScreen = ui('mutations-screen');
        const eventScreen = ui('event-screen');
        const eventChoices = ui('event-choices');
        const devTests = ui('dev-tests');
        const alertBanner = ui('alert-banner');
        const undoBtn = ui('btn-undo');
        const continueRunBtn = ui('continue-run-btn');

        // --- Helper ---
        function getPerkLevel(id){ return gameState.perks[id] || 0; }
        function hasPerk(id){ return (gameState.perks[id] || 0) > 0; }
        function getPerkDesc(id, level=1){
            const def = PERKS[id];
            let txt = currentLang==='ja' ? def.desc.ja : def.desc.en;
            txt = txt.replace(/\[Lv\]/g, level);
            txt = txt.replace(/\[4 \+ Lv\]/g, 4 + level);
            txt = txt.replace(/\[6 \- Lv\]/g, 6 - level);
            txt = txt.replace(/\[Lv x 20\]/g, level * 20);
            txt = txt.replace(/\[Lv x 3\]/g, level * 3);
            txt = txt.replace(/\[Lv x 4\]/g, level * 4);
            txt = txt.replace(/\[2 \+ Lv\]/g, 2 + level);
            txt = txt.replace(/\[1 \+ Lv\]/g, 1 + level);
            txt = txt.replace(/\[10 \+ Lv x 5\]/g, 10 + level * 5);
            txt = txt.replace(/\[Lv x 10\]/g, level * 10);
            txt = txt.replace(/\[15 \+ Lv x 5\]/g, 15 + level * 5);
            txt = txt.replace(/\[Lv x 15\]/g, level * 15);
            txt = txt.replace(/\[Lv x 2\]/g, level * 2);
            return txt;
        }

        // --- Game Logic ---
        function tubeTop(t){ return t.length ? t[t.length-1] : null; }
        function tubeFree(t){ return gameState.capacity - t.length; }
        
        // Added: count remaining segments for dynamic completion logic
        function getBoardCounts(){
            const counts = {};
            gameState.tubes.forEach(t => t.forEach(c => counts[c] = (counts[c]||0)+1));
            return counts;
        }

        function isCompleteTube(t, counts=null){
            if (!t || t.length === 0) return false;
            if(!counts) counts = getBoardCounts();

            const c = t[0];
            if (!t.every(x => x === c)) return false;
            
            const total = counts[c] || 0;
            // Complete if full capacity OR all remaining segments are here
            return t.length >= Math.min(gameState.capacity, total);
        }
        
        function colorMeta(key){ return COLOR_POOL.find(c => c.key===key); }
        function colorName(key){ const m=colorMeta(key); return currentLang==='ja' ? m.name.ja : m.name.en; }

        function generateGoals(){
            const flat = gameState.tubes.flat();
            const presentColors = new Set(flat);
            presentColors.delete('K'); 
            const colors = [...presentColors];

            const roll = Math.random();

            if (roll < 0.65) { // 65%ã®ç¢ºç‡ã§ã€Œã™ã¹ã¦ã®è‰²ã€ã‚’ç›®æ¨™
                gameState.primaryGoal = {
                    type: 'completeAll',
                    text: currentLang === 'ja' ? 'ã™ã¹ã¦ã®è‰²ã‚’å®Œæˆ' : 'Complete All Colors'
                };
            } else if (roll < 0.30) { // 30%ã®ç¢ºç‡ã§ã€Œã™ã¹ã¦ã®è‰²ã€ã‚’ç›®æ¨™
                const maxN = colors.length;
                const n = clamp(Math.floor(maxN / 1.5), 1, maxN);
                gameState.primaryGoal = {
                    type:'completeN', n:n,
                    text: currentLang==='ja' ? `ã„ãšã‚Œã‹${n}è‰²ã‚’å®Œæˆ` : `Complete any ${n} colors`
                };
            } else { // æ®‹ã‚Š
                const c = pick(colors);
                gameState.primaryGoal = {
                    type:'completeColor', color:c,
                    text: currentLang==='ja' ? `${colorName(c)}ã‚’å®Œæˆ` : `Complete ${colorName(c)}`
                };
            }
            
            const sroll = Math.random();
            const par = 14 + Math.floor(gameState.floor / 2) + 5; 
            if (sroll < 0.5){
                gameState.secondaryGoal = {
                    type:'speed', limit: par,
                    text: currentLang==='ja' ? `${par}ã‚¿ãƒ¼ãƒ³ä»¥å†…ã«1æœ¬å®Œæˆ` : `Complete 1 within ${par} turns`
                };
            } else {
                gameState.secondaryGoal = {
                    type:'combo', need:2,
                    text: currentLang==='ja' ? 'é€£ç¶šå®Œæˆï¼ˆã‚³ãƒ³ãƒœï¼‰' : 'Combo: 2 in a row'
                };
            }
            gameState.secondaryProgress = 0;
            renderHUD();
        }

        function checkPrimaryGoal(){
            const counts = getBoardCounts();

            if (gameState.primaryGoal.type === 'completeAll') { 
                // ç›¤é¢ã«å­˜åœ¨ã™ã‚‹é»’ä»¥å¤–ã®ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªè‰²ã®æ•°ã‚’å–å¾—
                const flat = gameState.tubes.flat();
                const colorsOnBoard = new Set(flat.filter(c => c !== 'K')).size;
                
                // å®Œæˆã—ãŸç“¶ã®æ•°ï¼ˆé»’ä»¥å¤–ï¼‰ãŒã€ç›¤é¢ã«ã‚ã‚‹è‰²ã®ç¨®é¡æ•°ã¨ä¸€è‡´ã™ã‚‹ã‹ç¢ºèª
                return countCompletedTubes(counts) >= colorsOnBoard;
            }
            if (gameState.primaryGoal.type === 'completeN') {
                return countCompletedTubes(counts) >= gameState.primaryGoal.n;
            }
            if (gameState.primaryGoal.type === 'completeColor'){
                return gameState.tubes.some(t => isCompleteTube(t, counts) && t[0] === gameState.primaryGoal.color);
            }
            if (gameState.primaryGoal.type === 'survive') return false; 
            return false;
        }
        
        function checkLevelClear(){
            const counts = getBoardCounts();
            if (checkPrimaryGoal()) return true;
            const allClean = gameState.tubes.every(t => t.length === 0 || (isCompleteTube(t, counts) && t[0] !== 'K'));
            if (allClean) return true;
            return false;
        }

        function onLevelClear(){
            const base = 6;
            const bonus = secondarySucceeded() ? 4 : 0;
            gameState.essence += (base + bonus);
            
            const msg = currentLang==='ja' 
                ? `ã‚¨ãƒªã‚¢ç¢ºä¿! +${base}âœ¨${bonus>0 ? ` (ãƒœãƒ¼ãƒŠã‚¹ +${bonus}âœ¨)` : ''}`
                : `Area Cleared! +${base}âœ¨${bonus>0 ? ` (Bonus +${bonus}âœ¨)` : ''}`;
            
            showToast(msg, bonus>0 ? 'emerald' : 'sky');
            saveGame();
            setTimeout(() => openPerkScreen(false), 1500);
        }

        function checkSecondaryGoalOnComplete(){
            if (!gameState.secondaryGoal) return;
            if (gameState.secondaryGoal.type === 'speed'){
                if (gameState.turnCount <= gameState.secondaryGoal.limit){
                    gameState.secondaryProgress = 1; 
                }
            } else if (gameState.secondaryGoal.type === 'combo'){
                gameState.secondaryProgress += 1;
                if(hasPerk('flow_mastery') && gameState.secondaryProgress >= 2){
                    const lv = getPerkLevel('flow_mastery');
                    gameState.pressure = Math.max(0, gameState.pressure - (lv * 2));
                    showFloatText(0, `Flow! -${lv*2} Pressure`, '#38bdf8');
                }
            }
        }

        function secondarySucceeded(){
            if (!gameState.secondaryGoal) return false;
            if (gameState.secondaryGoal.type === 'speed') return gameState.secondaryProgress >= 1;
            if (gameState.secondaryGoal.type === 'combo') return gameState.secondaryProgress >= gameState.secondaryGoal.need;
            return false;
        }
        
        function isDeadlocked(){
            for(let i=0; i<gameState.tubes.length; i++){
                if(gameState.tubes[i].length === 0) continue; 
                for(let j=0; j<gameState.tubes.length; j++){
                    if(i===j) continue;
                    const check = canPour(i, j);
                    if(check.ok) return false; 
                }
            }
            return true; 
        }

        function generateBoard(){
            const floor = gameState.floor;
            gameState.tubeCount = Math.min(10, 6 + Math.floor((floor-1)/2));
            const numColors = gameState.tubeCount - 2;
            const safeNumColors = Math.min(numColors, COLOR_POOL.length);
            const pool = COLOR_POOL.slice(0, Math.min(COLOR_POOL.length, safeNumColors + (floor > 5 ? 1 : 0))).map(c=>c.key);
            const colors = [];
            let failsafe = 0;
            while(colors.length < safeNumColors){
                const c = pick(pool);
                if(!colors.includes(c)) colors.push(c);
                failsafe++;
                if(failsafe > 100) break; 
            }
            const bag = [];
            for (const c of colors) for (let i=0;i<gameState.capacity;i++) bag.push(c);
            for (let i=bag.length-1;i>0;i--){
                const j = randInt(i+1);
                [bag[i], bag[j]] = [bag[j], bag[i]];
            }
            const tubes = Array.from({length: gameState.tubeCount}, () => []);
            let k=0;
            for (let t=0;t<safeNumColors;t++){
                for (let s=0;s<gameState.capacity;s++) {
                    if(k < bag.length) tubes[t].push(bag[k++]);
                }
            }
            for (let i=0;i<20;i++){
                const t1 = randInt(safeNumColors);
                const t2 = randInt(safeNumColors);
                if (t1===t2) continue;
                const s1 = randInt(gameState.capacity);
                const s2 = randInt(gameState.capacity);
                if(tubes[t1][s1] && tubes[t2][s2]) {
                    [tubes[t1][s1], tubes[t2][s2]] = [tubes[t2][s2], tubes[t1][s1]];
                }
            }
            gameState.tubes = tubes;
            updateTubeLayout();
        }
        
        function updateTubeLayout(){
            const cap = gameState.capacity;
            let segHeight = 40;
            if(cap >= 6) segHeight = 32;
            else if(cap >= 5) segHeight = 36;
            const tubeHeight = (segHeight * cap) + 40;
            document.documentElement.style.setProperty('--segment-height', `${segHeight}px`);
            document.documentElement.style.setProperty('--tube-height', `${tubeHeight}px`);
        }

        // --- ç„¡é™ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç”¨å®šæ•° ---
        const CLONE_PADDING = 10; // å·¦å³ã«é…ç½®ã™ã‚‹ã‚¯ãƒ­ãƒ¼ãƒ³ã®æ•°

        function renderBoard(){
            tubesContainer.innerHTML = '';
            const deadlocked = isDeadlocked();
            if (alertBanner) alertBanner.style.opacity = deadlocked ? '1' : '0';
            
            const counts = getBoardCounts();
            const totalTubes = gameState.tubes.length;

            // ãƒãƒ¥ãƒ¼ãƒ–ãŒç„¡ã„å ´åˆã®ã‚¨ãƒ©ãƒ¼å›é¿
            if (totalTubes === 0) return;

            // è¡¨ç¤ºãƒªã‚¹ãƒˆã‚’ä½œæˆ: [æœ«å°¾ã®ã‚¯ãƒ­ãƒ¼ãƒ³] + [æœ¬ä½“] + [å…ˆé ­ã®ã‚¯ãƒ­ãƒ¼ãƒ³]
            const renderList = [];
            
            // å·¦å´ã®ã‚¯ãƒ­ãƒ¼ãƒ³ (æœ«å°¾ã®æ•°å€‹)
            for(let i = 0; i < CLONE_PADDING; i++) {
                // è² ã®æ•°ã«ãªã‚‰ãªã„ã‚ˆã†å®‰å…¨ã«å‰°ä½™è¨ˆç®—ã‚’è¡Œã†
                // (totalTubes - CLONE_PADDING + i) ã ã¨ãƒã‚¤ãƒŠã‚¹ã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚è£œæ­£
                let idx = (totalTubes - CLONE_PADDING + i) % totalTubes;
                if (idx < 0) idx += totalTubes;
                renderList.push({ idx: idx, isClone: true });
            }
            
            // æœ¬ä½“
            for(let i = 0; i < totalTubes; i++) {
                renderList.push({ idx: i, isClone: false });
            }
            
            // å³å´ã®ã‚¯ãƒ­ãƒ¼ãƒ³ (å…ˆé ­ã®æ•°å€‹)
            for(let i = 0; i < CLONE_PADDING; i++) {
                // â˜…ä¿®æ­£ç®‡æ‰€: totalTubesã‚’è¶…ãˆãŸã‚‰0ã«æˆ»ã‚‹ã‚ˆã†ã«å‰°ä½™ç®—ã‚’è¿½åŠ 
                const idx = i % totalTubes; 
                renderList.push({ idx: idx, isClone: true });
            }

            renderList.forEach((item) => {
                const i = item.idx;
                const segments = gameState.tubes[i];
                
                // ä¸‡ãŒä¸€ undefined ã ã£ãŸå ´åˆã®ã‚¬ãƒ¼ãƒ‰
                if (!segments) return;

                const tube = document.createElement('div');
                tube.className = 'tube';
                tube.dataset.idx = String(i);
                if (item.isClone) tube.classList.add('clone-tube');

                if (i === gameState.selectedIdx) tube.classList.add('selected');
                
                if (gameState.focusIdx !== null && i === gameState.focusIdx) {
                    tube.classList.add('tube-focused');
                }

                if (deadlocked) tube.classList.add('deadlock-glow');
                
                const isTwoStepSkill = ['extractor', 'transfer'].includes(gameState.targetMode);
                if (isTwoStepSkill && gameState.extractorHeldColor) {
                    if(segments.length < gameState.capacity) {
                        tube.classList.add('target-mode');
                        tube.style.cursor = 'crosshair';
                    }
                } 
                else if (gameState.targetMode) {
                    if(gameState.targetMode === 'extractor' && segments.length === 0) {}
                    else {
                        tube.classList.add('target-mode');
                        tube.style.cursor = 'crosshair';
                    }
                }
                
                if (isCompleteTube(segments, counts)) {
                    if (segments[0] !== 'K') {
                        tube.style.boxShadow = `0 0 15px ${colorMeta(segments[0]).hex}`;
                        tube.style.borderColor = `rgba(255,255,255,0.5)`;
                    }
                }

                const water = document.createElement('div');
                water.className = 'water-container';
                segments.forEach(key => {
                    const c = colorMeta(key)?.hex || '#64748b';
                    const seg = document.createElement('div');
                    seg.className = 'water-segment';
                    seg.style.backgroundColor = c;
                    water.appendChild(seg);
                });
                tube.appendChild(water);
                
                tube.addEventListener('click', (e) => {
                    if(isDragging) return;
                    handleTubeClick(i);
                });
                
                tubesContainer.appendChild(tube);
            });

            renderSkills();
            requestAnimationFrame(() => {
                adjustBoardScale();
                initInfiniteScroll();
            });
        }

        function adjustBoardScale() {
            if (!boardArea || !tubesContainer) return;
            tubesContainer.style.transform = 'none';
            const availableH = boardArea.clientHeight;
            const contentH = tubesContainer.scrollHeight;
            const safeH = availableH * 0.95;
            let scale = 1;
            if (contentH > safeH) {
                scale = Math.max(0.6, safeH / contentH);
                tubesContainer.style.transform = `scale(${scale})`;
            }
        }
        
        window.addEventListener('resize', () => {
            requestAnimationFrame(adjustBoardScale);
        });
        
        function renderSkills(){
            skillsContainer.innerHTML = '';
            Object.keys(gameState.inventory).forEach(key => {
                const count = gameState.inventory[key];
                if(count > 0 || ITEMS[key].type === 'tool'){
                    const def = ITEMS[key];
                    const btn = document.createElement('button');
                    btn.className = 'skill-btn w-12 h-12 glass-panel flex items-center justify-center text-xl rounded-full border border-white/10 shrink-0';
                    btn.dataset.id = key; 
                    const name = currentLang==='ja' ? def.name.ja : def.name.en;
                    const desc = currentLang==='ja' ? def.desc.ja : def.desc.en;
                    let badgeHtml = '';
                    if(def.type === 'consumable'){
                        badgeHtml = `<span class="absolute -top-1 -right-1 bg-sky-500 text-[10px] font-bold px-1.5 rounded-full text-white pointer-events-none">${count}</span>`;
                    }
                    btn.innerHTML = `${def.icon}${badgeHtml}`;
                    if (key === 'pipette' && gameState.pipetteMode) btn.classList.add('active');
                    if (gameState.pendingSkill === key) btn.classList.add('pending');
                    if (gameState.targetMode === key) btn.classList.add('active-mode');
                    if (['extractor', 'transfer'].includes(gameState.targetMode) && key === gameState.targetMode) {
                        if(gameState.extractorHeldColor) {
                            btn.classList.add('extracting');
                            btn.innerHTML = `<div style="width:16px;height:16px;border-radius:50%;background:${colorMeta(gameState.extractorHeldColor).hex};border:2px solid white;"></div>` + badgeHtml;
                        } else {
                            btn.classList.add('active-mode');
                        }
                    }
                    btn.onclick = () => activateSkill(key);
                    btn.onmouseenter = () => showGlobalTooltip(btn, name, desc);
                    btn.onmouseleave = () => {
                        if(gameState.pendingSkill){
                           const pBtn = document.querySelector(`.skill-btn[data-id="${gameState.pendingSkill}"]`);
                           if(pBtn) {
                               const pDef = ITEMS[gameState.pendingSkill];
                               const pName = currentLang==='ja' ? pDef.name.ja : pDef.name.en;
                               const pDesc = currentLang==='ja' ? pDef.desc.ja : pDef.desc.en;
                               showGlobalTooltip(pBtn, pName, pDesc);
                               return;
                           }
                        }
                        hideGlobalTooltip();
                    };
                    skillsContainer.appendChild(btn);
                }
            });
            if(gameState.pendingSkill){
                const pBtn = document.querySelector(`.skill-btn[data-id="${gameState.pendingSkill}"]`);
                if(pBtn){
                    const pDef = ITEMS[gameState.pendingSkill];
                    const pName = currentLang==='ja' ? pDef.name.ja : pDef.name.en;
                    const pDesc = currentLang==='ja' ? pDef.desc.ja : pDef.desc.en;
                    showGlobalTooltip(pBtn, pName, pDesc);
                }
            }
        }

        function activateSkill(key){
            if(gameState.busy) return;
            const def = ITEMS[key];
            const isPending = (gameState.pendingSkill === key);
            const isActive = (gameState.targetMode === key) || (key === 'pipette' && gameState.pipetteMode);
            if (!isPending && !isActive) {
                gameState.pendingSkill = key;
                gameState.targetMode = null;
                gameState.extractorHeldColor = null; 
                showToast(currentLang==='ja'?'ã‚‚ã†ä¸€åº¦ã‚¿ãƒƒãƒ—ã—ã¦ä½¿ç”¨':'Tap again to use', 'yellow');
                renderSkills();
                renderBoard(); 
                return;
            }
            gameState.pendingSkill = null; 
            hideGlobalTooltip();
            if(key === 'summon_vial'){
                 if(gameState.inventory[key] > 0){
                     gameState.inventory[key]--;
                     gameState.tubeCount++;
                     gameState.tubes.push([]);
                     saveGame();
                     renderBoard();
                     showFloatText(gameState.tubes.length-1, "Summoned!", "#a855f7");
                     showToast(currentLang==='ja'?'ç©ºãç“¶ã‚’è¿½åŠ ã—ã¾ã—ãŸï¼':'Extra Tube Added!', 'purple');
                 }
                 return;
            }
            if(key === 'sedative'){
                 if(gameState.inventory[key] > 0){
                     gameState.inventory[key]--;
                     gameState.pressure = 0;
                     saveGame();
                     renderHUD();
                     showToast("Sedated! Pressure 0.", 'purple');
                 }
                 return;
            }
            if(def.type === 'tool' && key === 'pipette'){
                gameState.pipetteMode = !gameState.pipetteMode;
                gameState.targetMode = null; 
                gameState.selectedIdx = null; 
            } else if (def.type === 'consumable'){
                if (['extractor', 'transfer'].includes(key)) {
                     if (gameState.targetMode === key) {
                         if(gameState.extractorHeldColor){
                             showToast(currentLang==='ja'?'ä¿æŒä¸­ã®ãŸã‚ã‚­ãƒ£ãƒ³ã‚»ãƒ«ä¸å¯ï¼':'Cannot cancel while holding!', 'red');
                             return; 
                         }
                         gameState.targetMode = null;
                     } else {
                         gameState.targetMode = key;
                         gameState.extractorHeldColor = null;
                         gameState.selectedIdx = null; 
                         gameState.pipetteMode = false;
                         showToast(currentLang==='ja' ? "æŠ½å‡ºå…ƒã‚’é¸æŠã—ã¦ãã ã•ã„" : "Select source tube", 'emerald');
                     }
                } 
                else {
                    if(gameState.targetMode === key){
                        gameState.targetMode = null; 
                    } else {
                        gameState.targetMode = key;
                        gameState.selectedIdx = null; 
                        gameState.pipetteMode = false; 
                        showToast(currentLang==='ja' ? "å¯¾è±¡ã‚’é¸æŠã—ã¦ãã ã•ã„" : "Select a target tube", 'sky');
                    }
                }
            }
            renderSkills();
            renderBoard();
        }

        async function handleTubeClick(idx) {
            if (gameState.busy) return;
            if (['extractor', 'transfer'].includes(gameState.targetMode)) {
                await handleTwoStepSkill(idx);
                return;
            }
            if (gameState.targetMode) {
                await applySkillEffect(idx);
                return;
            }
            const content = gameState.tubes[idx];
            if (gameState.selectedIdx === idx) {
                gameState.selectedIdx = null;
                renderBoard();
                return;
            }
            if (gameState.selectedIdx === null) {
                const counts = getBoardCounts();
                if (content.length === 0) return;
                if (isCompleteTube(content, counts)) return; 
                gameState.selectedIdx = idx;
                renderBoard();
            } else {
                await tryPour(gameState.selectedIdx, idx);
            }
        }
        
        async function handleTwoStepSkill(idx) {
            const tube = gameState.tubes[idx];
            const skillKey = gameState.targetMode;
            if (!gameState.extractorHeldColor) {
                if (tube.length === 0) {
                    showFloatText(idx, "Empty!", "#ef4444");
                    return;
                }
                gameState.busy = true;
                const color = tube.pop();
                gameState.extractorHeldColor = color;
                showFloatText(idx, skillKey==='transfer'?"Surface Move!":"Extracted!", "#22c55e");
                renderBoard(); 
                gameState.busy = false;
                showToast(currentLang==='ja' ? "ç§»å‹•å…ˆã‚’é¸æŠã—ã¦ãã ã•ã„" : "Select destination", 'emerald');
            } 
            else {
                if (tubeFree(tube) <= 0) {
                    showFloatText(idx, "Full!", "#ef4444");
                    return;
                }
                if (skillKey === 'extractor' && tube.length > 0 && tube[tube.length-1] !== gameState.extractorHeldColor) {
                    showFloatText(idx, "Mismatch!", "#ef4444");
                    return;
                }
                pushHistory();
                tube.push(gameState.extractorHeldColor);
                gameState.extractorHeldColor = null;
                if (gameState.inventory[skillKey] > 0) {
                    let consume = true;
                    if(hasPerk('recycler')){
                        const lv = getPerkLevel('recycler');
                        if(Math.random() < lv * 0.1){
                            consume = false;
                            showToast("Recycled! Item saved.", 'purple');
                        }
                    }
                    if(consume) gameState.inventory[skillKey]--;
                }
                gameState.targetMode = null; 
                showFloatText(idx, "Placed!", "#22c55e");
                saveGame();
                renderHUD();
                renderBoard();
                
                const counts = getBoardCounts();
                if(isCompleteTube(tube, counts)){
                    await handleCompletion(idx, tube[0]);
                }
            }
        }
        
        async function applySkillEffect(idx){
            const skillKey = gameState.targetMode;
            const tube = gameState.tubes[idx];
            if(!skillKey || !gameState.inventory[skillKey] || gameState.inventory[skillKey] <= 0) return;
            let success = false;
            let consume = true;
            if(hasPerk('recycler')){
                const lv = getPerkLevel('recycler');
                if(Math.random() < lv * 0.1) consume = false;
            }
            try {
                gameState.busy = true;
                if(skillKey === 'inverter'){
                    if(tube.length < 2) showFloatText(idx, "Too Empty!", "#ef4444");
                    else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        tube.reverse(); showFloatText(idx, "Inverted!", "#a855f7"); success = true;
                    }
                } else if (skillKey === 'void_salt'){
                    if(tube.length === 0) showFloatText(idx, "Empty!", "#ef4444");
                    else {
                        if(tube[tube.length-1] !== 'K') showFloatText(idx, "Not Black!", "#ef4444");
                        else {
                            pushHistory(); if(consume) gameState.inventory[skillKey]--;
                            tube.pop(); showFloatText(idx, "Voided!", "#a855f7"); success = true;
                        }
                    }
                } else if (skillKey === 'separator'){
                    if(tube.length < 2) showFloatText(idx, "No need!", "#ef4444");
                    else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        const counts = {}; tube.forEach(c => counts[c] = (counts[c]||0)+1);
                        const newTube = []; Object.keys(counts).sort().forEach(c => { for(let i=0; i<counts[c]; i++) newTube.push(c); });
                        gameState.tubes[idx] = newTube; showFloatText(idx, "Separated!", "#a855f7"); success = true;
                    }
                } else if (skillKey === 'cycle_siphon'){
                     if(tube.length === 0) showFloatText(idx, "Empty!", "#ef4444");
                     else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        const bottom = tube.shift(); tube.push(bottom);
                        showFloatText(idx, "Cycled!", "#a855f7"); success = true;
                     }
                } else if (skillKey === 'sedative'){ 
                     if(tube.length < 2) showFloatText(idx, "No need!", "#ef4444");
                     else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        const top = tube.pop(); tube.unshift(top); 
                        showFloatText(idx, "Sunk!", "#a855f7"); success = true;
                     }
                } else if (skillKey === 'layer_swap'){ 
                    if(tube.length < 2) showFloatText(idx, "Need 2+", "#ef4444");
                    else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        const t1 = tube[tube.length-1]; const t2 = tube[tube.length-2];
                        tube[tube.length-1] = t2; tube[tube.length-2] = t1;
                        showFloatText(idx, "Swapped!", "#a855f7"); success = true;
                    }
                } else if (skillKey === 'vacuum'){ 
                    if(tube.length === 0) showFloatText(idx, "Empty!", "#ef4444");
                    else if(tube[tube.length-1] !== 'K') showFloatText(idx, "Obsidian Only!", "#ef4444");
                    else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        while(tube.length > 0 && tube[tube.length-1] === 'K') tube.pop();
                        showFloatText(idx, "Vacuumed!", "#a855f7"); success = true;
                    }
                } else if (skillKey === 'midas'){ 
                    if(tube.length === 0) showFloatText(idx, "Empty!", "#ef4444");
                    else if(tube[tube.length-1] !== 'K') showFloatText(idx, "Obsidian Only!", "#ef4444");
                    else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        tube.pop(); gameState.essence += 2; 
                        showFloatText(idx, "Transmuted! (+2âœ¨)", "#fbbf24"); success = true;
                    }
                } else if (skillKey === 'shaker'){
                    if(tube.length < 2) showFloatText(idx, "No need!", "#ef4444");
                    else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        for (let i = tube.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [tube[i], tube[j]] = [tube[j], tube[i]]; }
                        showFloatText(idx, "Shaken!", "#a855f7"); success = true;
                    }
                } else if (skillKey === 'cursed_sludge'){ 
                    if(tube.length >= gameState.capacity) showFloatText(idx, "Full!", "#ef4444");
                    else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        tube.push('K'); showFloatText(idx, "Cursed!", "#0f172a"); success = true;
                    }
                } else if (skillKey === 'scraper'){
                    if(tube.length === 0 || tube[tube.length-1] !== 'K') showFloatText(idx, "Black only!", "#ef4444");
                    else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        tube.pop(); showFloatText(idx, "Scraped!", "#94a3b8"); success = true;
                    }
                } else if (skillKey === 'vaporizer'){
                    if(tube.length === 0) showFloatText(idx, "Empty!", "#ef4444");
                    else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        tube.pop(); showFloatText(idx, "Vaporized!", "#94a3b8"); success = true;
                    }
                } else if (skillKey === 'booster'){
                    if(tube.length === 0) showFloatText(idx, "Empty!", "#ef4444");
                    else if(tube.length >= gameState.capacity) showFloatText(idx, "Full!", "#ef4444");
                    else {
                        // ãƒã‚°ä¿®æ­£: ç¾åœ¨ã®ãƒœãƒ¼ãƒ‰ä¸Šã®ç·æ•°ã‚’ç¢ºèªã€‚å®¹é‡ä»¥ä¸Šãªã‚‰è¿½åŠ ç¦æ­¢
                        const color = tube[tube.length-1];
                        const counts = getBoardCounts();
                        if ((counts[color] || 0) >= gameState.capacity) {
                            showFloatText(idx, "Maxed Out!", "#ef4444");
                            return; // å‡¦ç†ä¸­æ–­
                        }
                        
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        tube.push(tube[tube.length-1]); gameState.pressure += 3;
                        showFloatText(idx, "Boosted! (+3 P)", "#3b82f6"); success = true;
                    }
                }
            } finally {
                gameState.busy = false;
            }
            if(success){
                gameState.targetMode = null; renderHUD(); renderBoard(); saveGame();
                const counts = getBoardCounts();
                if(isCompleteTube(gameState.tubes[idx], counts)) await handleCompletion(idx, gameState.tubes[idx][0]);
            }
        }

        function canPour(fromIdx, toIdx){
            if (fromIdx === toIdx) return {ok:false};
            const from = gameState.tubes[fromIdx], to = gameState.tubes[toIdx];
            if (!from.length || tubeFree(to) <= 0) return {ok:false};
            const top = tubeTop(from), toTop = tubeTop(to);
            if (toTop && toTop !== top) return {ok:false};
            let count = 1;
            if(!gameState.pipetteMode) { for (let i=from.length-2;i>=0;i--) if (from[i] === top) count++; else break; }
            return {ok:true, color: top, moveCount: Math.min(count, tubeFree(to))};
        }

        function pushHistory(){
            gameState.history.push({
                tubes: deepCopy(gameState.tubes), turnCount: gameState.turnCount, pressure: gameState.pressure, hp: gameState.hp,
                secondaryProgress: gameState.secondaryProgress, catalystAvailable: gameState.catalystAvailable, essence: gameState.essence,
                inventory: {...gameState.inventory}, tubeCount: gameState.tubeCount, capacity: gameState.capacity,
                momentumTurns: gameState.momentumTurns, refluxUses: gameState.refluxUses
            });
            if (gameState.history.length > 50) gameState.history.shift();
        }

        async function tryPour(fromIdx, toIdx){
            const check = canPour(fromIdx, toIdx);
            if (!check.ok){
                const content = gameState.tubes[toIdx];
                const counts = getBoardCounts();
                gameState.selectedIdx = (content.length > 0 && !isCompleteTube(content, counts)) ? toIdx : null;
                renderBoard(); return;
            }
            try {
                pushHistory(); gameState.busy = true;
                let pressureImmune = false;
                if(hasPerk('steady_hand') && gameState.turnCount < getPerkLevel('steady_hand') * 3) pressureImmune = true;
                if(gameState.momentumTurns > 0) { gameState.momentumTurns--; pressureImmune = true; } 
                if(!pressureImmune) gameState.pressure += 1;
                gameState.turnCount += 1;
                await animatePour(fromIdx, toIdx, check.color, check.moveCount);
                const from = gameState.tubes[fromIdx], to = gameState.tubes[toIdx];
                for (let i=0;i<check.moveCount;i++) to.push(from.pop());
                saveGame();
                const counts = getBoardCounts();
                if(isCompleteTube(to, counts)) await handleCompletion(toIdx, to[0]);
                else if (gameState.secondaryGoal?.type === 'combo') gameState.secondaryProgress = 0;
                if (gameState.pressure >= gameState.pressureMax){
                    if(hasPerk('void_shield') && Math.random() < getPerkLevel('void_shield') * 0.15) {
                        gameState.pressure = 0; showFloatText(0, "Void Shield!", "#a855f7");
                    } else {
                        gameState.pressure = 0; gameState.hp -= 1;
                        ui('game-container').classList.add('animate-shake'); setTimeout(()=>ui('game-container').classList.remove('animate-shake'), 500);
                        corruptRandomSegment(); saveGame();
                    }
                }
            } finally {
                gameState.selectedIdx = null; gameState.busy = false;
            }
            if (gameState.hp <= 0){ clearSave(); openPerkScreen(true); return; }
            if (checkLevelClear()){ onLevelClear(); return; }
            renderHUD(); renderBoard();
        }

        async function handleCompletion(tubeIdx, colorKey){
            const tubeEl = tubeCenterEl(tubeIdx);
            if (colorKey === 'K') {
                showFloatText(tubeIdx, "Purged!", "#94a3b8");
                if(hasPerk('purification')){
                    const lv = getPerkLevel('purification');
                    gameState.pressure = Math.max(0, gameState.pressure - (2 + lv));
                    gameState.essence += (1 + lv);
                    showFloatText(tubeIdx, `Purified! (-${2+lv} P)`, "#38bdf8");
                }
                tubeEl.classList.add('evaporating'); await new Promise(r => setTimeout(r, 600));
                gameState.tubes[tubeIdx] = []; tubeEl.classList.remove('evaporating');
                renderBoard(); if (checkLevelClear()) onLevelClear(); return; 
            }
            if (hasPerk('catalyst') && gameState.catalystAvailable){
                const lv = getPerkLevel('catalyst'); gameState.pressure = Math.max(0, gameState.pressure - (4 + lv));
                gameState.catalystAvailable = false; showFloatText(tubeIdx, `Catalyst! (-${4+lv} P)`);
            }
            if (hasPerk('efficiency') && Math.random() < getPerkLevel('efficiency') * 0.20){
                gameState.essence += 1; showFloatText(tubeIdx, "Efficiency! (+1âœ¨)", "#fbbf24");
            }
            if(hasPerk('heavy_mastery') && gameState.capacity >= 5){
                 const lv = getPerkLevel('heavy_mastery'); gameState.pressure = Math.max(0, gameState.pressure - (2 + lv));
                 showFloatText(tubeIdx, `Heavy Bonus! (-${2+lv} P)`, "#a855f7");
            }
            if(hasPerk('momentum')) gameState.momentumTurns = getPerkLevel('momentum'); 
            if (colorKey === 'R' && hasPerk('crimson_resonance')) {
                const lv = getPerkLevel('crimson_resonance'); gameState.hp = Math.min(gameState.maxHp, gameState.hp + 1);
                gameState.pressure += (6 - lv); showFloatText(tubeIdx, `Crimson Heal! (+${6-lv} P)`, "#dc2626");
            }
            if (colorKey === 'B' && hasPerk('azure_cycle')) {
                const lv = getPerkLevel('azure_cycle'); gameState.pressure = Math.max(0, gameState.pressure - (lv * 3));
                showFloatText(tubeIdx, `Azure Cool! (-${lv*3} P)`, "#3b82f6");
            }
            if (colorKey === 'Y' && hasPerk('amber_greed')) {
                gameState.essence += (getPerkLevel('amber_greed') * 2);
                showFloatText(tubeIdx, `Amber Gold! (+${getPerkLevel('amber_greed')*2}âœ¨)`, "#fbbf24");
            }
            if (colorKey === 'W' && hasPerk('ivory_sanctuary')) {
                let count = 0, lv = getPerkLevel('ivory_sanctuary');
                for (let i = 0; i < lv; i++) {
                    const blackTubes = gameState.tubes.map((t, idx) => ({t, idx})).filter(obj => obj.t.includes('K'));
                    if (blackTubes.length > 0) {
                        const target = pick(blackTubes), kIdx = gameState.tubes[target.idx].indexOf('K');
                        if (kIdx !== -1) { gameState.tubes[target.idx].splice(kIdx, 1); count++; }
                    }
                }
                if (count > 0) showFloatText(tubeIdx, `Ivory Purge! (${count})`, "#e2e8f0");
            }
            if (colorKey === 'G' && hasPerk('emerald_vitality')) {
                gameState.pressure = Math.floor(gameState.pressure / 2); showFloatText(tubeIdx, `Emerald Calm!`, "#22c55e");
            }
            if (colorKey === 'P' && hasPerk('amethyst_surge')) {
                gameState.refluxUses += getPerkLevel('amethyst_surge');
                showFloatText(tubeIdx, `Amethyst Echo! (+${getPerkLevel('amethyst_surge')} Undo)`, "#a855f7");
            }
            if (colorKey === 'O' && hasPerk('orange_drive')) {
                gameState.momentumTurns += (getPerkLevel('orange_drive') * 2); showFloatText(tubeIdx, `Orange Drive!`, "#f97316");
            }
            if (colorKey === 'T' && hasPerk('teal_equilibrium')) { gameState.secondaryProgress += 1; showFloatText(tubeIdx, `Teal Analysis!`, "#06b6d4"); }
            if (colorKey === 'M' && hasPerk('pink_luck')) {
                if (Math.random() < (getPerkLevel('pink_luck') * 0.1)) {
                    const itemKeys = Object.keys(ITEMS).filter(k => ITEMS[k].type === 'consumable'), gift = pick(itemKeys);
                    if (!gameState.inventory[gift]) gameState.inventory[gift] = 0;
                    gameState.inventory[gift]++;
                    showToast(`Pink Gift: ${ITEMS[gift].name[currentLang==='ja'?'ja':'en']}!`, "#d946ef");
                }
            }
            checkSecondaryGoalOnComplete(); saveGame(); await showCompletionEvent(colorKey);
        }

        function countCompletedTubes(counts=null){
            if(!counts) counts = getBoardCounts();
            return gameState.tubes.filter(t => isCompleteTube(t, counts) && t[0] !== 'K').length;
        }

        // --- Animations and Visuals ---
        function corruptRandomSegment(){
            const candidates = [];
            for (let i=0;i<gameState.tubes.length;i++) if (gameState.tubes[i].length < gameState.capacity && (gameState.tubes[i].length === 0 || gameState.tubes[i][gameState.tubes[i].length-1] !== 'K')) candidates.push(i);
            if (!candidates.length) return;
            const idx = pick(candidates); gameState.tubes[idx].push('K'); showFloatText(idx, "CORRUPTED!", "#ef4444");
        }

        function showFloatText(tubeIdx, text, color="#38bdf8"){
            const el = ui('tubes-container').children[tubeIdx]; if(!el) return;
            const rect = el.getBoundingClientRect(), float = document.createElement('div');
            float.textContent = text; float.style.position = 'fixed'; float.style.left = rect.left + 'px'; float.style.top = rect.top + 'px';
            float.style.color = color; float.style.fontWeight = 'bold'; float.style.fontSize = '14px'; float.style.zIndex = 100;
            float.style.textShadow = '0 2px 4px rgba(0,0,0,0.8)';
            float.animate([{ transform: 'translateY(0)', opacity: 1 }, { transform: 'translateY(-30px)', opacity: 0 }], { duration: 1000, easing: 'ease-out' });
            document.body.appendChild(float); setTimeout(()=>float.remove(), 1000);
        }

        function tubeCenterEl(idx){ 
            // åŒã˜data-idxã‚’æŒã¤è¦ç´ ï¼ˆæœ¬ä½“ã¨ã‚¯ãƒ­ãƒ¼ãƒ³ï¼‰ã®ä¸­ã‹ã‚‰ã€ç¾åœ¨ç”»é¢å†…ã«ä¸€ç•ªè¿‘ã„ã‚‚ã®ã‚’æ¢ã™
            const els = ui('tubes-container').querySelectorAll(`[data-idx="${String(idx)}"]`);
            if(els.length === 0) return null;
            if(els.length === 1) return els[0];

            const container = ui('board-scroll-area');
            const center = container.getBoundingClientRect().left + container.clientWidth / 2;
            
            let closest = els[0];
            let minDist = Infinity;

            els.forEach(el => {
                const rect = el.getBoundingClientRect();
                const elCenter = rect.left + rect.width / 2;
                const dist = Math.abs(center - elCenter);
                if(dist < minDist){
                    minDist = dist;
                    closest = el;
                }
            });
            return closest;
        }
        
        function animatePour(fromIdx, toIdx, colorKey, count){
            return new Promise((resolve) => {
                const fromEl = tubeCenterEl(fromIdx), toEl = tubeCenterEl(toIdx); if (!fromEl || !toEl){ resolve(); return; }
                const fromWater = fromEl.querySelector('.water-container'), toWater = toEl.querySelector('.water-container'), shrinkSegments = [];
                for(let i=0; i<count; i++) if(fromWater.children.length > i) shrinkSegments.push(fromWater.children[fromWater.children.length - 1 - i]);
                const isRight = toEl.getBoundingClientRect().left > fromEl.getBoundingClientRect().left;
                fromEl.style.transition = 'transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1)'; fromEl.style.transform = `translateY(-10px) rotate(${isRight ? 45 : -45}deg)`; fromEl.style.zIndex = 50; 
                setTimeout(() => {
                    shrinkSegments.forEach(seg => { if(seg) { seg.style.height = '0px'; seg.style.opacity = '0'; seg.style.borderTop = 'none'; } });
                    for(let i=0; i<count; i++){
                        const newSeg = document.createElement('div'); newSeg.className = 'water-segment'; newSeg.style.backgroundColor = colorMeta(colorKey).hex;
                        newSeg.style.height = '0px'; newSeg.style.opacity = '0.5'; toWater.appendChild(newSeg); void newSeg.offsetWidth;
                        newSeg.style.height = 'var(--segment-height)'; newSeg.style.opacity = '1';
                    }
                }, 50);
                setTimeout(() => { fromEl.style.transform = ''; fromEl.style.zIndex = ''; resolve(); }, 400); 
            });
        }

        function showCompletionEvent(colorKey){
            return new Promise((resolve) => {
                const name = colorName(colorKey), title = currentLang==='ja' ? `${name}ã®å®‰å®šåŒ–` : `${name} Stabilized`, desc = currentLang==='ja' ? `${name}ã‚’å®Œæˆã•ã›ãŸã€‚\næ·±æ·µãŒåå¿œã—ã¦ã„ã‚‹ã€‚` : `You completed ${name}.\nThe abyss reacts to your achievement.`;
                const choices = buildEventChoices(colorKey); ui('event-kicker').textContent = t('eventKicker'); ui('event-title').textContent = title; ui('event-desc').textContent = desc; eventChoices.innerHTML = '';
                choices.forEach(ch => {
                    const card = document.createElement('div'); card.className = 'glass-panel perk-card p-4 cursor-pointer hover:bg-white/5 border-l-4 border-l-sky-500';
                    card.innerHTML = `<div class="text-[10px] text-sky-300 uppercase tracking-[0.35em] mb-1">${ch.kicker}</div><div class="text-xl font-black text-white">${ch.title}</div><div class="text-slate-400 text-xs mt-2 leading-relaxed">${ch.desc}</div>`;
                    card.onclick = () => { ch.apply(); saveGame(); eventScreen.classList.add('hidden'); eventScreen.classList.remove('flex'); renderHUD(); renderBoard(); resolve(); };
                    eventChoices.appendChild(card);
                });
                eventScreen.classList.remove('hidden'); eventScreen.classList.add('flex');
            });
        }
        function buildEventChoices(colorKey){
            if (colorKey === 'B'){ return [{ kicker: currentLang==='ja'?'æ’å‡º':'Vent', title: currentLang==='ja'?'åœ§åŠ› -4':'Pressure -4', desc: currentLang==='ja'?'å®‰å…¨ã‚’ç¢ºä¿ã™ã‚‹':'Release built-up pressure.', apply(){ gameState.pressure = Math.max(0, gameState.pressure-4); } }, { kicker: currentLang==='ja'?'çŸ¥è­˜':'Insight', title: currentLang==='ja'?'ã‚¨ãƒƒã‚»ãƒ³ã‚¹ +4':'Essence +4', desc: currentLang==='ja'?'ãƒªã‚¹ã‚¯ã‚’å–ã£ã¦å¯Œã‚’å¾—ã‚‹':'Gain currency for the shop.', apply(){ gameState.essence += 4; } }]; }
            if (colorKey === 'R'){ return [{ kicker: currentLang==='ja'?'æ´»åŠ›':'Vitality', title: currentLang==='ja'?'HP +1 / åœ§åŠ› +3':'HP +1 / Pressure +3', desc: currentLang==='ja'?'å›å¾©ã™ã‚‹ãŒè² è·ãŒã‹ã‹ã‚‹':'Heal yourself, but strain the system.', apply(){ gameState.hp = Math.min(gameState.maxHp, gameState.hp + 1); gameState.pressure += 3; } }, { kicker: currentLang==='ja'?'å¹³é™':'Calm', title: currentLang==='ja'?'åœ§åŠ› -6':'Pressure -6', desc: currentLang==='ja'?'å¿ƒã‚’è½ã¡ç€ã‘ã‚‹':'Significantly reduce pressure.', apply(){ gameState.pressure = Math.max(0, gameState.pressure-6); } }]; }
            return [{ kicker: currentLang==='ja'?'æµ„åŒ–':'Purify', title: currentLang==='ja'?'åœ§åŠ› -2':'Pressure -2', desc: currentLang==='ja'?'å°‘ã—è½ã¡ç€ã':'Minor relief.', apply(){ gameState.pressure = Math.max(0, gameState.pressure-2); } }, { kicker: currentLang==='ja'?'è²ªæ¬²':'Greed', title: currentLang==='ja'?'ã‚¨ãƒƒã‚»ãƒ³ã‚¹ +3 / åœ§åŠ› +1':'Essence +3 / Pressure +1', desc: currentLang==='ja'?'å°ã•ãªä»£å„Ÿã§å¯Œã‚’':'Wealth at a cost.', apply(){ gameState.essence += 3; gameState.pressure += 1; } }];
        }
        // ------------------------------
        // Perk / Shop (missing functions)
        // ------------------------------
        function rarityWeight(r){
        if(r === 'epic') return 0.45;
        if(r === 'rare') return 0.80;
        return 1.00;
        }

        // buildPerkCard(perk) ãŒ perk.id ã‚’å‚ç…§ã™ã‚‹ã®ã§ PERKS[id] ã‚’è¿”ã™
        function rollPerkChoices(count=3){
        const ids = Object.keys(PERKS);
        const f = clamp((gameState.floor - 1) / 10, 0, 1);

        // é‡ã¿ï¼šå¾ŒåŠã»ã©rare/epicãŒå°‘ã—å‡ºã‚„ã™ã„ï¼ˆã‚„ã‚Šã™ããªã„ï¼‰
        const pool = ids.slice();
        const w = pool.map(id=>{
            const r = PERKS[id].rarity;
            let base = rarityWeight(r);
            if(r === 'rare') base += 0.15 * f;
            if(r === 'epic') base += 0.10 * f;

            // æœªå–å¾—ã‚’å°‘ã—å„ªé‡
            if(getPerkLevel(id) === 0) base *= 1.10;
            return base;
        });

        const chosen = [];
        while(chosen.length < Math.min(count, pool.length)){
            const total = w.reduce((a,b)=>a+b,0);
            let r = Math.random() * total;
            let idx = 0;
            while(idx < w.length && (r -= w[idx]) > 0) idx++;
            idx = Math.min(idx, w.length-1);

            const perkId = pool[idx];
            chosen.push(PERKS[perkId]); // â† ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¿”ã—

            pool.splice(idx,1);
            w.splice(idx,1);
        }
        return chosen;
        }

        // ã‚·ãƒ§ãƒƒãƒ—ã¯ â€œé–¢æ•°æŒã¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆâ€ ã‚’ state ã«ä¿æŒã™ã‚‹ã¨ save/load ã§å£Šã‚Œã‚„ã™ã„ã®ã§ã€
        // state ã«ã¯æœ€ä½é™ã® {kind,id,purchased} ã ã‘å…¥ã‚Œã‚‹ï¼ˆJSONå®‰å…¨ï¼‰
        function generateShopOffers(n=4){
        const entries = [];
        INSTANT_ITEMS.forEach(x => entries.push({kind:'instant', id:x.id}));
        Object.values(ITEMS).forEach(x => entries.push({kind:'item', id:x.id}));

        const pool = entries.slice();
        const picks = [];
        while(picks.length < Math.min(n, pool.length)){
            const p = pool.splice(randInt(pool.length),1)[0];
            picks.push({ ...p, purchased:false });
        }
        return picks;
        }

        function findInstant(id){
        return INSTANT_ITEMS.find(x => x.id === id) || null;
        }

        function refreshRerollUI(){
        if(!rerollBtn) return;
        const can = (gameState.rerollCoupons > 0) || (gameState.essence >= 5);
        rerollBtn.classList.toggle('hidden', !can);

        if(gameState.rerollCoupons > 0){
            rerollBtn.textContent = `Reroll (Coupon x${gameState.rerollCoupons})`;
        }else{
            rerollBtn.textContent = `Reroll (-5âœ¨)`;
        }

        const pe = ui('perk-essence');
        if(pe) pe.textContent = `Essence: ${gameState.essence} âœ¨`;
        }

        // ã‚ãªãŸã® updateShopButtons() ãŒ .shop-card / .shop-btn ã‚’æ¢ã™ã®ã§ã€ãã‚Œã«åˆã‚ã›ã‚‹
        function buildShopCard(offer){
        let name='', desc='', icon='â—ˆ', baseCost=0;

        if(offer.kind === 'instant'){
            const inst = findInstant(offer.id);
            if(!inst){
            // å£Šã‚ŒãŸofferï¼ˆãƒ­ãƒ¼ãƒ‰å¾Œãªã©ï¼‰
            const dummy = document.createElement('div');
            dummy.className = 'shop-card glass-panel perk-card p-3 opacity-40';
            dummy.innerHTML = `<div class="text-xs text-slate-400">Broken Offer</div>`;
            dummy.dataset.cost = "9999";
            return dummy;
            }
            name = currentLang==='ja' ? inst.name.ja : inst.name.en;
            desc = currentLang==='ja' ? inst.desc.ja : inst.desc.en;
            baseCost = inst.cost;
            icon = 'âœ¦';
        }else{
            const it = ITEMS[offer.id];
            if(!it){
            const dummy = document.createElement('div');
            dummy.className = 'shop-card glass-panel perk-card p-3 opacity-40';
            dummy.innerHTML = `<div class="text-xs text-slate-400">Broken Item</div>`;
            dummy.dataset.cost = "9999";
            return dummy;
            }
            name = currentLang==='ja' ? it.name.ja : it.name.en;
            desc = currentLang==='ja' ? it.desc.ja : it.desc.en;
            baseCost = it.cost;
            icon = it.icon;
        }

        const cost = getDiscountedCost(baseCost);
        const affordable = gameState.essence >= cost;

        // toolã¯1å›ã ã‘ã«ã—ãŸã„ï¼ˆå¤šé‡æ‰€æŒã‚’é˜²ãï¼‰
        const ownedTool = (offer.kind==='item' && ITEMS[offer.id]?.type==='tool' && (gameState.inventory[offer.id]||0) > 0);

        const disabled = !!offer.purchased || ownedTool || !affordable;

        const card = document.createElement('div');
        card.className = 'shop-card glass-panel perk-card p-3 flex flex-col gap-2';
        card.dataset.cost = String(cost);

        const discountLine = (hasPerk('bargain') && cost !== baseCost)
            ? `<div class="text-[10px] text-slate-500">Discount: ${baseCost} â†’ ${cost}</div>`
            : `<div class="text-[10px] text-slate-500">&nbsp;</div>`;

        const btnLabel = offer.purchased ? (currentLang==='ja'?'è³¼å…¥æ¸ˆ':'BOUGHT')
                        : ownedTool ? (currentLang==='ja'?'æ‰€æŒæ¸ˆ':'OWNED')
                        : (currentLang==='ja'?'è³¼å…¥':'BUY');

        card.innerHTML = `
            <div class="flex items-start justify-between gap-3">
            <div class="flex items-start gap-3 min-w-0">
                <div class="w-10 h-10 rounded-xl glass-panel flex items-center justify-center text-xl shrink-0 border border-white/10">${icon}</div>
                <div class="min-w-0">
                <div class="text-sm font-black text-white">${name}</div>
                <div class="text-slate-400 text-[10px] leading-relaxed mt-1">${desc}</div>
                </div>
            </div>
            <div class="text-right shrink-0">
                <div class="text-[10px] text-slate-500 uppercase tracking-widest">${currentLang==='ja'?'ã‚³ã‚¹ãƒˆ':'COST'}</div>
                <div class="text-lg font-black text-yellow-400">${cost}</div>
            </div>
            </div>
            ${discountLine}
            <button class="shop-btn py-2 rounded-xl font-black text-xs uppercase tracking-widest border border-white/10 ${disabled?'opacity-30 cursor-not-allowed':'hover:bg-white/5'}">
            ${btnLabel}
            </button>
        `;

        const btn = card.querySelector('.shop-btn');
        btn.disabled = disabled;

        btn.onclick = () => {
            if(btn.disabled) return;
            const finalCost = getDiscountedCost(baseCost);
            if(gameState.essence < finalCost) return;

            gameState.essence -= finalCost;

            if(offer.kind === 'instant'){
            const inst = findInstant(offer.id);
            if(inst && typeof inst.apply === 'function') inst.apply(gameState);
            else showToast("Broken instant item.", "red");
            }else{
            const it = ITEMS[offer.id];
            if(it.type === 'tool'){
                gameState.inventory[offer.id] = 1;
            }else{
                gameState.inventory[offer.id] = (gameState.inventory[offer.id]||0) + 1;
            }
            showToast(currentLang==='ja'?'è³¼å…¥ã—ã¾ã—ãŸ':'Purchased', 'yellow');
            }

            offer.purchased = true;
            saveGame();
            refreshRerollUI();
            renderHUD();
            updateShopButtons();
        };

        return card;
        }

        // death screen helpers
        function generateShareText(){
        const perkList = Object.entries(gameState.perks || {})
            .filter(([_,lv]) => (lv||0)>0)
            .map(([id,lv]) => `${(currentLang==='ja'?PERKS[id].name.ja:PERKS[id].name.en)} Lv.${lv}`)
            .join(', ');
        return `Abyss Alchemy | FLOOR ${gameState.floor} | ESSENCE ${gameState.essence} | ${perkList || 'No Mutations'}`;
        }

        function copyResult(){
        const ta = ui('share-text-area');
        if(!ta) return;
        const txt = ta.value;
        if(navigator.clipboard?.writeText){
            navigator.clipboard.writeText(txt).then(
            ()=>showToast(currentLang==='ja'?'ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ':'Copied', 'emerald'),
            ()=>{ document.execCommand('copy'); showToast(currentLang==='ja'?'ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ':'Copied', 'emerald'); }
            );
        }else{
            ta.select();
            document.execCommand('copy');
            showToast(currentLang==='ja'?'ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ':'Copied', 'emerald');
        }
        }

        // Status screen (btn-mutations)
        function openMutationsScreen(){
        const sum = ui('mutations-stats-summary');
        const list = ui('mutations-list-container');
        if(!sum || !list) return;

        const totalLevels = Object.values(gameState.perks).reduce((a,b)=>a+(b||0), 0);
        const discount = hasPerk('bargain') ? (15 + getPerkLevel('bargain')*5) : 0;

        sum.innerHTML = '';
        const stats = [
            {k:'FLOOR', v:String(gameState.floor)},
            {k:'HP', v:`${gameState.hp} / ${gameState.maxHp}`},
            {k:'CAPACITY', v:String(gameState.capacity)},
            {k:'TUBES', v:String(gameState.tubeCount)},
            {k:'PRESSURE MAX', v:String(gameState.pressureMax)},
            {k:'ESSENCE', v:`${gameState.essence} âœ¨`},
            {k:'MUTATIONS', v:String(totalLevels)},
            {k:'SHOP DISCOUNT', v:`${discount}%`},
            {k:'REROLL COUPON', v:String(gameState.rerollCoupons||0)},
        ];
        stats.forEach(s=>{
            const d = document.createElement('div');
            d.className = 'stat-item';
            d.innerHTML = `<div class="text-[10px] text-slate-500 uppercase tracking-widest">${s.k}</div><div class="text-lg font-black text-white">${s.v}</div>`;
            sum.appendChild(d);
        });

        list.innerHTML = '';
        const entries = Object.entries(gameState.perks||{}).filter(([_,lv]) => (lv||0)>0);
        if(entries.length === 0){
            list.innerHTML = `<div class="text-slate-500 text-xs italic py-3">${currentLang==='ja'?'å¤‰ç•°ãªã—':'No mutations'}</div>`;
        }else{
            entries
            .sort((a,b)=>b[1]-a[1])
            .forEach(([id,lv])=>{
                const row = document.createElement('div');
                row.className = 'glass-panel p-3 border border-white/10';
                row.innerHTML = `
                <div class="flex items-center justify-between">
                    <div class="text-sm font-black text-white">${currentLang==='ja'?PERKS[id].name.ja:PERKS[id].name.en}</div>
                    <div class="text-xs font-black text-sky-300">Lv.${lv}</div>
                </div>
                <div class="text-[10px] text-slate-400 mt-1 leading-relaxed">${getPerkDesc(id, lv)}</div>
                `;
                list.appendChild(row);
            });
        }

        mutationsScreen.classList.replace('hidden','flex');
        }

        function openPerkScreen(isDeath){
            perkScreen.classList.remove('hidden');
            ui('perk-title').textContent = isDeath ? t('gameOver') : t('victory');
            ui('perk-subtitle').textContent = isDeath ? t('gameOverSub') : t('victorySub');
            ui('perk-essence').textContent = `Essence: ${gameState.essence} âœ¨`;
            
            // Reset pending selection
            gameState.pendingPerkId = null;

            perkCards.innerHTML = ''; 
            shopCards.innerHTML = '';
            
            if(isDeath){
                perkCards.innerHTML = `<div class="flex flex-col gap-4 h-full"><div class="text-sm font-bold text-rose-400 uppercase tracking-widest border-b border-white/10 pb-2">${currentLang==='ja'?'æ¢ç´¢è¨˜éŒ²':'Exploration Log'}</div><div class="grid grid-cols-2 gap-4"><div class="glass-panel p-4 flex flex-col items-center justify-center bg-white/5"><div class="text-[10px] text-slate-400 uppercase tracking-widest">FLOOR</div><div class="text-4xl font-black text-white">${gameState.floor}</div></div><div class="glass-panel p-4 flex flex-col items-center justify-center bg-white/5"><div class="text-[10px] text-slate-400 uppercase tracking-widest">ESSENCE</div><div class="text-4xl font-black text-sky-300">${gameState.essence}</div></div></div><div class="mt-auto"><div class="text-[10px] text-slate-500 mb-2 uppercase tracking-widest">Result String</div><textarea id="share-text-area" class="w-full h-24 bg-black/50 border border-white/10 rounded p-2 text-[10px] text-slate-400 font-mono resize-none" readonly>${generateShareText()}</textarea></div></div>`;
                const perkList = Object.entries(gameState.perks).map(([id, lv]) => `<div class="flex justify-between items-center py-2 border-b border-white/5"><span class="text-sm font-bold text-slate-200">${currentLang==='ja'?PERKS[id].name.ja:PERKS[id].name.en}</span><span class="text-xs font-bold text-sky-400">Lv.${lv}</span></div>`).join('');
                shopCards.parentElement.className = "flex-1 flex flex-col p-4 md:p-6 overflow-y-auto"; shopCards.className = "flex flex-col gap-4 h-full";
                shopCards.innerHTML = `<div class="flex-1 overflow-y-auto min-h-[120px]"><div class="text-sm font-bold text-sky-400 uppercase tracking-widest border-b border-white/10 pb-2 mb-2">${currentLang==='ja'?'ç²å¾—ã—ãŸå¤‰ç•°':'Acquired Mutations'}</div>${perkList || `<div class="text-slate-500 text-xs italic py-4">${currentLang==='ja'?'å¤‰ç•°ãªã—':'No mutations'}</div>`}</div><div class="grid grid-cols-2 gap-3 mt-4 shrink-0"><button onclick="copyResult()" class="py-4 bg-indigo-600 rounded-xl font-black text-white uppercase tracking-widest hover:bg-indigo-500 shadow-lg shadow-indigo-900/40 transform transition hover:-translate-y-1">${currentLang==='ja'?'çµæœã‚’ã‚³ãƒ”ãƒ¼':'Copy Result'}</button><button onclick="startNewRun()" class="py-4 bg-rose-600 rounded-xl font-black text-white uppercase tracking-widest hover:bg-rose-500 shadow-lg shadow-rose-900/40 transform transition hover:-translate-y-1">${currentLang==='ja'?'ãƒªãƒˆãƒ©ã‚¤':'Try Again'}</button></div>`;
                continueBtn.style.display = 'none'; return;
            }
            
            continueBtn.style.display = 'block'; 
            continueBtn.textContent = t('continue');
            // Disable button initially
            continueBtn.classList.add('opacity-50', 'cursor-not-allowed');

            continueBtn.onclick = () => { 
                if(!gameState.pendingPerkId) {
                    showToast(currentLang==='ja'?'å¤‰ç•°ã‚’é¸æŠã—ã¦ãã ã•ã„':'Select a Mutation!', 'rose');
                    return;
                }
                acquirePerk(gameState.pendingPerkId);
                perkScreen.classList.add('hidden'); 
                nextFloor(); 
            };
            
            shopCards.parentElement.className = "flex-1 flex flex-col p-4 md:p-6 overflow-y-auto"; shopCards.className = "grid grid-cols-2 md:grid-cols-2 lg:grid-cols-2 gap-3";
            if (!gameState.currentPerkChoices) gameState.currentPerkChoices = rollPerkChoices();
            if (!gameState.currentShopOffers) gameState.currentShopOffers = generateShopOffers();
            gameState.currentPerkChoices.forEach(p => perkCards.appendChild(buildPerkCard(p))); refreshRerollUI();
            gameState.currentShopOffers.forEach(item => shopCards.appendChild(buildShopCard(item))); updateShopButtons();
            saveGame();
        }

        function buildPerkCard(perk){
            const card = document.createElement('div'), owned = getPerkLevel(perk.id), next = owned + 1;
            card.className = `perk-card glass-panel p-3 cursor-pointer rarity-${perk.rarity} relative hover:bg-white/5 transition-all`;
            card.innerHTML = `<div class="flex justify-between items-start mb-1"><span class="text-[9px] text-slate-400 uppercase tracking-widest">${perk.rarity}</span><span class="text-[9px] ${owned>0?'text-emerald-400':'text-sky-400'} font-bold uppercase">${owned>0?'UPGRADE':'NEW'}</span></div><div class="text-sm font-black text-white leading-tight mb-1">${currentLang==='ja'?perk.name.ja:perk.name.en} <span class="text-[10px] text-slate-500">Lv.${owned}â†’${next}</span></div><div class="text-slate-400 text-[10px] leading-relaxed">${getPerkDesc(perk.id, next)}</div>`;
            
            card.onclick = () => { 
                // Set pending selection
                gameState.pendingPerkId = perk.id;
                
                // Clear other selections
                Array.from(perkCards.children).forEach(c => { 
                    c.classList.remove('border-sky-500', 'bg-sky-500/20', 'ring-2', 'ring-sky-500');
                    c.classList.add('border-white/10');
                    c.style.opacity = '0.6';
                }); 
                
                // Highlight this one
                card.style.opacity = '1'; 
                card.classList.remove('border-white/10');
                card.classList.add('border-sky-500', 'bg-sky-500/20', 'ring-2', 'ring-sky-500');
                
                // Enable continue button
                continueBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            };
            return card;
        }
        
        // ä¿®æ­£ç®‡æ‰€: lv() -> getPerkLevel()
        function getDiscountedCost(base) { 
            if(hasPerk('bargain')) return Math.floor(base * (1 - (15+getPerkLevel('bargain')*5)/100)); 
            return base; 
        }
        
        function updateShopButtons() {
            document.querySelectorAll('.shop-card').forEach(card => {
                const btn = card.querySelector('.shop-btn'); if(btn.disabled && btn.textContent.includes('BOUGHT')) return;
                if(gameState.essence >= parseInt(card.dataset.cost)) { btn.classList.remove('opacity-30', 'cursor-not-allowed'); btn.classList.add('hover:bg-sky-500'); btn.style.pointerEvents = 'auto'; }
                else { btn.classList.add('opacity-30', 'cursor-not-allowed'); btn.classList.remove('hover:bg-sky-500'); }
            });
        }
        function acquirePerk(id){ if(!gameState.perks[id]) gameState.perks[id] = 0; gameState.perks[id]++; if(id === 'overflow') gameState.pressureMax += 4; renderHUD(); saveGame(); }
        function startNewRun(){ 
            clearSave(); 
            startScreen.classList.add('hidden'); 
            Object.assign(gameState, { 
                floor:1, essence:0, hp:3, maxHp:3, capacity:4, 
                perks:{}, pressure:0, pressureMax:14, history:[], inventory:{}, 
                catalystAvailable:true, refluxUses:0, momentumTurns:0, rerollCoupons:0 
            }); 
            perkScreen.classList.add('hidden'); 
            nextFloor(true); 
        }
        function nextFloor(isFirst=false){
            if(!isFirst) {
                gameState.floor++; if (gameState.floor >= 8) gameState.capacity = 6; else if (gameState.floor >= 4) gameState.capacity = 5; else gameState.capacity = 4;
                if(hasPerk('scavenger') && Math.random() < (0.10 + getPerkLevel('scavenger')*0.05)) { const k = pick(Object.keys(ITEMS).filter(x=>ITEMS[x].type==='consumable')); gameState.inventory[k] = (gameState.inventory[k]||0)+1; showToast("Scavenged!", 'emerald'); }
                if(hasPerk('transmutation')) { for(let i=0; i<getPerkLevel('transmutation'); i++){ const k = pick(Object.keys(ITEMS).filter(x=>ITEMS[x].type==='consumable')); gameState.inventory[k] = (gameState.inventory[k]||0)+1; } }
                if(hasPerk('deep_adapt') && gameState.capacity > 4){ gameState.maxHp += getPerkLevel('deep_adapt'); gameState.hp += getPerkLevel('deep_adapt'); }
                if(hasPerk('coupon')) gameState.rerollCoupons += getPerkLevel('coupon');
            }
            Object.assign(gameState, { turnCount:0, pressure:0, catalystAvailable:true, momentumTurns:0, refluxUses:getPerkLevel('reflux'), currentPerkChoices:null, currentShopOffers:null, selectedIdx:null, busy:false, targetMode:null, pipetteMode:false, pendingSkill:null, extractorHeldColor:null,history: [] });
            generateBoard(); generateGoals(); renderHUD(); renderBoard(); saveGame();
        }
        function tryUndo(){
            if (!gameState.history.length) return;

            // ã€ä¿®æ­£1ã€‘æˆ»ã‚Šå…ˆï¼ˆ1æ‰‹å‰ï¼‰ã®çŠ¶æ…‹ã‚’å…ˆã«å‚ç…§ã™ã‚‹
            const prev = gameState.history[gameState.history.length - 1];
            
            // ã€ä¿®æ­£2ã€‘ã‚³ã‚¹ãƒˆåˆ¤å®šã¯ã€Œæˆ»ã£ãŸå¾Œã®è‡ªåˆ†ã€ãŒæ”¯æ‰•ãˆã‚‹ã‹ã§åˆ¤å®šã™ã‚‹
            // ç¾åœ¨ã® gameState.refluxUses ã‚„ essence ã‚’ä½¿ã†ã¨ã€
            // ã€Œãã®ã‚¿ãƒ¼ãƒ³ã§ç¨¼ã„ã åˆ†ã€ãŒå«ã¾ã‚Œã¦ã—ã¾ã„è¨ˆç®—ãŒåˆã‚ãªããªã‚‹
            let isFree = prev.refluxUses > 0;

            if(!isFree && prev.essence < 5) {
                // æˆ»ã£ãŸå…ˆã§æ”¯æ‰•ãˆãªã„å ´åˆã¯Undoä¸å¯ã¨ã™ã‚‹ï¼ˆãƒã‚¤ãƒŠã‚¹å›é¿ï¼‰
                showToast(currentLang==='ja'?'ã‚¨ãƒƒã‚»ãƒ³ã‚¹ä¸è¶³ã§æˆ»ã‚Œã¾ã›ã‚“':'Not enough Essence in past state', 'rose');
                return;
            }

            // å±¥æ­´ã‹ã‚‰å–ã‚Šå‡ºã™
            gameState.history.pop();

            // çŠ¶æ…‹ã®å¾©å…ƒ
            Object.assign(gameState, { 
                tubes:deepCopy(prev.tubes), 
                turnCount:prev.turnCount, 
                pressure:prev.pressure, 
                hp:prev.hp, 
                secondaryProgress:prev.secondaryProgress, 
                catalystAvailable:prev.catalystAvailable, 
                essence:prev.essence, 
                inventory:{...prev.inventory}, 
                tubeCount:prev.tubeCount, 
                capacity:prev.capacity||4, 
                momentumTurns:prev.momentumTurns, 
                refluxUses:prev.refluxUses, // ã“ã“ã§éå»ã®å€‹æ•°ã«æˆ»ã‚‹
                targetMode:null, 
                pendingSkill:null, 
                extractorHeldColor:null, 
                selectedIdx:null 
            });

            // ã€ä¿®æ­£3ã€‘å¾©å…ƒã•ã‚ŒãŸçŠ¶æ…‹ã«å¯¾ã—ã¦ã‚³ã‚¹ãƒˆã‚’æ”¯æ‰•ã†
            if(isFree){ 
                gameState.pressure += 2; 
                gameState.refluxUses--; 
                showFloatText(0, "Reflux Used (+2 P)", "#a855f7"); 
            } else { 
                gameState.essence -= 5; 
            }

            updateTubeLayout(); 
            renderHUD(); 
            renderBoard(); 
            saveGame();
        }        

        function renderHUD(){
            // ãƒ†ã‚­ã‚¹ãƒˆæƒ…å ±ã®æ›´æ–°
            setText('ui-floor', `${t('floor')} ${gameState.floor}`); 
            setText('ui-essence', `${gameState.essence} âœ¨`); 
            setText('ui-hp', `HP ${gameState.hp}`); 
            setText('ui-floor-mobile', `${gameState.floor}F`); 
            setText('ui-essence-mobile', `${gameState.essence} âœ¨`); 
            setText('ui-hp-mobile', `HP ${gameState.hp}`);
            
            const totalLevels = Object.values(gameState.perks).reduce((a,b)=>a+b, 0); 
            setText('ui-perks-mobile', `ğŸ§¬ ${totalLevels}`); 
            setText('ui-turn', `${t('turn')} ${gameState.turnCount}`); 
            setText('ui-perks', `${t('perks')} ${totalLevels}`);
            
            // ç›®æ¨™è¨­å®š
            setText('ui-goal', gameState.primaryGoal?.text ?? 'â€”'); 
            setText('ui-goal-sub', gameState.secondaryGoal?.text ?? 'â€”'); 
            setText('ui-secondary', `${t('secondary')} ${secondarySucceeded()?'COMPLETE':'â€”'}`);
            
            // UIã‚¯ãƒ©ã‚¹åˆ¶å¾¡
            ui('ui-secondary').className = secondarySucceeded() 
                ? "px-4 py-2 rounded-xl glass-panel text-sm font-black tracking-tight uppercase bg-emerald-500/20 text-emerald-300 border border-emerald-500/50" 
                : "px-4 py-2 rounded-xl glass-panel text-sm font-black tracking-tight uppercase bg-black/20 text-white border border-white/5";
            
            // åœ§åŠ›ãƒãƒ¼
            setText('ui-pressure', String(gameState.pressure)); 
            const pct = Math.round((gameState.pressure/gameState.pressureMax)*100);
            const pBar = ui('ui-pressure-bar'); 
            if(pBar){ 
                pBar.style.width=`${clamp(pct,0,100)}%`; 
                if(gameState.pressure >= gameState.pressureMax-3){ 
                    pBar.classList.remove('from-sky-400'); 
                    pBar.classList.add('bg-rose-600'); 
                } else { 
                    pBar.classList.add('from-sky-400'); 
                    pBar.classList.remove('bg-rose-600'); 
                } 
            }
            setText('ui-pressure-sub', `${gameState.pressure} / ${gameState.pressureMax}`); 

            // --- UNDOãƒœã‚¿ãƒ³åˆ¶å¾¡ (ã“ã“ã‚’ä¿®æ­£ãƒ»çµ±åˆã—ã¾ã—ãŸ) ---
            const undoCost = gameState.refluxUses>0?'FREE':'5âœ¨'; 
            if(undoBtn){ 
                undoBtn.innerHTML=`<span>â†º</span> UNDO (${undoCost})`; 
                
                // å±¥æ­´ãŒã‚ã‚‹ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
                const canUndo = gameState.history.length > 0;

                // ãƒœã‚¿ãƒ³ã®æœ‰åŠ¹/ç„¡åŠ¹ã‚’åˆ‡ã‚Šæ›¿ãˆ
                undoBtn.disabled = !canUndo; 
                
                // è¦‹ãŸç›®ã®åˆ¶å¾¡
                undoBtn.style.opacity = canUndo ? '1' : '0.3';
                undoBtn.style.cursor = canUndo ? 'pointer' : 'not-allowed';
                undoBtn.style.pointerEvents = canUndo ? 'auto' : 'none';
            } 
            
            renderSkills();
        }

        function moveFocus(dx){ if(!gameState.tubes.length) return; gameState.focusIdx = gameState.focusIdx === null ? 0 : (gameState.focusIdx + dx + gameState.tubeCount) % gameState.tubeCount; renderBoard(); }
        function updateStartScreenButtons(){ continueRunBtn.classList.toggle('hidden', !hasSaveData()); }

        ui('btn-help').onclick = () => ui('help-screen').classList.replace('hidden', 'flex');
        ui('help-close').onclick = () => ui('help-screen').classList.replace('flex', 'hidden');
        ui('btn-mutations').onclick = openMutationsScreen;
        ui('mutations-close').onclick = () => mutationsScreen.classList.replace('flex', 'hidden');
        if(undoBtn) undoBtn.onclick = tryUndo;
        ui('reroll-btn').onclick = () => {
            if(gameState.rerollCoupons > 0) gameState.rerollCoupons--; else if(gameState.essence >= 5) gameState.essence -= 5; else return;
            gameState.currentPerkChoices = null; gameState.currentShopOffers = null; openPerkScreen(false); saveGame();
        };
        ui('start-run-btn').onclick = startNewRun;
        ui('continue-run-btn').onclick = () => { startScreen.classList.add('hidden'); loadGame(); };

        // --- ç„¡é™ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« & ãƒ‰ãƒ©ãƒƒã‚°åˆ¶å¾¡ ---
        let isDown = false;
        let startX;       // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«è¨ˆç®—ç”¨ï¼ˆå¸¸ã«æ›´æ–°ï¼‰
        let dragStartX;   // ãƒ‰ãƒ©ãƒƒã‚°åˆ¤å®šç”¨ï¼ˆã‚¯ãƒªãƒƒã‚¯æ™‚ã®ä½ç½®ã§å›ºå®šï¼‰
        let isDragging = false; 

        const slider = ui('board-scroll-area');

        slider.addEventListener('mousedown', (e) => {
            isDown = true;
            isDragging = false;
            slider.style.cursor = 'grabbing';
            startX = e.pageX - slider.offsetLeft;
            dragStartX = e.pageX; // â˜…ãƒ‰ãƒ©ãƒƒã‚°åˆ¤å®šã®åŸºæº–ç‚¹ã‚’ä¿å­˜
        });

        slider.addEventListener('mouseleave', () => {
            isDown = false;
            slider.style.cursor = 'grab';
        });

        slider.addEventListener('mouseup', () => {
            isDown = false;
            slider.style.cursor = 'grab';
        });

        slider.addEventListener('mousemove', (e) => {
            if (!isDown) return;
            e.preventDefault();
            const x = e.pageX - slider.offsetLeft;
            
            // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç§»å‹•é‡ï¼ˆå‰å›ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®å·®åˆ†ï¼‰
            const walk = (x - startX) * 1.5; 
            slider.scrollLeft -= walk; 
            startX = x; // æ¬¡ã®è¨ˆç®—ã®ãŸã‚ã«ç¾åœ¨ä½ç½®ã‚’æ›´æ–°
            
            // â˜…ã€ŒæŠ¼ã—å§‹ã‚ã®ä½ç½®(dragStartX)ã€ã‹ã‚‰ã€Œç¾åœ¨ä½ç½®(e.pageX)ã€ã¾ã§ã®è·é›¢ãŒ
            // 5pxã‚’è¶…ãˆãŸå ´åˆã®ã¿ã€ãƒ‰ãƒ©ãƒƒã‚°ï¼ˆã‚¯ãƒªãƒƒã‚¯ç„¡åŠ¹ï¼‰ã¨åˆ¤å®šã™ã‚‹
            if(Math.abs(e.pageX - dragStartX) > 5) {
                isDragging = true;
            }
        });

        // ç„¡é™ãƒ«ãƒ¼ãƒ—åˆ¤å®š
        slider.addEventListener('scroll', () => {
            checkInfiniteScrollLoop();
        });

        // --- ç„¡é™ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åˆæœŸåŒ– ---
        function initInfiniteScroll() {
            const tubeEl = tubesContainer.querySelector('.tube');
            if(!tubeEl) return;
            
            const style = window.getComputedStyle(tubesContainer);
            const gap = parseFloat(style.gap) || 0; 
            const itemWidth = tubeEl.offsetWidth + gap;
            
            const cloneWidth = itemWidth * CLONE_PADDING;
            const realWidth = itemWidth * gameState.tubes.length;
            const containerWidth = slider.clientWidth;
            
            let targetScroll = cloneWidth;

            // æœ¬ä½“å¹…ãŒç”»é¢ã‚ˆã‚Šå°ã•ã„å ´åˆã€ä¸­å¤®ã«æ¥ã‚‹ã‚ˆã†ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—
            if (realWidth < containerWidth) {
                const offset = (containerWidth - realWidth) / 2;
                targetScroll -= offset;
            }

            // åˆå›ä½ç½®åˆã‚ã›
            if(slider.scrollLeft < 5) {
                slider.scrollLeft = targetScroll;
            }
        }

        // --- ç„¡é™ãƒ«ãƒ¼ãƒ—ç›£è¦– ---
        function checkInfiniteScrollLoop() {
            if(!gameState.tubes.length) return;
            const tubeEl = tubesContainer.querySelector('.tube');
            if(!tubeEl) return;
            
            const style = window.getComputedStyle(tubesContainer);
            const gap = parseFloat(style.gap) || 0;
            const itemWidth = tubeEl.offsetWidth + gap;
            const realWidth = itemWidth * gameState.tubes.length;
            
            const buffer = 10; 

            if (slider.scrollLeft < buffer) {
                // å·¦ç«¯ã«è¡ŒãéããŸã‚‰å³ã¸ãƒ¯ãƒ¼ãƒ—
                slider.scrollLeft += realWidth;
            }
            else if (slider.scrollLeft > slider.scrollWidth - slider.clientWidth - buffer) {
                // å³ç«¯ã«è¡ŒãéããŸã‚‰å·¦ã¸ãƒ¯ãƒ¼ãƒ—
                slider.scrollLeft -= realWidth;
            }
        }

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ
        window.onkeydown = (e) => {
            if(!perkScreen.classList.contains('hidden') || !eventScreen.classList.contains('hidden') || !helpScreen.classList.contains('hidden') || !mutationsScreen.classList.contains('hidden')) return;
            if (e.key === 'ArrowLeft') moveFocus(-1); if (e.key === 'ArrowRight') moveFocus(1);
            if ((e.key === 'Enter' || e.key === ' ') && gameState.focusIdx !== null) handleTubeClick(gameState.focusIdx);
            if (e.key === 'Backspace' || e.key === 'z') tryUndo();
        };

        // åˆæœŸåŒ–å®Ÿè¡Œ
        applyLang(); updateStartScreenButtons();

        window.onkeydown = (e) => {
            if(!perkScreen.classList.contains('hidden') || !eventScreen.classList.contains('hidden') || !helpScreen.classList.contains('hidden') || !mutationsScreen.classList.contains('hidden')) return;
            if (e.key === 'ArrowLeft') moveFocus(-1); if (e.key === 'ArrowRight') moveFocus(1);
            if ((e.key === 'Enter' || e.key === ' ') && gameState.focusIdx !== null) handleTubeClick(gameState.focusIdx);
            if (e.key === 'Backspace' || e.key === 'z') tryUndo();
        };
        applyLang(); updateStartScreenButtons();
    </script>
</body>
</html>