<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Abyssal Alchemy - Water Sort Rogue</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg-color: #020617;
            --tube-border: #334155;
            --tube-bg: rgba(15, 23, 42, 0.4);
            --pour-speed: 0.3s;
            --segment-height: 40px;
            --tube-height: 220px;
            --primary-glow: #38bdf8;
            --rarity-common: #94a3b8;
            --rarity-rare: #3b82f6;
            --rarity-epic: #a855f7;
        }

        body {
            background: radial-gradient(circle at 50% 0%, #0f172a 0%, #020617 100%);
            color: white;
            font-family: 'Inter', system-ui, sans-serif;
            touch-action: manipulation;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            margin: 0;
            user-select: none;
            -webkit-user-select: none;
        }

        .glass-panel {
            background: rgba(15, 23, 42, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(12px);
            border-radius: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        /* „ÉÅ„É•„Éº„Éñ„ÅÆ„Çπ„Çø„Ç§„É´ */
        .tube {
            width: clamp(40px, 10vw, 56px);
            height: var(--tube-height);
            border: 3px solid var(--tube-border);
            border-top: 2px solid rgba(255,255,255,0.15);
            border-bottom-left-radius: 28px;
            border-bottom-right-radius: 28px;
            position: relative;
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1), box-shadow 0.3s ease, border-color 0.3s ease;
            background: var(--tube-bg);
            margin: 6px;
            z-index: 10;
            cursor: pointer;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            box-shadow: inset 2px 0 4px rgba(255,255,255,0.05), inset -2px 0 4px rgba(0,0,0,0.2);
            flex-shrink: 0;
        }

        .tube.selected {
            transform: translateY(-15px) scale(1.05);
            border-color: var(--primary-glow);
            box-shadow: 0 0 25px rgba(56, 189, 248, 0.25);
            z-index: 20;
        }
        
        .tube.target-mode {
            border-color: #a855f7;
            box-shadow: 0 0 20px rgba(168, 85, 247, 0.4);
            animation: pulse-purple 1.5s infinite;
        }
        
        .tube.source-mode {
            border-color: #fbbf24;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.4);
            animation: pulse-yellow 1.5s infinite;
        }

        @keyframes pulse-purple {
            0%, 100% { box-shadow: 0 0 20px rgba(168, 85, 247, 0.4); }
            50% { box-shadow: 0 0 30px rgba(168, 85, 247, 0.7); }
        }
        @keyframes pulse-yellow {
            0%, 100% { box-shadow: 0 0 20px rgba(251, 191, 36, 0.4); }
            50% { box-shadow: 0 0 30px rgba(251, 191, 36, 0.7); }
        }

        .tube-focused {
            border-color: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 0 4px rgba(255,255,255,0.3);
        }

        /* Ë©∞„ÅøË≠¶Âëä */
        .deadlock-glow {
            box-shadow: 0 0 0 4px rgba(244, 63, 94, 0.5) !important;
            border-color: rgba(244, 63, 94, 0.8) !important;
        }

        .water-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            flex-direction: column-reverse;
            padding: 0;
            gap: 0;
            pointer-events: none;
            width: 100%;
        }

        .water-segment {
            width: 100%;
            height: var(--segment-height);
            position: relative;
            transition: height 0.3s ease, opacity 0.3s ease;
        }

        .water-segment::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, 
                rgba(255,255,255,0.1) 0%, 
                rgba(255,255,255,0) 20%, 
                rgba(0,0,0,0.1) 50%, 
                rgba(255,255,255,0) 80%, 
                rgba(255,255,255,0.15) 100%);
            opacity: 0.6;
        }

        .water-segment:last-child {
            border-top: 1px solid rgba(255,255,255,0.3);
        }
        .water-segment:last-child::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(255,255,255,0.4);
            filter: blur(2px);
            border-radius: 50%;
            transform: scaleX(0.9);
        }
        
        @keyframes evaporate {
            0% { transform: scale(1); opacity: 1; filter: brightness(1); }
            50% { filter: brightness(2); background-color: white; }
            100% { transform: scale(1.2); opacity: 0; }
        }
        .evaporating .water-segment {
            animation: evaporate 0.6s forwards;
        }

        .lang-btn{
            padding: 6px 10px;
            font-weight: 800;
            font-size: 12px;
            border-radius: 12px;
            opacity: 0.55;
            transition: all .2s;
        }
        .lang-btn.active{ opacity: 1; background: rgba(56,189,248,0.15); border: 1px solid rgba(56,189,248,0.35); }

        .perk-card {
            transition: all 0.25s ease;
            border: 1px solid rgba(255,255,255,0.06);
            position: relative;
            overflow: hidden;
        }
        .perk-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            border-color: rgba(56,189,248,0.35);
        }

        .rarity-common{ border-left: 3px solid var(--rarity-common); }
        .rarity-rare{ border-left: 3px solid var(--rarity-rare); }
        .rarity-epic{ border-left: 3px solid var(--rarity-epic); }
        
        .skill-btn {
            position: relative;
            transition: all 0.2s;
            filter: grayscale(0.8);
            opacity: 0.7;
        }
        .skill-btn:not(:disabled):hover {
            filter: grayscale(0);
            opacity: 1;
            transform: translateY(-2px);
            z-index: 50;
        }
        /* ÈÅ∏Êäû‰∏≠ÔºàÁ¢∫Ë™çÂæÖ„Å°Ôºâ */
        .skill-btn.pending {
            filter: grayscale(0);
            opacity: 1;
            border-color: #fbbf24;
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.4);
            background: rgba(251, 191, 36, 0.1);
            animation: pulse-btn 1s infinite;
        }
        /* Áô∫Âãï„É¢„Éº„Éâ‰∏≠ */
        .skill-btn.active-mode {
            filter: grayscale(0);
            opacity: 1;
            border-color: #a855f7;
            box-shadow: 0 0 15px rgba(168, 85, 247, 0.4);
            background: rgba(168, 85, 247, 0.2);
        }
        /* ÊäΩÂá∫‰∏≠ */
        .skill-btn.extracting {
            border-color: #22c55e;
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.4);
            background: rgba(34, 197, 94, 0.2);
            animation: pulse-btn 1.5s infinite;
        }
        .skill-btn.active {
            filter: grayscale(0);
            opacity: 1;
            border-color: var(--primary-glow);
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.4);
            background: rgba(56, 189, 248, 0.2);
        }
        
        @keyframes pulse-btn {
            0% { box-shadow: 0 0 5px currentColor; }
            50% { box-shadow: 0 0 15px currentColor; }
            100% { box-shadow: 0 0 5px currentColor; }
        }

        .skill-tooltip {
            position: absolute;
            bottom: 115%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(2, 6, 23, 0.95);
            border: 1px solid rgba(56, 189, 248, 0.3);
            padding: 8px 12px;
            border-radius: 8px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            pointer-events: none;
            width: max-content;
            max-width: 220px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            z-index: 100;
        }
        .skill-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -6px;
            border-width: 6px;
            border-style: solid;
            border-color: rgba(56, 189, 248, 0.3) transparent transparent transparent;
        }
        .skill-btn:hover .skill-tooltip {
            opacity: 1;
            visibility: visible;
            bottom: 125%;
        }

        #btn-undo {
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
            transition: all 0.2s;
        }
        #btn-undo:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.3);
        }
        #btn-undo:active {
            transform: scale(0.95);
        }

        #alert-banner {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(244, 63, 94, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 14px;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        #toast-container {
            pointer-events: none;
        }
        .toast-msg {
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(56, 189, 248, 0.3);
            color: white;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            animation: toast-in 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(4px);
        }
        .toast-msg.fade-out {
            animation: toast-out 0.3s forwards;
        }
        @keyframes toast-in {
            from { opacity: 0; transform: translateY(-20px) scale(0.9); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        @keyframes toast-out {
            to { opacity: 0; transform: translateY(-10px); }
        }

        .floating{
            animation: floaty 3.2s ease-in-out infinite;
        }
        @keyframes floaty{
            0%,100%{ transform: translateY(0); }
            50%{ transform: translateY(-10px); }
        }

        /* Ê®™„Çπ„ÇØ„É≠„Éº„É´ÂØæÂøú„ÅÆ„Éú„Éº„Éâ„Ç®„É™„Ç¢ */
        #board-scroll-area {
            width: 100%;
            height: 100%;
            overflow-x: auto;
            overflow-y: hidden;
            display: flex;
            align-items: center; /* Á∏¶ÊñπÂêë‰∏≠Â§Æ */
            /* „Çπ„ÇØ„É≠„Éº„É´„Éê„ÉºË£ÖÈ£æ */
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.1) transparent;
        }
        #board-scroll-area::-webkit-scrollbar {
            height: 6px;
        }
        #board-scroll-area::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }

        /* ‰øÆÊ≠£ÁÆáÊâÄÔºö„Çπ„ÇØ„É≠„Éº„É´ÊôÇ„Å´Â∑¶Á´Ø„ÅåË¶ãÂàá„Çå„Å™„ÅÑ„Çà„ÅÜ„Å´ÊúÄÈÅ©Âåñ */
        #tubes-container {
            display: flex;
            flex-wrap: nowrap; /* Êäò„ÇäËøî„Åó„Å™„Åó */
            gap: 12px;
            padding: 0 24px; /* Á´Ø„ÅÆ‰ΩôÁôΩ */
            
            /* ÈáçË¶Å: justify-content: center „ÇíÂâäÈô§ */
            
            /* „Ç≥„É≥„ÉÜ„É≥„ÉÑÂπÖ„Å´Âêà„Çè„Åõ„Çã */
            width: max-content; 
            
            /* Ë¶™„Çà„ÇäÂ∞è„Åï„ÅÑ„Å®„Åç„ÅØ‰∏≠Â§Æ„ÄÅÂ§ß„Åç„ÅÑ„Å®„Åç„ÅØÂ∑¶Ë©∞„ÇÅÔºà„Çπ„ÇØ„É≠„Éº„É´ÂèØËÉΩÔºâ„Å´„Åô„ÇãÈ≠îÊ≥ï */
            margin: auto; 
            
            transition: transform 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            transform-origin: center center;
        }
        
        /* „Çπ„Ç≠„É´„Ç≥„É≥„ÉÜ„Éä„ÅÆ„É¨„Çπ„Éù„É≥„Ç∑„ÉñÂØæÂøú */
        #skills-container {
            display: flex;
            align-items: center;
            justify-content: flex-start; /* Â∑¶ÂØÑ„Åõ„Å´„Åó„Å¶„Çπ„ÇØ„É≠„Éº„É´„Åï„Åõ„Çã */
            gap: 0.75rem;
            overflow-x: auto; /* Ê®™„Çπ„ÇØ„É≠„Éº„É´ÊúâÂäπ */
            padding-left: 1rem;
            padding-right: 1rem;
            padding-bottom: 0.5rem; /* „Çπ„ÇØ„É≠„Éº„É´„Éê„Éº‰ΩôÁôΩ */
            
            /* Â∑¶Âè≥„ÅÆÁ´Ø„Çí„Éï„Çß„Éº„Éâ„Ç¢„Ç¶„Éà */
            mask-image: linear-gradient(to right, transparent 0%, black 5%, black 95%, transparent 100%);
            -webkit-mask-image: linear-gradient(to right, transparent 0%, black 5%, black 95%, transparent 100%);
            
            /* „Çπ„ÇØ„É≠„Éº„É´„Éê„Éº„ÇíÈö†„Åô */
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        #skills-container::-webkit-scrollbar {
            display: none;
        }

        #dev-tests {
            display: none;
        }
    </style>
</head>
<body>
    
    <div id="toast-container" class="fixed top-20 left-1/2 -translate-x-1/2 z-[200] flex flex-col gap-2 w-full max-w-sm px-4"></div>

    <div id="game-container" class="flex flex-col items-center justify-between h-screen w-screen p-2 md:p-4 overflow-hidden relative">
        <div id="alert-banner">NO MOVES LEFT</div>

        <!-- „Éà„ÉÉ„ÉóHUD -->
        <div id="top-hud" class="w-full max-w-5xl glass-panel p-3 md:p-4 flex items-center justify-between z-20 shrink-0 mb-2">
            <div class="flex items-center gap-4">
                <div>
                    <div class="text-[10px] text-slate-400 uppercase tracking-[0.35em]" id="ui-subtitle">Èå¨ÈáëË°ì„ÅÆÊ∑±Ê∑µ</div>
                    <div class="text-xl md:text-2xl font-black tracking-tight leading-none bg-gradient-to-br from-white to-slate-400 bg-clip-text text-transparent" id="ui-title">Abyssal Alchemy</div>
                </div>
                <div class="hidden md:flex items-center gap-3 ml-4">
                    <span class="px-4 py-2 rounded-xl glass-panel text-xl font-bold border border-white/5" id="ui-floor">FLOOR 1</span>
                    <span class="px-4 py-2 rounded-xl glass-panel text-xl font-bold text-sky-300 border border-white/5" id="ui-essence">0 ‚ú®</span>
                    <span class="px-4 py-2 rounded-xl glass-panel text-xl font-bold text-rose-300 border border-white/5" id="ui-hp">HP 3</span>
                </div>
            </div>

            <div class="flex items-center gap-2">
                <button id="btn-help" class="w-10 h-10 md:w-auto md:h-auto md:px-4 md:py-2 flex items-center justify-center glass-panel font-bold text-xs uppercase tracking-widest hover:bg-white/5 active:scale-95 transition-all">
                    <span class="md:hidden">?</span><span class="hidden md:inline">Help</span>
                </button>
            </div>
        </div>

        <!-- ÁõÆÊ®ô/ÂúßÂäõ Ë°å -->
        <div id="status-bar" class="w-full max-w-5xl flex gap-2 shrink-0 z-20 mb-2">
            <div class="flex-1 glass-panel px-4 py-2 border-l-4 border-l-sky-500/50">
                <div class="text-[10px] text-slate-400 uppercase tracking-[0.35em]" id="ui-goal-title">GOAL</div>
                <div class="text-sm font-black tracking-tight text-white" id="ui-goal">‚Äî</div>
                <div class="text-[10px] text-slate-500 mt-1" id="ui-goal-sub">‚Äî</div>
            </div>
            <div class="w-[180px] md:w-[220px] glass-panel px-4 py-2 border-l-4 border-l-rose-500/50">
                <div class="text-[10px] text-slate-400 uppercase tracking-[0.35em]">PRESSURE</div>
                <div class="flex items-center gap-2 mt-1">
                    <div class="flex-1 h-2 rounded-full bg-slate-800/80 overflow-hidden relative border border-white/5">
                        <div id="ui-pressure-bar" class="h-full rounded-full bg-gradient-to-r from-sky-400 via-purple-400 to-rose-500 transition-all duration-300" style="width:0%"></div>
                    </div>
                    <div class="text-xs font-black w-5 text-right" id="ui-pressure">0</div>
                </div>
                <div class="text-[10px] text-slate-500 mt-1 text-right" id="ui-pressure-sub">‚Äî</div>
            </div>
        </div>

        <!-- Áõ§Èù¢„Ç®„É™„Ç¢ -->
        <div id="board-area" class="flex-1 w-full relative z-10 overflow-hidden my-2">
            <div id="board-scroll-area">
                <div id="tubes-container"></div>
            </div>
        </div>
        
        <!-- „Çπ„Ç≠„É´„Éê„Éº (Scrollable) -->
        <div id="skills-container" class="w-full max-w-2xl z-20 mb-2 min-h-[60px] shrink-0">
            <!-- JS„Åß„Éú„Çø„É≥ÁîüÊàê -->
        </div>

        <!-- ‰∏ãHUD (‰øÆÊ≠£: „Çπ„Çø„Ç§„É´Áµ±‰∏Ä) -->
        <div id="bottom-hud" class="w-full max-w-5xl glass-panel p-3 md:p-4 shrink-0 z-20 mb-safe">
            <div class="md:hidden flex items-center justify-between mb-3 px-1 gap-2 text-sm font-bold">
                 <span class="text-slate-300 bg-white/5 px-2 py-1 rounded border border-white/10" id="ui-floor-mobile">1F</span>
                 <div class="flex gap-3">
                     <span class="text-sky-300" id="ui-essence-mobile">0 ‚ú®</span>
                     <span class="text-purple-300" id="ui-perks-mobile">üß¨ 0</span>
                 </div>
                 <span class="text-rose-300" id="ui-hp-mobile">HP 3</span>
            </div>

            <div class="flex items-center justify-between gap-3 relative">
                <div class="flex items-center gap-2 md:gap-3 flex-wrap">
                    <!-- ‰øÆÊ≠£: ‰∏äÈÉ®„ÅÆGoal„Å®Âêå„Åò„Çπ„Çø„Ç§„É´Ôºàtext-sm font-black text-whiteÔºâ„Å´Â§âÊõ¥ -->
                    <span class="px-4 py-2 rounded-xl glass-panel text-sm font-black tracking-tight text-white border border-white/5" id="ui-turn">TURN 0</span>
                    <span class="px-4 py-2 rounded-xl glass-panel text-sm font-black tracking-tight text-white border border-white/5" id="ui-secondary">BONUS ‚Äî</span>
                    <span class="px-4 py-2 rounded-xl glass-panel text-sm font-black tracking-tight text-sky-300 border border-white/5 hidden sm:block" id="ui-perks">PERKS 0</span>
                </div>
                
                <button id="btn-undo" class="px-4 py-2 rounded-xl font-bold text-xs uppercase tracking-widest text-slate-300 flex items-center gap-2">
                    <span>‚Ü∫</span> UNDO (5‚ú®)
                </button>
            </div>
        </div>
    </div>

    <!-- ÁîªÈù¢Ôºö„Ç§„Éô„É≥„Éà -->
    <div id="event-screen" class="fixed inset-0 z-[140] bg-slate-950/85 backdrop-blur-sm hidden items-center justify-center p-6 transition-opacity">
        <div class="glass-panel w-full max-w-2xl p-6 border border-sky-500/20 shadow-2xl shadow-sky-900/20">
            <div class="flex items-end justify-between gap-4">
                <div>
                    <div class="text-[10px] text-sky-400 uppercase tracking-[0.35em] font-bold" id="event-kicker">EVENT</div>
                    <div class="text-3xl font-black tracking-tight text-white mt-1" id="event-title">‚Äî</div>
                    <div class="text-slate-300 text-sm mt-3 whitespace-pre-line leading-relaxed" id="event-desc">‚Äî</div>
                </div>
                <div class="text-right shrink-0">
                    <div class="px-3 py-1 bg-rose-500/10 border border-rose-500/30 rounded text-[10px] text-rose-300 uppercase tracking-[0.2em]">Unavoidable</div>
                </div>
            </div>
            <div class="grid md:grid-cols-2 gap-4 mt-8" id="event-choices"></div>
        </div>
    </div>

    <!-- „Çπ„Çø„Éº„ÉàÁîªÈù¢ -->
    <div id="start-screen" class="fixed inset-0 z-[100] flex flex-col items-center justify-center bg-slate-950 p-8">
        <div class="absolute top-8 right-8 flex gap-2 glass-panel p-1 z-50">
            <button onclick="setLang('en')" id="lang-en" class="lang-btn">EN</button>
            <button onclick="setLang('ja')" id="lang-ja" class="lang-btn active">JP</button>
        </div>

        <div class="text-center mb-16 floating relative">
            <div class="absolute inset-0 bg-sky-500/20 blur-[100px] rounded-full"></div>
            <h1 class="relative text-5xl md:text-7xl font-black tracking-tighter text-transparent bg-clip-text bg-gradient-to-b from-sky-300 via-sky-500 to-indigo-600 drop-shadow-2xl leading-tight">ABYSSAL<br>ALCHEMY</h1>
            <p id="start-subtitle" class="relative text-sky-200/60 font-medium tracking-[0.5em] uppercase text-xs mt-4">Èå¨ÈáëË°ì„ÅÆÊ∑±Ê∑µ</p>
        </div>
        
        <div class="flex flex-col gap-3 w-full max-w-xs">
            <button id="continue-run-btn" class="hidden w-full py-4 bg-emerald-600 rounded-2xl font-black text-white uppercase tracking-widest shadow-2xl shadow-emerald-500/20 hover:bg-emerald-500 hover:shadow-emerald-500/40 hover:-translate-y-1 transition-all active:scale-95 active:translate-y-0 flex items-center justify-center gap-2">
                <span>‚ñ∂</span> <span id="continue-btn-text">„Å§„Å•„Åç„Åã„Çâ</span>
            </button>
            <button id="start-run-btn" class="w-full py-4 bg-sky-600 rounded-2xl font-black text-white uppercase tracking-widest shadow-2xl shadow-sky-500/20 hover:bg-sky-500 hover:shadow-sky-500/40 hover:-translate-y-1 transition-all active:scale-95 active:translate-y-0">
                Êé¢Á¥¢„ÇíÈñãÂßã
            </button>
        </div>

        <p class="text-slate-600 text-[10px] mt-8 tracking-widest uppercase">Ver 2.6.0 Fix Scroll & Fonts</p>
    </div>

    <!-- Â§âÁï∞ÈÅ∏Êäû & „Ç∑„Éß„ÉÉ„ÉóÁîªÈù¢ -->
    <div id="perk-screen" class="fixed inset-0 z-[150] bg-slate-950 flex flex-col items-center justify-center p-4 md:p-8 hidden">
        <div class="w-full max-w-6xl h-full max-h-full flex flex-col glass-panel p-0 overflow-hidden relative border border-white/10 shadow-2xl shadow-black/80">
            
            <!-- Header -->
            <div class="flex justify-between items-center p-4 md:p-6 border-b border-white/5 shrink-0 bg-slate-900/40">
                <div>
                    <h2 id="perk-title" class="text-xl md:text-3xl font-black text-white italic uppercase leading-none">Â§âÁï∞„ÅÆÂÖÜ„Åó</h2>
                    <p id="perk-subtitle" class="text-slate-400 text-[10px] md:text-xs mt-1 uppercase tracking-widest">ÁÑ°Êñô„ÅÆÂº∑Âåñ„Çí1„Å§ÈÅ∏Êäû</p>
                </div>
                <div class="text-right flex flex-col items-end gap-2">
                    <button id="reroll-btn" class="px-3 py-1 glass-panel border border-white/5 text-[10px] font-black uppercase tracking-widest hover:bg-white/5 active:scale-95 transition-all hidden">Reroll (-5‚ú®)</button>
                </div>
            </div>

            <!-- Main Content (Scrollable) -->
            <div class="flex-1 flex flex-col md:flex-row min-h-0 overflow-hidden">
                
                <!-- Left: Perks -->
                <div class="flex-1 flex flex-col p-4 md:p-6 overflow-y-auto border-b md:border-b-0 md:border-r border-white/5 bg-slate-900/20">
                    <div class="text-sm font-bold mb-3 text-sky-300 uppercase tracking-widest flex items-center gap-2">
                        <span>üß¨ Mutations</span>
                        <span class="text-[10px] text-slate-500 font-normal normal-case">Pick One (Updates every level)</span>
                    </div>
                    <div class="grid gap-3" id="perk-cards">
                        <!-- Perks injected here -->
                    </div>
                </div>

                <!-- Right: Shop -->
                <div class="flex-1 flex flex-col p-4 md:p-6 overflow-y-auto">
                    <div class="flex justify-between items-center mb-3">
                        <div class="text-sm font-bold text-yellow-500 uppercase tracking-widest flex items-center gap-2">
                            <span>‚óà Shop</span>
                            <span class="text-[10px] text-slate-500 font-normal normal-case">4 Random Items</span>
                        </div>
                        <div class="text-[10px] font-bold text-sky-400 bg-sky-900/30 px-2 py-1 rounded border border-sky-500/20" id="perk-essence">Essence: 0 ‚ú®</div>
                    </div>
                    
                    <div class="grid grid-cols-2 md:grid-cols-2 lg:grid-cols-2 gap-3" id="shop-cards">
                        <!-- Shop Items injected here -->
                    </div>
                </div>
            </div>

            <!-- Footer: Fixed Continue Button -->
            <div class="p-4 border-t border-white/5 bg-slate-900/40 shrink-0 flex justify-center z-10">
                <button id="continue-btn" class="w-full max-w-md py-3 bg-indigo-600 rounded-xl font-black text-white text-sm uppercase tracking-widest shadow-lg shadow-indigo-900/40 hover:bg-indigo-500 transition-all active:scale-95">Next Floor</button>
            </div>

        </div>
    </div>

    <!-- Help -->
    <div id="help-screen" class="fixed inset-0 z-[160] bg-slate-950/90 backdrop-blur hidden items-center justify-center p-6">
        <div class="glass-panel w-full max-w-2xl p-8 border border-white/10">
            <div class="flex justify-between items-center mb-6">
                <div>
                    <div class="text-[10px] text-slate-400 uppercase tracking-[0.35em]">HELP</div>
                    <div class="text-3xl font-black tracking-tight">Guide</div>
                </div>
                <button id="help-close" class="px-4 py-2 glass-panel font-black text-xs uppercase tracking-widest hover:bg-white/10 active:scale-95 transition-colors">Close</button>
            </div>
            <div class="text-slate-300 text-sm leading-loose whitespace-pre-line font-medium" id="help-text"></div>
        </div>
    </div>

    <div id="dev-tests"></div>

    <script>
        // --- „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£ ---
        function clamp(val, min, max){ return Math.min(Math.max(val, min), max); }
        function randInt(n){ return Math.floor(Math.random()*n); }
        function pick(arr){ return arr[randInt(arr.length)]; }
        function deepCopy(x){ return JSON.parse(JSON.stringify(x)); }
        function ui(id){ return document.getElementById(id); }
        function setText(id, text){
            const el = document.getElementById(id);
            if(el) el.textContent = text;
        }

        // --- „Éà„Éº„Çπ„ÉàÈÄöÁü• ---
        function showToast(msg, color='sky'){
            const container = ui('toast-container');
            const el = document.createElement('div');
            el.className = `toast-msg text-${color}-300 border-${color}-500/30`;
            el.innerHTML = `<span>‚óà</span> ${msg}`;
            container.appendChild(el);
            setTimeout(() => {
                el.classList.add('fade-out');
                setTimeout(() => el.remove(), 300);
            }, 3000);
        }

        // --- „Çª„Éº„ÉñÊ©üËÉΩ (LocalStorage) ---
        const SAVE_KEY = 'abyssal_alchemy_save_v1';

        function saveGame() {
            try {
                const data = JSON.stringify(gameState);
                localStorage.setItem(SAVE_KEY, data);
            } catch (e) {
                console.error("Save failed:", e);
                showToast("Save failed (Storage Full?)", "red");
            }
        }

        function loadGame() {
            try {
                const data = localStorage.getItem(SAVE_KEY);
                if (data) {
                    const loadedState = JSON.parse(data);
                    Object.assign(gameState, loadedState);
                    updateTubeLayout();
                    perkScreen.classList.add('hidden');
                    startScreen.classList.add('hidden');
                    renderHUD();
                    renderBoard();
                    showToast(currentLang==='ja'?'ÂÜçÈñã„Åó„Åæ„Åó„Åü':'Game Loaded', 'emerald');
                    return true;
                }
            } catch (e) {
                console.error("Load failed:", e);
                showToast("Save data corrupted", "red");
            }
            return false;
        }

        function clearSave() {
            localStorage.removeItem(SAVE_KEY);
        }

        function hasSaveData() {
            return !!localStorage.getItem(SAVE_KEY);
        }

        // --- ÁøªË®≥„Éá„Éº„Çø ---
        const translations = {
            en: {
                subtitle: "Abyssal Alchemy",
                startBtn: "New Descent",
                continueBtn: "Continue",
                vitality: "HP",
                floor: "FLOOR",
                essence: "Essence",
                turn: "TURN",
                secondary: "BONUS",
                perks: "PERKS",
                hint: "Select a tube to pour",
                goalTitle: "GOAL",
                pressureTitle: "PRESSURE",
                eventKicker: "EVENT",
                unavoid: "Unavoidable",
                helpTitle: "How to play",
                helpText: [
                    "‚Ä¢ Pour water: Click a tube, then click another to pour.",
                    "‚Ä¢ Obsidian (Black Ink): Match 4 to evaporate them and clear the tube!",
                    "‚Ä¢ Pressure: Rises with every move. If it fills, you take 1 Damage.",
                    "‚Ä¢ Survival: No Move limit. Manage your HP and Pressure to survive.",
                    "‚Ä¢ Artifacts: Buy skills in the shop. Use them from the bottom bar.",
                    "‚Ä¢ Undo: Use the button below (Costs 5 Essence).",
                ].join("\n"),
                helpClose: "Close",
                settings: "Settings",
                continue: "Continue",
                shopTitle: "Shop",
                shopSub: "Trade Essence for survival",
                gameOver: "Consumed",
                gameOverSub: "The abyss claims another soul...",
                victory: "Mutation",
                victorySub: "Select a mutation to evolve",
            },
            ja: {
                subtitle: "Èå¨ÈáëË°ì„ÅÆÊ∑±Ê∑µ",
                startBtn: "Êñ∞„Åü„Å™Êé¢Á¥¢",
                continueBtn: "„Å§„Å•„Åç„Åã„Çâ",
                vitality: "HP",
                floor: "ÈöéÂ±§",
                essence: "„Ç®„ÉÉ„Çª„É≥„Çπ",
                turn: "ÁµåÈÅé„Çø„Éº„É≥",
                secondary: "ÂâØÁõÆÊ®ô",
                perks: "Â§âÁï∞",
                hint: "„ÉÅ„É•„Éº„Éñ„ÇíÈÅ∏Êäû„Åó„Å¶Ê≥®„Åê",
                goalTitle: "ÁõÆÊ®ô",
                pressureTitle: "ÂúßÂäõ",
                eventKicker: "Â§âË≥™",
                unavoid: "‰∏çÂèØÈÅø",
                helpTitle: "ÈÅä„Å≥Êñπ",
                helpText: [
                    "„ÉªÊ≥®„ÅêÔºö„ÉÅ„É•„Éº„Éñ„ÇíÈÅ∏Êäû„Åó„ÄÅÂà•„ÅÆ„ÉÅ„É•„Éº„Éñ„Å∏Ê≥®„Åé„Åæ„Åô",
                    "„ÉªÈªí„Ç§„É≥„ÇØÔºö4„Å§ÊèÉ„Åà„Çã„Å®Ëí∏Áô∫„Åó„Å¶Ê∂à„Åà„ÄÅÁ©∫„ÅçÁì∂„Å´„Å™„Çä„Åæ„Åô„ÄÇ",
                    "„ÉªÂúßÂäõÔºö1Êâã„Åî„Å®„Å´‰∏äÊòá„Åó„Åæ„Åô„ÄÇÊúÄÂ§ß„Å´„Å™„Çã„Å®HP„Åå1Ê∏õ„Çä„Åæ„Åô„ÄÇ",
                    "„ÉªÁîüÂ≠òÔºöÊâãÊï∞Âà∂Èôê„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇHP„ÅåÂ∞Ω„Åç„Å™„ÅÑÈôê„ÇäÊé¢Á¥¢„ÇíÁ∂ö„Åë„Çâ„Çå„Åæ„Åô„ÄÇ",
                    "„ÉªÈÅìÂÖ∑„Å®ÁßòË°ìÔºö„Ç∑„Éß„ÉÉ„Éó„Åß„Çπ„Ç≠„É´„ÇíË≥ºÂÖ•„Åó„ÄÅÁîªÈù¢‰∏ãÈÉ®„Åã„Çâ‰ΩøÁî®„Åó„Åæ„Åô",
                    "„Éª„ÇÑ„ÇäÁõ¥„ÅóÔºöÂè≥‰∏ã„ÅÆUNDO„Éú„Çø„É≥„Çí‰ΩøÁî®„Åó„Åæ„ÅôÔºàÊ∂àË≤ªÔºö5„Ç®„ÉÉ„Çª„É≥„ÇπÔºâ",
                    "„Éª„Ç¢„Ç§„ÉÜ„É†Ôºö„Ç¢„Ç§„Ç≥„É≥„Çí1Âõû„Çø„ÉÉ„Éó„ÅßÈÅ∏Êäû(Á¢∫Ë™ç)„ÄÅ2ÂõûÁõÆ„Åß‰ΩøÁî®/„É¢„Éº„ÉâÁßªË°å„Åó„Åæ„Åô„ÄÇ",
                ].join("\n"),
                helpClose: "Èñâ„Åò„Çã",
                settings: "Ë®≠ÂÆö",
                continue: "Ê¨°„Å∏ÈÄ≤„ÇÄ",
                shopTitle: "„Ç∑„Éß„ÉÉ„Éó",
                shopSub: "„Ç®„ÉÉ„Çª„É≥„Çπ„ÇíÊ∂àË≤ª„Åó„Å¶ÂÆâÂÆö„ÇíÂæó„Çã",
                gameOver: "Â•àËêΩ„Å´Âëë„Åæ„Çå„Åü",
                gameOverSub: "Ê∑±Ê∑µ„ÅØ„Åæ„Åü‰∏Ä„Å§È≠Ç„ÇíÂñ∞„Çâ„Å£„Åü...",
                victory: "Â§âÁï∞„ÅÆÂÖÜ„Åó",
                victorySub: "Âäõ„ÇíÈÅ∏„Çì„ÅßÈÄ≤Âåñ„Åô„Çã",
            }
        };

        let currentLang = 'ja';

        function setLang(lang){
            currentLang = lang;
            document.getElementById('lang-en').classList.toggle('active', lang==='en');
            document.getElementById('lang-ja').classList.toggle('active', lang==='ja');
            applyLang();
            updateStartScreenButtons();
            renderHUD();
        }

        function t(key){
            return translations[currentLang]?.[key] ?? translations.en[key] ?? key;
        }

        function applyLang(){
            setText('start-subtitle', t('subtitle'));
            setText('start-run-btn', t('startBtn'));
            setText('continue-btn-text', t('continueBtn'));
            setText('ui-subtitle', t('subtitle'));
            setText('ui-title', translations.en.subtitle);
            setText('ui-goal-title', t('goalTitle'));
            setText('help-text', t('helpText'));
            setText('help-close', t('helpClose'));
        }

        // --- „Ç≤„Éº„É†ÂÆöÁæ© ---
        const COLOR_POOL = [
            { key: 'R', name:{en:'Crimson', ja:'Á¥Ö'}, hex:'#dc2626' }, 
            { key: 'B', name:{en:'Azure', ja:'Ëíº'}, hex:'#3b82f6' },
            { key: 'Y', name:{en:'Amber', ja:'Áê•ÁèÄ'}, hex:'#fbbf24' },
            { key: 'W', name:{en:'Ivory', ja:'Ë±°Áâô'}, hex:'#e2e8f0' },
            { key: 'K', name:{en:'Obsidian', ja:'Èªí'}, hex:'#0f172a' },
            { key: 'G', name:{en:'Emerald', ja:'Áø†'}, hex:'#22c55e' }, 
            { key: 'P', name:{en:'Amethyst', ja:'Á¥´'}, hex:'#a855f7' }, 
            { key: 'O', name:{en:'Orange', ja:'Ê©ô'}, hex:'#f97316' }, 
            { key: 'T', name:{en:'Teal', ja:'ÈùíÁ∑ë'}, hex:'#06b6d4' }, 
            { key: 'M', name:{en:'Pink', ja:'Ê°É'}, hex:'#d946ef' }, 
        ];

        // --- Perks ---
        const PERKS = {
            catalyst: {
                id:'catalyst',
                name:{en:'Catalyst', ja:'Ëß¶Â™íÂèçÂøú'},
                rarity:'rare',
                desc:{en:'Completing a tube reduces Pressure by [4 + Lv].', ja:'Ëâ≤„ÇíÂÆåÊàê„Åï„Åõ„Çã„Å®ÂúßÂäõ„Åå [4 + Lv] ‰∏ã„Åå„Çã„ÄÇ'},
            },
            efficiency: {
                id:'efficiency',
                name:{en:'Efficiency', ja:'ÊäΩÂá∫ÂäπÁéá'},
                rarity:'common',
                desc:{en:'Tube completion has [Lv x 20]% chance to grant +1 Essence.', ja:'Ëâ≤ÂÆåÊàêÊôÇ„ÄÅ[Lv x 20]% „ÅÆÁ¢∫Áéá„Åß +1 „Ç®„ÉÉ„Çª„É≥„Çπ„ÇíÁç≤Âæó„ÄÇ'},
            },
            transmutation: {
                id:'transmutation',
                name:{en:'Transmutation', ja:'Áâ©Ë≥™Â§âÊèõ'},
                rarity:'rare',
                desc:{en:'Start each floor with [Lv] random items.', ja:'ÈöéÂ±§ÈñãÂßãÊôÇ„ÄÅ[Lv] ÂÄã„ÅÆ„É©„É≥„ÉÄ„É†„Ç¢„Ç§„ÉÜ„É†„ÇíÁç≤Âæó„Åô„Çã„ÄÇ'},
            },
            momentum: {
                id:'momentum',
                name:{en:'Momentum', ja:'ÊÖ£ÊÄßÂæã'},
                rarity:'common',
                desc:{en:'After completing a tube, Pressure does not rise for [Lv] turns.', ja:'„ÉÅ„É•„Éº„ÉñÂÆåÊàêÂæå„ÄÅ[Lv] „Çø„Éº„É≥„ÅÆÈñì„ÄÅÂúßÂäõ„Åå‰∏äÊòá„Åó„Å™„ÅÑ„ÄÇ'},
            },
            reflux: {
                id:'reflux',
                name:{en:'Reflux', ja:'ÈÄÜÊµÅÂà∂Âæ°'},
                rarity:'common',
                desc:{en:'First [Lv] undos each floor are free (Pressure +2 instead).', ja:'ÂêÑÈöéÂ±§„ÄÅÊúÄÂàù„ÅÆ [Lv] Âõû„ÅÆUndo„ÅØ„Ç®„ÉÉ„Çª„É≥„ÇπÁÑ°Êñô„ÄÇ'},
            },
            steady_hand: {
                id:'steady_hand',
                name:{en:'Steady Hand', ja:'ÂÆâÂÆö„Åó„ÅüÊâã'},
                rarity:'rare',
                desc:{en:'Pressure does not rise for the first [Lv x 3] turns of a floor.', ja:'ÈöéÂ±§ÈñãÂßã„Åã„Çâ [Lv x 3] „Çø„Éº„É≥„ÅÆÈñì„ÄÅÂúßÂäõ„Åå‰∏äÊòá„Åó„Å™„ÅÑ„ÄÇ'},
            },
            overflow: {
                id:'overflow',
                name:{en:'Overflow', ja:'„Ç™„Éº„Éê„Éº„Éï„É≠„Éº'},
                rarity:'common',
                desc:{en:'Pressure max +[Lv x 4].', ja:'ÂúßÂäõ„ÅÆÊúÄÂ§ßË®±ÂÆπÈáè„Åå +[Lv x 4] „Åï„Çå„Çã„ÄÇ'},
            },
            purification: {
                id:'purification',
                name:{en:'Purification', ja:'ÊµÑÂåñ‰ΩúÁî®'},
                rarity:'epic',
                desc:{en:'Clearing Obsidian reduces Pressure by [2 + Lv] and grants [1 + Lv] Essence.', ja:'Èªí„Ç§„É≥„ÇØÊ∂àÊªÖÊôÇ„ÄÅÂúßÂäõ-[2 + Lv]„ÄÅ„Ç®„ÉÉ„Çª„É≥„Çπ+[1 + Lv]„ÄÇ'},
            },
            scavenger: {
                id:'scavenger',
                name:{en:'Scavenger', ja:'„Çπ„Ç´„Éô„É≥„Ç∏„É£„Éº'},
                rarity:'rare',
                desc:{en:'[10 + Lv x 5]% chance to find item on new floor.', ja:'ÈöéÂ±§ÁßªÂãïÊôÇ„ÄÅ[10 + Lv x 5]% „ÅÆÁ¢∫Áéá„Åß„Ç¢„Ç§„ÉÜ„É†„ÇíÊãæ„ÅÜ„ÄÇ'},
            },
            recycler: {
                id:'recycler',
                name:{en:'Recycler', ja:'„É™„Çµ„Ç§„ÇØ„É´'},
                rarity:'epic',
                desc:{en:'[Lv x 10]% chance to not consume item on use.', ja:'„Ç¢„Ç§„ÉÜ„É†‰ΩøÁî®ÊôÇ„ÄÅ[Lv x 10]% „ÅÆÁ¢∫Áéá„ÅßÊ∂àË≤ª„Åó„Å™„ÅÑ„ÄÇ'},
            },
            bargain: {
                id:'bargain',
                name:{en:'Bargain', ja:'‰∫§Ê∏âË°ì'},
                rarity:'common',
                desc:{en:'Shop prices reduced by [15 + Lv x 5]%.', ja:'„Ç∑„Éß„ÉÉ„Éó‰æ°Ê†º [15 + Lv x 5]% OFF„ÄÇ'},
            },
            heavy_mastery: {
                id:'heavy_mastery',
                name:{en:'Heavy Mastery', ja:'Â§ßÂÆπÈáè„Éú„Éº„Éä„Çπ'},
                rarity:'rare',
                desc:{en:'Clearing 5+ capacity tube reduces Pressure by [2 + Lv].', ja:'ÂÆπÈáè5‰ª•‰∏ä„ÅÆ„ÉÅ„É•„Éº„ÉñÂÆåÊàê„ÅßÂúßÂäõ [2 + Lv] Ê∏õÂ∞ë„ÄÇ'},
            },
            void_shield: {
                id:'void_shield',
                name:{en:'Void Shield', ja:'ËôöÁ©∫„ÅÆÁõæ'},
                rarity:'rare',
                desc:{en:'[Lv x 15]% chance to negate Pressure damage.', ja:'ÂúßÂäõ„ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„ÅüÊôÇ„ÄÅ[Lv x 15]% „ÅßÁÑ°ÂäπÂåñ„Åô„Çã„ÄÇ'},
            },
            deep_adapt: {
                id:'deep_adapt',
                name:{en:'Deep Adapt', ja:'Ê∑±Â±§ÈÅ©Âøú'},
                rarity:'epic',
                desc:{en:'Gain [Lv] Max HP if capacity > 4 at start of floor.', ja:'ÈöéÂ±§ÈñãÂßãÊôÇ„ÄÅÂÆπÈáè5‰ª•‰∏ä„Å™„ÇâÊúÄÂ§ßHP+[Lv]„ÄÇ'},
            },
            flow_mastery: {
                id:'flow_mastery',
                name:{en:'Flow Mastery', ja:'„Éï„É≠„ÉºÁÜüÁ∑¥'},
                rarity:'common',
                desc:{en:'Combo reduces Pressure by [Lv x 2].', ja:'„Ç≥„É≥„ÉúÁô∫ÁîüÊôÇ„ÄÅÂúßÂäõ„Åå [Lv x 2] ‰∏ã„Åå„Çã„ÄÇ'},
            },
            coupon: {
                id: 'coupon',
                name: {en:'Coupon', ja:'„ÇØ„Éº„Éù„É≥Âà∏'},
                rarity: 'common',
                desc: {en:'Start each floor with [Lv] free Rerolls.', ja:'ÂêÑÈöéÂ±§ÈñãÂßãÊôÇ„ÄÅÁÑ°Êñô„Åß„É™„É≠„Éº„É´„Åß„Åç„Çã„ÇØ„Éº„Éù„É≥„Çí [Lv] ÊûöÂæó„Çã„ÄÇ'}
            }
        };

        // --- Items & Skills ---
        const ITEMS = {
            extractor: {
                id: 'extractor', type: 'consumable', cost: 12, icon: 'üíâ',
                name: {en:'Extractor', ja:'„Çπ„Éù„Ç§„ÉàÊäΩÂá∫'},
                desc: {en:'Move top color to any empty space.', ja:'‰∏ÄÁï™‰∏ä„ÅÆËâ≤„ÇíÂê∏„ÅÑÂèñ„Çä„ÄÅÁ©∫„Åç„Åå„ÅÇ„ÇãÂ•Ω„Åç„Å™Â†¥ÊâÄ„Å∏Áßª„Åô'}
            },
            pipette: {
                id: 'pipette', type: 'tool', cost: 10, icon: '‚öóÔ∏è',
                name: {en:'Pipette', ja:'Á≤æÂØÜ„Éî„Éö„ÉÉ„Éà'},
                desc: {en:'Toggle: Pour 1 segment.', ja:'ÂàáÊõøÔºö1ÁõÆÁõõ„Çä„Å†„ÅëÊ≥®„Åê'}
            },
            inverter: {
                id: 'inverter', type: 'consumable', cost: 6, icon: 'üîÑ',
                name: {en:'Gravity Coil', ja:'ÈáçÂäõÂèçËª¢Ê©ü'},
                desc: {en:'Invert contents.', ja:'‰∏≠Ë∫´„Çí‰∏ä‰∏ãÂèçËª¢'}
            },
            void_salt: {
                id: 'void_salt', type: 'consumable', cost: 8, icon: 'üßÇ',
                name: {en:'Void Salt', ja:'ËôöÁÑ°„ÅÆÂ°©'},
                desc: {en:'Remove top Black.', ja:'‰∏ÄÁï™‰∏ä„ÅÆ„ÄêÈªí„Äë„ÇíÈô§Âéª'}
            },
            separator: {
                id: 'separator', type: 'consumable', cost: 12, icon: 'üå™Ô∏è',
                name: {en:'Separator', ja:'ÈÅ†ÂøÉÂàÜÈõ¢Ê©ü'},
                desc: {en:'Sort tube contents.', ja:'‰∏≠Ë∫´„ÇíÊï¥ÁêÜ„Åô„Çã'}
            },
            summon_vial: {
                id: 'summon_vial', type: 'consumable', cost: 15, icon: 'üß™',
                name: {en:'Extra Vial', ja:'‰∫àÂÇô„Éï„É©„Çπ„Ç≥'},
                desc: {en:'Add empty tube.', ja:'Á©∫„ÅçÁì∂„Çí1„Å§ËøΩÂä†'}
            },
            cycle_siphon: {
                id: 'cycle_siphon', type: 'consumable', cost: 9, icon: '‚è´',
                name: {en:'Cycle Siphon', ja:'Âæ™Áí∞„Çµ„Ç§„Éï„Ç©„É≥'},
                desc: {en:'Move bottom to top.', ja:'‰∏ÄÁï™‰∏ã„Çí‰∏ÄÁï™‰∏ä„Å∏'}
            },
            sedative: {
                id: 'sedative', type: 'consumable', cost: 12, icon: 'üí§',
                name: {en:'Sedative', ja:'ÈéÆÈùôÂâ§'},
                desc: {en:'Set Pressure to 0.', ja:'ÂúßÂäõ„Çí0„Å´„Åô„Çã'}
            },
            sediment: {
                id: 'sediment', type: 'consumable', cost: 10, icon: '‚è¨',
                name: {en:'Sediment', ja:'Ê≤àÊÆø'},
                desc: {en:'Move top to bottom.', ja:'‰∏ÄÁï™‰∏ä„Çí‰∏ÄÁï™‰∏ã„Å∏'}
            },
            layer_swap: {
                id: 'layer_swap', type: 'consumable', cost: 12, icon: 'üîó',
                name: {en:'Layer Swap', ja:'Â±§‰∫§Êèõ'},
                desc: {en:'Swap top 2 layers.', ja:'‰∏ä2„Å§„ÅÆÂ±§„ÇíÂÖ•„ÇåÊõø„Åà'}
            },
            vacuum: {
                id: 'vacuum', type: 'consumable', cost: 14, icon: 'üåÄ',
                name: {en:'Obsidian Vacuum', ja:'ÈªíÂê∏ÂºïÊ©ü'},
                desc: {en:'Remove all top Obsidian.', ja:'‰∏ÄÁï™‰∏ä„ÅÆÈªí„Ç§„É≥„ÇØ„ÇíÂÖ®Èô§Âéª'}
            },
            midas: {
                id: 'midas', type: 'consumable', cost: 8, icon: 'üñêÔ∏è',
                name: {en:'Alchemy Stone', ja:'ÂØæÈªíÂ§âÊàê'},
                desc: {en:'Obsidian > Essence.', ja:'‰∏ÄÁï™‰∏ä„ÅÆÈªí„Çí„Ç®„ÉÉ„Çª„É≥„Çπ„Å´'}
            },
            shaker: {
                id: 'shaker', type: 'consumable', cost: 5, icon: 'üé≤',
                name: {en:'Shaker', ja:'„Ç∑„Çß„Ç§„Ç´„Éº'},
                desc: {en:'Shuffle tube.', ja:'‰∏≠Ë∫´„Çí„Ç∑„É£„ÉÉ„Éï„É´'}
            },
            cursed_sludge: {
                id: 'cursed_sludge', type: 'consumable', cost: 6, icon: '‚ö´',
                name: {en:'Cursed Sludge', ja:'Âë™„ÅÑ„ÅÆÊ≥•'},
                desc: {en:'Add Obsidian if space.', ja:'Á©∫„Åç„Åå„ÅÇ„Çå„Å∞Èªí„ÇíËøΩÂä†'}
            }
        };

        const INSTANT_ITEMS = [
            { 
                id:'heal', type:'stat', cost:8, 
                name:{en:'Stabilizer', ja:'ÂÆâÂÆöÂâ§'}, 
                desc:{en:'Heal +1 HP', ja:'HP+1'}, 
                apply(gs){ 
                    gs.hp = Math.min(gs.maxHp, gs.hp + 1);
                    showToast('HP Recovered!', 'rose'); 
                } 
            },
            { 
                id:'relief', type:'stat', cost:5, 
                name:{en:'Vent Valve', ja:'ÂúßÂäõÂºÅ'}, 
                desc:{en:'Pressure -5', ja:'ÂúßÂäõ-5'}, 
                apply(gs){ gs.pressure = Math.max(0, gs.pressure-5); showToast('Pressure Released!', 'sky'); } 
            },
            { 
                id:'panacea', type:'stat', cost:20, 
                name:{en:'Panacea', ja:'‰∏áËÉΩËñ¨'}, 
                desc:{en:'HP+1, Pressure=0', ja:'HP+1, ÂúßÂäõÂÖ®ÂõûÂæ©'}, 
                apply(gs){ 
                    gs.hp = Math.min(gs.maxHp, gs.hp + 1);
                    gs.pressure = 0; 
                    showToast('Full Restore!', 'emerald'); 
                } 
            },
            { 
                id:'dark_pact', type:'stat', cost:0, 
                name:{en:'Dark Pact', ja:'Èªí„ÅÆÂ•ëÁ¥Ñ'}, 
                desc:{en:'HP-1, +20 Ess', ja:'HP-1, +20„Ç®„ÉÉ„Çª„É≥„Çπ'}, 
                apply(gs){ 
                    if(gs.hp > 1){
                        gs.hp -= 1; gs.essence += 20; 
                        showToast('Power at a cost...', 'purple'); 
                    } else {
                        showToast('Too weak...', 'red');
                    }
                } 
            },
            { 
                id:'mystery_box', type:'stat', cost:5, 
                name:{en:'Mystery Box', ja:'Á¶èË¢ã'}, 
                desc:{en:'Random Item', ja:'„É©„É≥„ÉÄ„É†„Ç¢„Ç§„ÉÜ„É†'}, 
                apply(gs){ 
                    const keys = Object.keys(ITEMS);
                    const gift = pick(keys);
                    if(!gs.inventory[gift]) gs.inventory[gift] = 0;
                    gs.inventory[gift]++;
                    showToast(`Got ${ITEMS[gift].name[currentLang==='ja'?'ja':'en']}!`, 'yellow');
                } 
            }
        ];

        const SHOP_POOL = [
            ...INSTANT_ITEMS,
            ...Object.values(ITEMS).map(i => ({ id: `buy_${i.id}`, type: 'item', ref: i }))
        ];

        // --- „Ç≤„Éº„É†Áä∂ÊÖã ---
        const gameState = {
            floor: 1,
            essence: 0,
            hp: 3,
            maxHp: 3,
            turnCount: 0, 
            capacity: 4,
            tubeCount: 0,
            selectedIdx: null,
            tubes: [],
            busy: false,
            perks: {},
            inventory: {}, 
            pressure: 0,
            pressureMax: 14,
            catalystAvailable: true,
            refluxUses: 0,
            momentumTurns: 0,
            history: [],
            primaryGoal: null,
            secondaryGoal: null,
            secondaryProgress: 0,
            focusIdx: null, 
            currentPerkChoices: null,
            currentShopOffers: null,
            pipetteMode: false,
            targetMode: null, 
            pendingSkill: null, // Êñ∞Ë¶è: Á¢∫Ë™çÂæÖ„Å°„ÅÆ„Çπ„Ç≠„É´ID
            extractorHeldColor: null, // Êñ∞Ë¶è: ÊäΩÂá∫‰∏≠„ÅÆËâ≤
            rerollCoupons: 0,
        };

        // --- DOM ---
        const tubesContainer = ui('tubes-container');
        const boardArea = ui('board-area');
        const boardScrollArea = ui('board-scroll-area');
        const skillsContainer = ui('skills-container');
        const startScreen = ui('start-screen');
        const perkScreen = ui('perk-screen');
        const perkCards = ui('perk-cards');
        const shopCards = ui('shop-cards');
        const continueBtn = ui('continue-btn');
        const rerollBtn = ui('reroll-btn');
        const helpScreen = ui('help-screen');
        const eventScreen = ui('event-screen');
        const eventChoices = ui('event-choices');
        const devTests = ui('dev-tests');
        const alertBanner = ui('alert-banner');
        const undoBtn = ui('btn-undo');
        const continueRunBtn = ui('continue-run-btn');

        // --- Helper ---
        function getPerkLevel(id){ return gameState.perks[id] || 0; }
        function hasPerk(id){ return (gameState.perks[id] || 0) > 0; }
        function getPerkDesc(id, level=1){
            const def = PERKS[id];
            let txt = currentLang==='ja' ? def.desc.ja : def.desc.en;
            txt = txt.replace(/\[Lv\]/g, level);
            txt = txt.replace(/\[4 \+ Lv\]/g, 4 + level);
            txt = txt.replace(/\[Lv x 20\]/g, level * 20);
            txt = txt.replace(/\[Lv x 3\]/g, level * 3);
            txt = txt.replace(/\[Lv x 4\]/g, level * 4);
            txt = txt.replace(/\[2 \+ Lv\]/g, 2 + level);
            txt = txt.replace(/\[1 \+ Lv\]/g, 1 + level);
            txt = txt.replace(/\[10 \+ Lv x 5\]/g, 10 + level * 5);
            txt = txt.replace(/\[Lv x 10\]/g, level * 10);
            txt = txt.replace(/\[15 \+ Lv x 5\]/g, 15 + level * 5);
            txt = txt.replace(/\[Lv x 15\]/g, level * 15);
            txt = txt.replace(/\[Lv x 2\]/g, level * 2);
            return txt;
        }

        // --- Game Logic ---
        function tubeTop(t){ return t.length ? t[t.length-1] : null; }
        function tubeFree(t){ return gameState.capacity - t.length; }
        function isCompleteTube(t){
            if (t.length !== gameState.capacity) return false;
            return t.every(c => c === t[0]);
        }
        function colorMeta(key){ return COLOR_POOL.find(c => c.key===key); }
        function colorName(key){ const m=colorMeta(key); return currentLang==='ja' ? m.name.ja : m.name.en; }

        function generateGoals(){
            const flat = gameState.tubes.flat();
            const presentColors = new Set(flat);
            presentColors.delete('K'); 
            const colors = [...presentColors];

            if (colors.length === 0) {
                gameState.primaryGoal = { type:'survive', text: currentLang==='ja'?'Áîü„ÅçÂª∂„Å≥„Çç':'Survive' };
                return;
            }

            const roll = Math.random();
            if (roll < 0.50){
                const maxN = colors.length;
                const n = clamp(Math.floor(maxN / 1.5), 1, maxN);
                gameState.primaryGoal = {
                    type:'completeN', n:n,
                    text: currentLang==='ja' ? `„ÅÑ„Åö„Çå„Åã${n}Ëâ≤„ÇíÂÆåÊàê` : `Complete any ${n} colors`
                };
            } else {
                const c = pick(colors);
                gameState.primaryGoal = {
                    type:'completeColor', color:c,
                    text: currentLang==='ja' ? `${colorName(c)}„ÇíÂÆåÊàê` : `Complete ${colorName(c)}`
                };
            }
            
            const sroll = Math.random();
            const par = 14 + Math.floor(gameState.floor / 2) + 5; 
            if (sroll < 0.5){
                gameState.secondaryGoal = {
                    type:'speed', limit: par,
                    text: currentLang==='ja' ? `${par}„Çø„Éº„É≥‰ª•ÂÜÖ„Å´1Êú¨ÂÆåÊàê` : `Complete 1 within ${par} turns`
                };
            } else {
                gameState.secondaryGoal = {
                    type:'combo', need:2,
                    text: currentLang==='ja' ? 'ÈÄ£Á∂öÂÆåÊàêÔºà„Ç≥„É≥„ÉúÔºâ' : 'Combo: 2 in a row'
                };
            }
            gameState.secondaryProgress = 0;
            renderHUD();
        }

        function checkPrimaryGoal(){
            if (gameState.primaryGoal.type === 'completeN') {
                return countCompletedTubes() >= gameState.primaryGoal.n;
            }
            if (gameState.primaryGoal.type === 'completeColor'){
                return gameState.tubes.some(t => isCompleteTube(t) && t[0] === gameState.primaryGoal.color);
            }
            if (gameState.primaryGoal.type === 'survive') return false; 
            return false;
        }
        
        function checkLevelClear(){
            if (checkPrimaryGoal()) return true;
            const allClean = gameState.tubes.every(t => t.length === 0 || (isCompleteTube(t) && t[0] !== 'K'));
            if (allClean) return true;
            return false;
        }

        function onLevelClear(){
            const base = 6;
            const bonus = secondarySucceeded() ? 4 : 0;
            gameState.essence += (base + bonus);
            
            const msg = currentLang==='ja' 
                ? `„Ç®„É™„Ç¢Á¢∫‰øù! +${base}‚ú®${bonus>0 ? ` („Éú„Éº„Éä„Çπ +${bonus}‚ú®)` : ''}`
                : `Area Cleared! +${base}‚ú®${bonus>0 ? ` (Bonus +${bonus}‚ú®)` : ''}`;
            
            showToast(msg, bonus>0 ? 'emerald' : 'sky');
            saveGame();
            setTimeout(() => openPerkScreen(false), 1500);
        }

        function checkSecondaryGoalOnComplete(){
            if (!gameState.secondaryGoal) return;
            if (gameState.secondaryGoal.type === 'speed'){
                if (gameState.turnCount <= gameState.secondaryGoal.limit){
                    gameState.secondaryProgress = 1; 
                }
            } else if (gameState.secondaryGoal.type === 'combo'){
                gameState.secondaryProgress += 1;
                if(hasPerk('flow_mastery') && gameState.secondaryProgress >= 2){
                    const lv = getPerkLevel('flow_mastery');
                    gameState.pressure = Math.max(0, gameState.pressure - (lv * 2));
                    showFloatText(0, `Flow! -${lv*2} Pressure`, '#38bdf8');
                }
            }
        }

        function secondarySucceeded(){
            if (!gameState.secondaryGoal) return false;
            if (gameState.secondaryGoal.type === 'speed') return gameState.secondaryProgress >= 1;
            if (gameState.secondaryGoal.type === 'combo') return gameState.secondaryProgress >= gameState.secondaryGoal.need;
            return false;
        }
        
        function isDeadlocked(){
            for(let i=0; i<gameState.tubes.length; i++){
                if(gameState.tubes[i].length === 0) continue; 
                for(let j=0; j<gameState.tubes.length; j++){
                    if(i===j) continue;
                    const check = canPour(i, j);
                    if(check.ok) return false; 
                }
            }
            return true; 
        }

        function generateBoard(){
            const floor = gameState.floor;
            gameState.tubeCount = Math.min(10, 6 + Math.floor((floor-1)/2));
            const numColors = gameState.tubeCount - 2;

            const safeNumColors = Math.min(numColors, COLOR_POOL.length);
            
            const pool = COLOR_POOL.slice(0, Math.min(COLOR_POOL.length, safeNumColors + (floor > 5 ? 1 : 0))).map(c=>c.key);
            const colors = [];
            
            let failsafe = 0;
            while(colors.length < safeNumColors){
                const c = pick(pool);
                if(!colors.includes(c)) colors.push(c);
                failsafe++;
                if(failsafe > 100) break; 
            }

            const bag = [];
            for (const c of colors) for (let i=0;i<gameState.capacity;i++) bag.push(c);

            for (let i=bag.length-1;i>0;i--){
                const j = randInt(i+1);
                [bag[i], bag[j]] = [bag[j], bag[i]];
            }

            const tubes = Array.from({length: gameState.tubeCount}, () => []);
            let k=0;
            for (let t=0;t<safeNumColors;t++){
                for (let s=0;s<gameState.capacity;s++) {
                    if(k < bag.length) tubes[t].push(bag[k++]);
                }
            }

            for (let i=0;i<20;i++){
                const t1 = randInt(safeNumColors);
                const t2 = randInt(safeNumColors);
                if (t1===t2) continue;
                const s1 = randInt(gameState.capacity);
                const s2 = randInt(gameState.capacity);
                if(tubes[t1][s1] && tubes[t2][s2]) {
                    [tubes[t1][s1], tubes[t2][s2]] = [tubes[t2][s2], tubes[t1][s1]];
                }
            }

            gameState.tubes = tubes;
            updateTubeLayout();
        }
        
        function updateTubeLayout(){
            const cap = gameState.capacity;
            let segHeight = 40;
            if(cap >= 6) segHeight = 32;
            else if(cap >= 5) segHeight = 36;
            
            const tubeHeight = (segHeight * cap) + 40;

            document.documentElement.style.setProperty('--segment-height', `${segHeight}px`);
            document.documentElement.style.setProperty('--tube-height', `${tubeHeight}px`);
        }

        function renderBoard(){
            tubesContainer.innerHTML = '';
            
            const deadlocked = isDeadlocked();
            if (alertBanner) alertBanner.style.opacity = deadlocked ? '1' : '0';

            gameState.tubes.forEach((segments, i) => {
                const tube = document.createElement('div');
                tube.className = 'tube';
                tube.dataset.idx = String(i);

                if (i === gameState.selectedIdx) tube.classList.add('selected');
                if (gameState.focusIdx !== null && i === gameState.focusIdx) {
                    tube.classList.add('tube-focused');
                }
                if (deadlocked) tube.classList.add('deadlock-glow');
                
                if (gameState.targetMode === 'extractor' && gameState.extractorHeldColor) {
                    if(segments.length < gameState.capacity) {
                        tube.classList.add('target-mode');
                        tube.style.cursor = 'crosshair';
                    }
                } 
                else if (gameState.targetMode) {
                    if(gameState.targetMode === 'extractor' && segments.length === 0) {
                        // skip style
                    } else {
                        tube.classList.add('target-mode');
                        tube.style.cursor = 'crosshair';
                    }
                }

                if (isCompleteTube(segments)) {
                    if (segments[0] !== 'K') {
                        tube.style.boxShadow = `0 0 15px ${colorMeta(segments[0]).hex}`;
                        tube.style.borderColor = `rgba(255,255,255,0.5)`;
                    }
                }

                const water = document.createElement('div');
                water.className = 'water-container';

                segments.forEach(key => {
                    const c = colorMeta(key)?.hex || '#64748b';
                    const seg = document.createElement('div');
                    seg.className = 'water-segment';
                    seg.style.backgroundColor = c;
                    water.appendChild(seg);
                });

                tube.appendChild(water);
                tube.addEventListener('click', () => handleTubeClick(i));
                tubesContainer.appendChild(tube);
            });
            
            renderSkills();
            requestAnimationFrame(adjustBoardScale);
        }
        
        // ‰øÆÊ≠£: Ê®™„Çπ„ÇØ„É≠„Éº„É´ÂâçÊèê„ÅÆ„Çπ„Ç±„Éº„É´Ë™øÊï¥ÔºàÁ∏¶„ÅÆ„Åø„ÉÅ„Çß„ÉÉ„ÇØÔºâ
        function adjustBoardScale() {
            if (!boardArea || !tubesContainer) return;
            tubesContainer.style.transform = 'none';
            
            const availableH = boardArea.clientHeight;
            const contentH = tubesContainer.scrollHeight;
            
            // Á∏¶„Åå„ÅØ„ÅøÂá∫„ÇãÂ†¥Âêà„ÅÆ„ÅøÁ∏ÆÂ∞è„Åô„Çã
            const safeH = availableH * 0.95;
            let scale = 1;
            
            if (contentH > safeH) {
                scale = Math.max(0.6, safeH / contentH); // ÊúÄÂ∞è0.6ÂÄç„Åæ„Åß
                tubesContainer.style.transform = `scale(${scale})`;
            }
        }
        
        window.addEventListener('resize', () => {
            requestAnimationFrame(adjustBoardScale);
        });
        
        function renderSkills(){
            skillsContainer.innerHTML = '';
            // Inventory check
            Object.keys(gameState.inventory).forEach(key => {
                const count = gameState.inventory[key];
                if(count > 0 || ITEMS[key].type === 'tool'){
                    const def = ITEMS[key];
                    const btn = document.createElement('button');
                    btn.className = 'skill-btn w-12 h-12 glass-panel flex items-center justify-center text-xl rounded-full border border-white/10 shrink-0';
                    
                    const name = currentLang==='ja' ? def.name.ja : def.name.en;
                    const desc = currentLang==='ja' ? def.desc.ja : def.desc.en;

                    let badgeHtml = '';
                    if(def.type === 'consumable'){
                        badgeHtml = `<span class="absolute -top-1 -right-1 bg-sky-500 text-[10px] font-bold px-1.5 rounded-full text-white pointer-events-none">${count}</span>`;
                    }

                    btn.innerHTML = `
                        ${def.icon}
                        ${badgeHtml}
                        <div class="skill-tooltip">
                            <div class="font-bold text-sky-300 text-xs mb-1">${name}</div>
                            <div class="text-slate-300 text-[10px] leading-tight whitespace-pre-wrap">${desc}</div>
                        </div>
                    `;
                    
                    // Style states
                    if (key === 'pipette' && gameState.pipetteMode) btn.classList.add('active');
                    if (gameState.pendingSkill === key) btn.classList.add('pending');
                    if (gameState.targetMode === key) btn.classList.add('active-mode');
                    if (gameState.targetMode === 'extractor' && key === 'extractor') {
                        if(gameState.extractorHeldColor) {
                            btn.classList.add('extracting');
                            btn.innerHTML = `<div style="width:16px;height:16px;border-radius:50%;background:${colorMeta(gameState.extractorHeldColor).hex};border:2px solid white;"></div>` + badgeHtml;
                        } else {
                            btn.classList.add('active-mode');
                        }
                    }

                    btn.onclick = () => activateSkill(key);
                    skillsContainer.appendChild(btn);
                }
            });
        }

        function activateSkill(key){
            if(gameState.busy) return;
            const def = ITEMS[key];

            // 1. Pending Check
            const isPending = (gameState.pendingSkill === key);
            const isActive = (gameState.targetMode === key) || (key === 'pipette' && gameState.pipetteMode) || (key==='extractor' && gameState.targetMode==='extractor');

            if (!isPending && !isActive) {
                gameState.pendingSkill = key;
                gameState.targetMode = null;
                gameState.extractorHeldColor = null; 
                showToast(currentLang==='ja'?'„ÇÇ„ÅÜ‰∏ÄÂ∫¶„Çø„ÉÉ„Éó„Åó„Å¶‰ΩøÁî®':'Tap again to use', 'yellow');
                renderSkills();
                renderBoard(); 
                return;
            }

            gameState.pendingSkill = null; 
            
            // --- Instant Skills ---
            if(key === 'summon_vial'){
                 if(gameState.inventory[key] > 0){
                     gameState.inventory[key]--;
                     gameState.tubeCount++;
                     gameState.tubes.push([]);
                     saveGame();
                     renderBoard();
                     showFloatText(gameState.tubes.length-1, "Summoned!", "#a855f7");
                     showToast(currentLang==='ja'?'Á©∫„ÅçÁì∂„ÇíËøΩÂä†„Åó„Åæ„Åó„ÅüÔºÅ':'Extra Tube Added!', 'purple');
                 }
                 return;
            }
            if(key === 'sedative'){
                 if(gameState.inventory[key] > 0){
                     gameState.inventory[key]--;
                     gameState.pressure = 0;
                     saveGame();
                     renderHUD();
                     showToast("Sedated! Pressure 0.", 'purple');
                 }
                 return;
            }

            // --- Toggle / Target Skills ---
            if(def.type === 'tool' && key === 'pipette'){
                gameState.pipetteMode = !gameState.pipetteMode;
                gameState.targetMode = null; 
                gameState.selectedIdx = null; 
            } else if (def.type === 'consumable'){
                if (key === 'extractor') {
                     if (gameState.targetMode === 'extractor') {
                         if(gameState.extractorHeldColor){
                             showToast(currentLang==='ja'?'ÊäΩÂá∫‰∏≠„ÅÆ„Åü„ÇÅ„Ç≠„É£„É≥„Çª„É´‰∏çÂèØÔºÅ':'Cannot cancel while holding color!', 'red');
                             return; 
                         }
                         gameState.targetMode = null;
                     } else {
                         gameState.targetMode = 'extractor';
                         gameState.extractorHeldColor = null;
                         gameState.selectedIdx = null; 
                         gameState.pipetteMode = false;
                         showToast(currentLang==='ja' ? "ÊäΩÂá∫ÂÖÉ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ" : "Select source tube", 'emerald');
                     }
                } 
                else {
                    if(gameState.targetMode === key){
                        gameState.targetMode = null; 
                    } else {
                        gameState.targetMode = key;
                        gameState.selectedIdx = null; 
                        gameState.pipetteMode = false; 
                        showToast(currentLang==='ja' ? "ÂØæË±°„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ" : "Select a target tube", 'sky');
                    }
                }
            }
            renderSkills();
            renderBoard();
        }

        async function handleTubeClick(idx) {
            if (gameState.busy) return;
            
            if (gameState.targetMode === 'extractor') {
                await handleExtractorStep(idx);
                return;
            }

            if (gameState.targetMode) {
                await applySkillEffect(idx);
                return;
            }

            const content = gameState.tubes[idx];

            if (gameState.selectedIdx === idx) {
                gameState.selectedIdx = null;
                renderBoard();
                return;
            }

            if (gameState.selectedIdx === null) {
                if (content.length === 0) return;
                if (isCompleteTube(content)) return; 

                gameState.selectedIdx = idx;
                renderBoard();
            } else {
                await tryPour(gameState.selectedIdx, idx);
            }
        }
        
        async function handleExtractorStep(idx) {
            const tube = gameState.tubes[idx];
            
            if (!gameState.extractorHeldColor) {
                if (tube.length === 0) {
                    showFloatText(idx, "Empty!", "#ef4444");
                    return;
                }
                
                gameState.busy = true;
                const color = tube.pop();
                gameState.extractorHeldColor = color;
                
                showFloatText(idx, "Extracted!", "#22c55e");
                renderBoard(); 
                gameState.busy = false;
                
                showToast(currentLang==='ja' ? "ÁßªÂãïÂÖà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ" : "Select destination", 'emerald');
            } 
            else {
                if (tubeFree(tube) <= 0) {
                    showFloatText(idx, "Full!", "#ef4444");
                    return;
                }
                
                pushHistory();
                
                tube.push(gameState.extractorHeldColor);
                gameState.extractorHeldColor = null;
                
                if (gameState.inventory['extractor'] > 0) {
                    let consume = true;
                    if(hasPerk('recycler')){
                        const lv = getPerkLevel('recycler');
                        if(Math.random() < lv * 0.1){
                            consume = false;
                            showToast("Recycled! Item saved.", 'purple');
                        }
                    }
                    if(consume) gameState.inventory['extractor']--;
                }
                
                gameState.targetMode = null; 
                showFloatText(idx, "Injected!", "#22c55e");
                
                saveGame();
                renderHUD();
                renderBoard();
                
                if(isCompleteTube(tube)){
                    await handleCompletion(idx, tube[0]);
                }
            }
        }
        
        async function applySkillEffect(idx){
            const skillKey = gameState.targetMode;
            const tube = gameState.tubes[idx];
            
            if(!skillKey || !gameState.inventory[skillKey] || gameState.inventory[skillKey] <= 0) return;
            
            let success = false;
            let consume = true;

            if(hasPerk('recycler')){
                const lv = getPerkLevel('recycler');
                if(Math.random() < lv * 0.1){
                    consume = false;
                    showToast("Recycled! Item saved.", 'purple');
                }
            }
            
            try {
                gameState.busy = true;

                if(skillKey === 'inverter'){
                    if(tube.length < 2) showFloatText(idx, "Too Empty!", "#ef4444");
                    else {
                        pushHistory();
                        if(consume) gameState.inventory[skillKey]--;
                        tube.reverse(); 
                        showFloatText(idx, "Inverted!", "#a855f7");
                        success = true;
                    }
                } else if (skillKey === 'void_salt'){
                    if(tube.length === 0) showFloatText(idx, "Empty!", "#ef4444");
                    else {
                        if(tube[tube.length-1] !== 'K') showFloatText(idx, "Not Black!", "#ef4444");
                        else {
                            pushHistory();
                            if(consume) gameState.inventory[skillKey]--;
                            tube.pop();
                            showFloatText(idx, "Voided!", "#a855f7");
                            success = true;
                        }
                    }
                } else if (skillKey === 'separator'){
                    if(tube.length < 2) showFloatText(idx, "No need!", "#ef4444");
                    else {
                        pushHistory();
                        if(consume) gameState.inventory[skillKey]--;
                        const counts = {};
                        tube.forEach(c => counts[c] = (counts[c]||0)+1);
                        const newTube = [];
                        Object.keys(counts).sort().forEach(c => {
                             for(let i=0; i<counts[c]; i++) newTube.push(c);
                        });
                        gameState.tubes[idx] = newTube;
                        showFloatText(idx, "Separated!", "#a855f7");
                        success = true;
                    }
                } else if (skillKey === 'cycle_siphon'){
                     if(tube.length === 0) showFloatText(idx, "Empty!", "#ef4444");
                     else {
                        pushHistory();
                        if(consume) gameState.inventory[skillKey]--;
                        const bottom = tube.shift();
                        tube.push(bottom);
                        showFloatText(idx, "Cycled!", "#a855f7");
                        success = true;
                     }
                } else if (skillKey === 'sediment'){ 
                     if(tube.length < 2) showFloatText(idx, "No need!", "#ef4444");
                     else {
                        pushHistory();
                        if(consume) gameState.inventory[skillKey]--;
                        const top = tube.pop();
                        tube.unshift(top); 
                        showFloatText(idx, "Sunk!", "#a855f7");
                        success = true;
                     }
                } else if (skillKey === 'layer_swap'){ 
                    if(tube.length < 2) showFloatText(idx, "Need 2+", "#ef4444");
                    else {
                        pushHistory();
                        if(consume) gameState.inventory[skillKey]--;
                        const t1 = tube[tube.length-1];
                        const t2 = tube[tube.length-2];
                        tube[tube.length-1] = t2;
                        tube[tube.length-2] = t1;
                        showFloatText(idx, "Swapped!", "#a855f7");
                        success = true;
                    }
                } else if (skillKey === 'vacuum'){ 
                    if(tube.length === 0) showFloatText(idx, "Empty!", "#ef4444");
                    else if(tube[tube.length-1] !== 'K') showFloatText(idx, "Obsidian Only!", "#ef4444");
                    else {
                        pushHistory();
                        if(consume) gameState.inventory[skillKey]--;
                        while(tube.length > 0 && tube[tube.length-1] === 'K'){
                            tube.pop();
                        }
                        showFloatText(idx, "Vacuumed!", "#a855f7");
                        success = true;
                    }
                } else if (skillKey === 'midas'){ 
                    if(tube.length === 0) showFloatText(idx, "Empty!", "#ef4444");
                    else if(tube[tube.length-1] !== 'K') showFloatText(idx, "Obsidian Only!", "#ef4444");
                    else {
                        pushHistory();
                        if(consume) gameState.inventory[skillKey]--;
                        tube.pop(); 
                        gameState.essence += 2; 
                        showFloatText(idx, "Transmuted! (+2‚ú®)", "#fbbf24");
                        success = true;
                    }
                } else if (skillKey === 'shaker'){
                    if(tube.length < 2) showFloatText(idx, "No need!", "#ef4444");
                    else {
                        pushHistory();
                        if(consume) gameState.inventory[skillKey]--;
                        for (let i = tube.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [tube[i], tube[j]] = [tube[j], tube[i]];
                        }
                        showFloatText(idx, "Shaken!", "#a855f7");
                        success = true;
                    }
                } else if (skillKey === 'cursed_sludge'){ 
                    if(tube.length >= gameState.capacity) showFloatText(idx, "Full!", "#ef4444");
                    else {
                        pushHistory();
                        if(consume) gameState.inventory[skillKey]--;
                        tube.push('K');
                        showFloatText(idx, "Cursed!", "#0f172a");
                        success = true;
                    }
                }

            } finally {
                gameState.busy = false;
            }
            
            if(success){
                gameState.targetMode = null;
                renderHUD();
                renderBoard();
                
                saveGame();
                
                if(isCompleteTube(gameState.tubes[idx])){
                    await handleCompletion(idx, gameState.tubes[idx][0]);
                }
            }
        }

        function canPour(fromIdx, toIdx){
            if (fromIdx === toIdx) return {ok:false, reason:'same'};
            const from = gameState.tubes[fromIdx];
            const to = gameState.tubes[toIdx];
            if (!from.length) return {ok:false, reason:'empty'};
            if (tubeFree(to) <= 0) return {ok:false, reason:'full'};

            const top = tubeTop(from);
            const toTop = tubeTop(to);

            if (toTop && toTop !== top) return {ok:false, reason:'mismatch'};

            let count = 1;
            if(gameState.pipetteMode){
                count = 1;
            } else {
                for (let i=from.length-2;i>=0;i--){
                    if (from[i] === top) count++;
                    else break;
                }
            }
            
            const moveCount = Math.min(count, tubeFree(to));
            return {ok:true, color: top, moveCount};
        }

        function pushHistory(){
            gameState.history.push({
                tubes: deepCopy(gameState.tubes),
                turnCount: gameState.turnCount,
                pressure: gameState.pressure,
                hp: gameState.hp,
                secondaryProgress: gameState.secondaryProgress,
                catalystAvailable: gameState.catalystAvailable,
                essence: gameState.essence,
                inventory: {...gameState.inventory},
                tubeCount: gameState.tubeCount,
                momentumTurns: gameState.momentumTurns,
                refluxUses: gameState.refluxUses
            });
            if (gameState.history.length > 50) gameState.history.shift();
        }

        async function tryPour(fromIdx, toIdx){
            const check = canPour(fromIdx, toIdx);
            if (!check.ok){
                const content = gameState.tubes[toIdx];
                if (content.length > 0 && !isCompleteTube(content)) {
                    gameState.selectedIdx = toIdx;
                } else {
                    gameState.selectedIdx = null;
                }
                renderBoard();
                return;
            }

            try {
                pushHistory();
                gameState.busy = true;
                
                let pressureImmune = false;
                if(hasPerk('steady_hand')){
                    const lv = getPerkLevel('steady_hand');
                    if(gameState.turnCount < lv * 3) pressureImmune = true;
                }
                
                if(gameState.momentumTurns > 0){
                    gameState.momentumTurns--;
                    pressureImmune = true;
                    showFloatText(toIdx, "Momentum!", "#a855f7");
                } 
                
                if(!pressureImmune) {
                    gameState.pressure += 1;
                }
                
                gameState.turnCount += 1;

                await animatePour(fromIdx, toIdx, check.color, check.moveCount);

                const from = gameState.tubes[fromIdx];
                const to = gameState.tubes[toIdx];
                const moveCount = check.moveCount;

                for (let i=0;i<moveCount;i++){
                    to.push(from.pop());
                }
                
                // Auto Save after move
                saveGame();

                if(isCompleteTube(to)){
                    await handleCompletion(toIdx, to[0]);
                } else {
                    if (gameState.secondaryGoal?.type === 'combo') gameState.secondaryProgress = 0;
                }

                if (gameState.pressure >= gameState.pressureMax){
                    let prevented = false;
                    if(hasPerk('void_shield')){
                        const lv = getPerkLevel('void_shield');
                        if(Math.random() < lv * 0.15){
                            prevented = true;
                            showFloatText(0, "Void Shield!", "#a855f7");
                            gameState.pressure = 0; 
                        }
                    }

                    if(!prevented){
                        gameState.pressure = 0;
                        gameState.hp -= 1;
                        ui('game-container').classList.add('animate-shake');
                        setTimeout(()=>ui('game-container').classList.remove('animate-shake'), 500);
                        corruptRandomSegment();
                        saveGame(); // Save HP loss
                    }
                }
            } catch (e) {
                console.error("Game Logic Error:", e);
            } finally {
                gameState.selectedIdx = null;
                gameState.busy = false;
            }

            if (gameState.hp <= 0){
                clearSave(); // DELETE SAVE ON DEATH
                openPerkScreen(true);
                return;
            }

            if (checkLevelClear()){
                onLevelClear();
                return;
            }

            renderHUD();
            renderBoard();
        }

        async function handleCompletion(tubeIdx, colorKey){
            const tubeEl = tubeCenterEl(tubeIdx);
            
            if (colorKey === 'K') {
                showFloatText(tubeIdx, "Purged!", "#94a3b8");
                if(hasPerk('purification')){
                    const lv = getPerkLevel('purification');
                    gameState.pressure = Math.max(0, gameState.pressure - (2 + lv));
                    gameState.essence += (1 + lv);
                    showFloatText(tubeIdx, `Purified! (-${2+lv} P)`, "#38bdf8");
                }
                tubeEl.classList.add('evaporating');
                await new Promise(r => setTimeout(r, 600));
                gameState.tubes[tubeIdx] = []; 
                tubeEl.classList.remove('evaporating');
                renderBoard();
                if (checkLevelClear()){
                    onLevelClear();
                }
                return; 
            }

            if (hasPerk('catalyst') && gameState.catalystAvailable){
                const lv = getPerkLevel('catalyst');
                gameState.pressure = Math.max(0, gameState.pressure - (4 + lv));
                gameState.catalystAvailable = false;
                showFloatText(tubeIdx, `Catalyst! (-${4+lv} P)`);
            }
            if (hasPerk('efficiency')){
                const lv = getPerkLevel('efficiency');
                if(Math.random() < lv * 0.20){
                    gameState.essence += 1;
                    showFloatText(tubeIdx, "Efficiency! (+1‚ú®)", "#fbbf24");
                }
            }
            if(hasPerk('heavy_mastery') && gameState.capacity >= 5){
                 const lv = getPerkLevel('heavy_mastery');
                 gameState.pressure = Math.max(0, gameState.pressure - (2 + lv));
                 showFloatText(tubeIdx, `Heavy Bonus! (-${2+lv} P)`, "#a855f7");
            }
            if(hasPerk('momentum')){
                const lv = getPerkLevel('momentum');
                gameState.momentumTurns = lv; 
            }
            
            checkSecondaryGoalOnComplete();
            
            saveGame(); // Save progress before event
            await showCompletionEvent(colorKey);
        }

        function countCompletedTubes(){
            return gameState.tubes.filter(t => isCompleteTube(t) && t[0] !== 'K').length;
        }

        function corruptRandomSegment(){
            const candidates = [];
            for (let i=0;i<gameState.tubes.length;i++){
                const t = gameState.tubes[i];
                if (t.length < gameState.capacity && (t.length === 0 || t[t.length-1] !== 'K')) {
                    candidates.push(i);
                }
            }
            if (!candidates.length) return;

            const idx = pick(candidates);
            gameState.tubes[idx].push('K');
            showFloatText(idx, "CORRUPTED!", "#ef4444");
        }

        function showFloatText(tubeIdx, text, color="#38bdf8"){
            const el = ui('tubes-container').children[tubeIdx];
            if(!el) return;
            const rect = el.getBoundingClientRect();
            const float = document.createElement('div');
            float.textContent = text;
            float.style.position = 'fixed';
            float.style.left = rect.left + 'px';
            float.style.top = rect.top + 'px';
            float.style.color = color;
            float.style.fontWeight = 'bold';
            float.style.fontSize = '14px';
            float.style.pointerEvents = 'none';
            float.style.zIndex = 100;
            float.style.textShadow = '0 2px 4px rgba(0,0,0,0.8)';
            float.animate([
                { transform: 'translateY(0)', opacity: 1 },
                { transform: 'translateY(-30px)', opacity: 0 }
            ], { duration: 1000, easing: 'ease-out' });
            document.body.appendChild(float);
            setTimeout(()=>float.remove(), 1000);
        }

        function tubeCenterEl(idx){
            return ui('tubes-container').querySelector(`[data-idx="${idx}"]`);
        }

        function animatePour(fromIdx, toIdx, colorKey, count){
            return new Promise((resolve) => {
                const fromEl = tubeCenterEl(fromIdx);
                const toEl = tubeCenterEl(toIdx);
                if (!fromEl || !toEl){ resolve(); return; }
                
                const fromWater = fromEl.querySelector('.water-container');
                const toWater = toEl.querySelector('.water-container');
                
                const shrinkSegments = [];
                for(let i=0; i<count; i++){
                    if(fromWater.children.length > i){
                        shrinkSegments.push(fromWater.children[fromWater.children.length - 1 - i]);
                    }
                }
                
                const colorHex = colorMeta(colorKey)?.hex || '#64748b';
                const fr = fromEl.getBoundingClientRect();
                const tr = toEl.getBoundingClientRect();
                const isRight = tr.left > fr.left;
                
                fromEl.style.transition = 'transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1)';
                fromEl.style.transform = `translateY(-10px) rotate(${isRight ? 45 : -45}deg)`;
                fromEl.style.zIndex = 50; 
                
                setTimeout(() => {
                    shrinkSegments.forEach(seg => {
                        if(seg) {
                            seg.style.height = '0px';
                            seg.style.opacity = '0';
                            seg.style.borderTop = 'none'; 
                        }
                    });
                    
                    for(let i=0; i<count; i++){
                        const newSeg = document.createElement('div');
                        newSeg.className = 'water-segment';
                        newSeg.style.backgroundColor = colorHex;
                        newSeg.style.height = '0px';
                        newSeg.style.opacity = '0.5';
                        toWater.appendChild(newSeg);
                        void newSeg.offsetWidth;
                        newSeg.style.height = 'var(--segment-height)';
                        newSeg.style.opacity = '1';
                    }
                }, 50);

                setTimeout(() => {
                    fromEl.style.transform = '';
                    fromEl.style.zIndex = '';
                    resolve();
                }, 400); 
            });
        }

        // --- Event / Screens ---
        function showCompletionEvent(colorKey){
            return new Promise((resolve) => {
                const name = colorName(colorKey);
                const title = currentLang==='ja' ? `${name}„ÅÆÂÆâÂÆöÂåñ` : `${name} Stabilized`;
                const desc = currentLang==='ja'
                    ? `${name}„ÇíÂÆåÊàê„Åï„Åõ„Åü„ÄÇ\nÊ∑±Ê∑µ„ÅåÂèçÂøú„Åó„Å¶„ÅÑ„Çã„ÄÇ`
                    : `You completed ${name}.\nThe abyss reacts to your achievement.`;

                const choices = buildEventChoices(colorKey);
                ui('event-kicker').textContent = t('eventKicker');
                ui('event-title').textContent = title;
                ui('event-desc').textContent = desc;
                eventChoices.innerHTML = '';
                choices.forEach(ch => {
                    const card = document.createElement('div');
                    card.className = 'glass-panel perk-card p-4 cursor-pointer hover:bg-white/5 border-l-4 border-l-sky-500';
                    card.innerHTML = `
                        <div class="text-[10px] text-sky-300 uppercase tracking-[0.35em] mb-1">${ch.kicker}</div>
                        <div class="text-xl font-black text-white">${ch.title}</div>
                        <div class="text-slate-400 text-xs mt-2 leading-relaxed">${ch.desc}</div>
                    `;
                    card.onclick = () => {
                        ch.apply();
                        saveGame(); // Save event choice result
                        eventScreen.classList.add('hidden');
                        eventScreen.classList.remove('flex');
                        renderHUD();
                        renderBoard();
                        resolve();
                    };
                    eventChoices.appendChild(card);
                });
                eventScreen.classList.remove('hidden');
                eventScreen.classList.add('flex');
            });
        }

        function buildEventChoices(colorKey){
            if (colorKey === 'B'){ 
                return [
                    {
                        kicker: currentLang==='ja' ? 'ÊéíÂá∫' : 'Vent',
                        title: currentLang==='ja' ? 'ÂúßÂäõ -4' : 'Pressure -4',
                        desc: currentLang==='ja' ? 'ÂÆâÂÖ®„ÇíÁ¢∫‰øù„Åô„Çã' : 'Release built-up pressure.',
                        apply(){ gameState.pressure = Math.max(0, gameState.pressure-4); }
                    },
                    {
                        kicker: currentLang==='ja' ? 'Áü•Ë≠ò' : 'Insight',
                        title: currentLang==='ja' ? '„Ç®„ÉÉ„Çª„É≥„Çπ +4' : 'Essence +4',
                        desc: currentLang==='ja' ? '„É™„Çπ„ÇØ„ÇíÂèñ„Å£„Å¶ÂØå„ÇíÂæó„Çã' : 'Gain currency for the shop.',
                        apply(){ gameState.essence += 4; }
                    }
                ];
            }
            if (colorKey === 'R'){
                return [
                    {
                        kicker: currentLang==='ja' ? 'Ê¥ªÂäõ' : 'Vitality',
                        title: currentLang==='ja' ? 'HP +1 / ÂúßÂäõ +3' : 'HP +1 / Pressure +3',
                        desc: currentLang==='ja' ? 'ÂõûÂæ©„Åô„Çã„ÅåË≤†Ëç∑„Åå„Åã„Åã„Çã' : 'Heal yourself, but strain the system.',
                        apply(){ 
                            gameState.hp = Math.min(gameState.maxHp, gameState.hp + 1); // Cap check
                            gameState.pressure += 3; 
                        }
                    },
                    {
                        kicker: currentLang==='ja' ? 'Âπ≥Èùô' : 'Calm',
                        title: currentLang==='ja' ? 'ÂúßÂäõ -6' : 'Pressure -6',
                        desc: currentLang==='ja' ? 'ÂøÉ„ÇíËêΩ„Å°ÁùÄ„Åë„Çã' : 'Significantly reduce pressure.',
                        apply(){ gameState.pressure = Math.max(0, gameState.pressure-6); }
                    }
                ];
            }
            return [
                {
                    kicker: currentLang==='ja' ? 'ÊµÑÂåñ' : 'Purify',
                    title: currentLang==='ja' ? 'ÂúßÂäõ -2' : 'Pressure -2',
                    desc: currentLang==='ja' ? 'Â∞ë„ÅóËêΩ„Å°ÁùÄ„Åè' : 'Minor relief.',
                    apply(){ gameState.pressure = Math.max(0, gameState.pressure-2); }
                },
                {
                    kicker: currentLang==='ja' ? 'Ë≤™Ê¨≤' : 'Greed',
                    title: currentLang==='ja' ? '„Ç®„ÉÉ„Çª„É≥„Çπ +3 / ÂúßÂäõ +1' : 'Essence +3 / Pressure +1',
                    desc: currentLang==='ja' ? 'Â∞è„Åï„Å™‰ª£ÂÑü„ÅßÂØå„Çí' : 'Wealth at a cost.',
                    apply(){ gameState.essence += 3; gameState.pressure += 1; }
                }
            ];
        }

        function openPerkScreen(isDeath){
            perkScreen.classList.remove('hidden');

            ui('perk-title').textContent = isDeath ? t('gameOver') : t('victory');
            ui('perk-subtitle').textContent = isDeath ? t('gameOverSub') : t('victorySub');
            ui('perk-essence').textContent = `Essence: ${gameState.essence} ‚ú®`;

            perkCards.innerHTML = '';
            shopCards.innerHTML = '';
            
            if(isDeath){
                // --- „É™„Ç∂„É´„ÉàÁîªÈù¢„ÅÆÁîüÊàê ---
                perkCards.innerHTML = `
                    <div class="flex flex-col gap-4 h-full">
                        <div class="text-sm font-bold text-rose-400 uppercase tracking-widest border-b border-white/10 pb-2">
                            ${currentLang==='ja'?'Êé¢Á¥¢Ë®òÈå≤':'Exploration Log'}
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div class="glass-panel p-4 flex flex-col items-center justify-center bg-white/5">
                                <div class="text-[10px] text-slate-400 uppercase tracking-widest">FLOOR</div>
                                <div class="text-4xl font-black text-white">${gameState.floor}</div>
                            </div>
                            <div class="glass-panel p-4 flex flex-col items-center justify-center bg-white/5">
                                <div class="text-[10px] text-slate-400 uppercase tracking-widest">ESSENCE</div>
                                <div class="text-4xl font-black text-sky-300">${gameState.essence}</div>
                            </div>
                        </div>
                        
                        <div class="mt-auto">
                            <div class="text-[10px] text-slate-500 mb-2 uppercase tracking-widest">Result String</div>
                            <textarea id="share-text-area" class="w-full h-24 bg-black/50 border border-white/10 rounded p-2 text-[10px] text-slate-400 font-mono resize-none" readonly>${generateShareText()}</textarea>
                        </div>
                    </div>
                `;

                // Âè≥ÂÅ¥ÔºöÊâÄÊåÅ„Çπ„Ç≠„É´‰∏ÄË¶ß ÔºÜ „Ç¢„ÇØ„Ç∑„Éß„É≥
                const perkList = Object.entries(gameState.perks).map(([id, lv]) => {
                    const p = PERKS[id];
                    const name = currentLang==='ja' ? p.name.ja : p.name.en;
                    return `<div class="flex justify-between items-center py-2 border-b border-white/5">
                        <span class="text-sm font-bold text-slate-200">${name}</span>
                        <span class="text-xs font-bold text-sky-400">Lv.${lv}</span>
                    </div>`;
                }).join('');

                shopCards.parentElement.className = "flex-1 flex flex-col p-4 md:p-6 overflow-y-auto";
                shopCards.className = "flex flex-col gap-4 h-full";
                
                shopCards.innerHTML = `
                    <div class="flex-1 overflow-y-auto min-h-[120px]">
                        <div class="text-sm font-bold text-sky-400 uppercase tracking-widest border-b border-white/10 pb-2 mb-2">
                            ${currentLang==='ja'?'Áç≤Âæó„Åó„ÅüÂ§âÁï∞':'Acquired Mutations'}
                        </div>
                        ${perkList || `<div class="text-slate-500 text-xs italic py-4">${currentLang==='ja'?'Â§âÁï∞„Å™„Åó':'No mutations'}</div>`}
                    </div>
                    
                    <div class="grid grid-cols-2 gap-3 mt-4 shrink-0">
                        <button onclick="copyResult()" class="py-4 bg-indigo-600 rounded-xl font-black text-white uppercase tracking-widest hover:bg-indigo-500 shadow-lg shadow-indigo-900/40 transform transition hover:-translate-y-1">
                            ${currentLang==='ja'?'ÁµêÊûú„Çí„Ç≥„Éî„Éº':'Copy Result'}
                        </button>
                        <button onclick="startNewRun()" class="py-4 bg-rose-600 rounded-xl font-black text-white uppercase tracking-widest hover:bg-rose-500 shadow-lg shadow-rose-900/40 transform transition hover:-translate-y-1">
                            ${currentLang==='ja'?'„É™„Éà„É©„Ç§':'Try Again'}
                        </button>
                    </div>
                `;
                
                continueBtn.style.display = 'none';
                return;
            }

            continueBtn.style.display = 'block';
            continueBtn.textContent = t('continue');
            continueBtn.onclick = () => {
                perkScreen.classList.add('hidden');
                nextFloor();
            };

            // Reset classes for shop mode
            shopCards.parentElement.className = "flex-1 flex flex-col p-4 md:p-6 overflow-y-auto";
            shopCards.className = "grid grid-cols-2 md:grid-cols-2 lg:grid-cols-2 gap-3";

            if (!gameState.currentPerkChoices) {
                gameState.currentPerkChoices = rollPerkChoices();
            }
            if (!gameState.currentShopOffers) {
                gameState.currentShopOffers = generateShopOffers();
            }

            gameState.currentPerkChoices.forEach(p => perkCards.appendChild(buildPerkCard(p)));
            refreshRerollUI();
            gameState.currentShopOffers.forEach(item => shopCards.appendChild(buildShopCard(item)));
            updateShopButtons(); // Init button states
            
            saveGame(); // Save state at shop
        }

        function generateShareText(){
            const floor = gameState.floor;
            const ess = gameState.essence;
            const perks = Object.entries(gameState.perks).map(([id, lv]) => {
                const p = PERKS[id];
                const name = currentLang==='ja' ? p.name.ja : p.name.en;
                return `${name} Lv.${lv}`;
            }).join('\n');
            
            const title = "Abyssal Alchemy";
            const text = `${title}\nFloor: ${floor}\nEssence: ${ess}‚ú®\n\n[Mutations]\n${perks || '(None)'}\n\n#AbyssalAlchemy #WaterSortRogue`;
            return text;
        }

        function copyResult(){
            const textarea = document.getElementById('share-text-area');
            if(!textarea) return;
            textarea.select();
            document.execCommand('copy');
            showToast(currentLang==='ja'?'„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ':'Copied to clipboard!', 'emerald');
        }

        function generateShopOffers(){
            const candidates = [...SHOP_POOL];
            const offers = [];
            
            for(let i=0; i<4; i++){
                if(candidates.length === 0) break;
                
                let idx = randInt(candidates.length);
                let selected = candidates[idx];
                
                // If item is a tool and already owned, don't show it (remove and retry)
                if(selected.type === 'item' && selected.ref.type === 'tool' && gameState.inventory[selected.ref.id]){
                    candidates.splice(idx, 1);
                    i--; // retry
                    continue;
                }
                
                offers.push(selected);
                candidates.splice(idx, 1);
            }
            return offers;
        }
        
        function refreshRerollUI(){
            const btn = ui('reroll-btn');
            if((gameState.rerollCoupons||0) > 0){
                btn.textContent = `Reroll (Coupon: ${gameState.rerollCoupons})`;
                btn.classList.remove('hidden');
            } else {
                btn.textContent = `Reroll (-5‚ú®)`;
                btn.classList.toggle('hidden', gameState.essence < 5);
            }
        }

        function rollPerkChoices(){
            const all = Object.values(PERKS);
            const candidates = [...all];
            const picks = [];
            const safePool = [...candidates];
            while(picks.length < 3 && safePool.length > 0){
                const idx = randInt(safePool.length);
                picks.push(safePool[idx]);
                safePool.splice(idx, 1);
            }
            return picks;
        }

        function buildPerkCard(perk){
            const card = document.createElement('div');
            card.className = `perk-card glass-panel p-3 cursor-pointer rarity-${perk.rarity} relative hover:bg-white/5 transition-all`;
            
            const ownedLevel = gameState.perks[perk.id] || 0;
            const nextLevel = ownedLevel + 1;
            
            const name = currentLang==='ja' ? perk.name.ja : perk.name.en;
            const desc = getPerkDesc(perk.id, nextLevel); 
            
            const isUpgrade = ownedLevel > 0;
            const badgeText = isUpgrade ? `UPGRADE Lv.${nextLevel}` : 'NEW';
            const badgeClass = isUpgrade ? 'text-emerald-400' : 'text-sky-400';

            card.innerHTML = `
                <div class="flex justify-between items-start mb-1">
                    <span class="text-[9px] text-slate-400 uppercase tracking-widest">${perk.rarity}</span>
                    <span class="text-[9px] ${badgeClass} font-bold uppercase">${badgeText}</span>
                </div>
                <div class="text-sm font-black text-white leading-tight mb-1">${name} <span class="text-[10px] text-slate-500">Lv.${ownedLevel}‚Üí${nextLevel}</span></div>
                <div class="text-slate-400 text-[10px] leading-relaxed">${desc}</div>
                <div class="absolute bottom-2 right-2 text-white/10 text-xl font-bold">+</div>
            `;

            card.onclick = () => {
                acquirePerk(perk.id);
                Array.from(perkCards.children).forEach(c => {
                    c.style.pointerEvents = 'none';
                    c.style.opacity = '0.4';
                    c.classList.remove('border-sky-500');
                });
                card.style.opacity = '1';
                card.style.borderColor = '#38bdf8';
                card.classList.add('bg-sky-500/10');
            };
            return card;
        }

        function getDiscountedCost(baseCost) {
            if(hasPerk('bargain')){
                const lv = getPerkLevel('bargain');
                const discount = 15 + (lv * 5); 
                return Math.floor(baseCost * (1 - discount/100));
            }
            return baseCost;
        }

        function buildShopCard(item){
            const card = document.createElement('div');
            card.className = 'glass-panel p-3 flex flex-col justify-between relative group hover:border-white/20 transition-all shop-card';
            
            const def = item.type==='item' ? item.ref : item;
            
            const name = currentLang==='ja' ? def.name.ja : def.name.en;
            const desc = currentLang==='ja' ? def.desc.ja : def.desc.en;
            const baseCost = item.cost || def.cost;
            const cost = getDiscountedCost(baseCost);
            
            // Store cost for dynamic checking
            card.dataset.cost = cost;

            let ownedText = '';
            if(item.type==='item' && def.type==='consumable'){
                 const count = gameState.inventory[def.id] || 0;
                 if(count > 0) ownedText = `x${count}`;
            } else if (item.type==='item' && def.type==='tool'){
                if(gameState.inventory[def.id]) ownedText = 'OWNED';
            }

            card.innerHTML = `
                <div>
                    <div class="flex items-start justify-between mb-1">
                        <div class="text-xs font-black text-white truncate pr-1">${name}</div>
                        <div class="text-sky-300 text-[10px] font-bold whitespace-nowrap">${cost}‚ú®</div>
                    </div>
                    <div class="text-slate-500 text-[9px] leading-tight h-8 overflow-hidden">${desc}</div>
                </div>
                <button class="mt-2 w-full py-1.5 bg-white/5 rounded font-bold text-[10px] uppercase tracking-widest transition-all shop-btn flex items-center justify-center gap-1">
                    <span>BUY</span>
                    ${ownedText ? `<span class="bg-black/40 px-1 rounded text-white/70">${ownedText}</span>` : ''}
                </button>
            `;
            
            const btn = card.querySelector('.shop-btn');
            
            // If already bought tool, disable permanently
            if(item.type === 'item' && def.type==='tool' && gameState.inventory[def.id]){
                 btn.innerHTML = `<span>BOUGHT</span>`;
                 btn.classList.add('opacity-50', 'cursor-not-allowed');
                 btn.disabled = true;
            } else {
                btn.onclick = () => {
                    if (gameState.essence < cost) {
                        showToast(currentLang==='ja'?'„Ç®„ÉÉ„Çª„É≥„Çπ„ÅåË∂≥„Çä„Åæ„Åõ„ÇìÔºÅ':'Not enough Essence!', 'rose');
                        return;
                    }
                    
                    if(item.type === 'item' && def.type==='tool' && gameState.inventory[def.id]){
                        return; 
                    }
                
                    gameState.essence -= cost;
                    
                    if(item.type === 'item'){
                        const id = def.id;
                        if(!gameState.inventory[id]) gameState.inventory[id] = 0;
                        if(def.type === 'tool') gameState.inventory[id] = 1;
                        else gameState.inventory[id]++;
                        
                        showToast(currentLang==='ja'?`${name}„ÇíË≥ºÂÖ•ÔºÅ`:`Bought ${name}!`, 'sky');
                    } else {
                        item.apply(gameState);
                    }
                    
                    ui('perk-essence').textContent = `Essence: ${gameState.essence} ‚ú®`;
                    
                    // Mark tool as bought
                    if(item.type === 'item' && def.type==='tool'){
                         btn.innerHTML = `<span>BOUGHT</span>`;
                         btn.classList.add('opacity-50', 'cursor-not-allowed');
                         btn.onclick = null;
                         btn.disabled = true;
                    }
                    
                    // Update owned counts for consumables
                    if(item.type === 'item' && def.type==='consumable'){
                        const count = gameState.inventory[def.id];
                        btn.innerHTML = `<span>BUY</span> <span class="bg-black/40 px-1 rounded text-white/70">x${count}</span>`;
                    }
                    
                    saveGame(); // Save after purchase
                    refreshRerollUI();
                    updateShopButtons(); // Refresh ALL buttons based on new essence
                };
            }
            return card;
        }

        // New function to update all shop buttons state
        function updateShopButtons() {
            const cards = document.querySelectorAll('.shop-card');
            cards.forEach(card => {
                const cost = parseInt(card.dataset.cost);
                const btn = card.querySelector('.shop-btn');
                
                if(btn.disabled && btn.textContent.includes('BOUGHT')) return; // Already bought tool

                if(gameState.essence >= cost) {
                    btn.classList.remove('opacity-30', 'cursor-not-allowed');
                    btn.classList.add('hover:bg-sky-500', 'hover:text-white');
                    btn.style.pointerEvents = 'auto';
                } else {
                    btn.classList.add('opacity-30', 'cursor-not-allowed');
                    btn.classList.remove('hover:bg-sky-500', 'hover:text-white');
                }
            });
        }

        function acquirePerk(id){
            if(!gameState.perks[id]) gameState.perks[id] = 0;
            gameState.perks[id]++;
            if(id === 'overflow') {
                gameState.pressureMax += 4;
                renderHUD(); 
            }
            renderHUD();
            saveGame(); // Save Perk acquisition
        }

        // --- Core Loop ---
        function startNewRun(){
            clearSave(); // CLEAR OLD SAVE
            startScreen.classList.add('hidden');
            gameState.floor = 1;
            gameState.essence = 0;
            gameState.hp = 3;
            gameState.maxHp = 3;
            gameState.perks = {};
            gameState.pressure = 0;
            gameState.pressureMax = 14;
            gameState.history = [];
            gameState.inventory = {}; 
            gameState.catalystAvailable = true;
            gameState.refluxUses = 0;
            gameState.momentumTurns = 0;
            gameState.currentPerkChoices = null; 
            gameState.currentShopOffers = null; 
            gameState.pipetteMode = false;
            gameState.targetMode = null;
            gameState.pendingSkill = null;
            gameState.extractorHeldColor = null;
            gameState.rerollCoupons = 0;
            
            perkScreen.classList.add('hidden'); 
            nextFloor(true);
        }

        function nextFloor(isFirst=false){
            if(!isFirst) gameState.floor += 1;
            if (gameState.floor >= 8) gameState.capacity = 6;
            else if (gameState.floor >= 4) gameState.capacity = 5;
            else gameState.capacity = 4;
            
            if(!isFirst && hasPerk('scavenger')){
                const lv = getPerkLevel('scavenger');
                if(Math.random() < (0.10 + lv * 0.05)){
                    const itemKeys = Object.keys(ITEMS);
                    const gift = pick(itemKeys);
                    if(!gameState.inventory[gift]) gameState.inventory[gift] = 0;
                    gameState.inventory[gift]++;
                    showToast("Scavenger found: " + ITEMS[gift].name[currentLang==='ja'?'ja':'en'], 'emerald');
                }
            }
            if(!isFirst && hasPerk('transmutation')){
                const lv = getPerkLevel('transmutation');
                for(let i=0; i<lv; i++){
                    const itemKeys = Object.keys(ITEMS);
                    const gift = pick(itemKeys);
                    if(!gameState.inventory[gift]) gameState.inventory[gift] = 0;
                    gameState.inventory[gift]++;
                }
                showToast(`Transmutation: +${lv} Item(s)`, 'purple');
            }
            if(hasPerk('deep_adapt')){
                const lv = getPerkLevel('deep_adapt');
                if(gameState.capacity > 4){
                    gameState.maxHp += lv;
                    gameState.hp += lv; 
                }
            }
            if(hasPerk('coupon')){
                const lv = getPerkLevel('coupon');
                gameState.rerollCoupons = (gameState.rerollCoupons || 0) + lv;
                showToast(`Coupon: +${lv}`, "yellow");
            }

            gameState.movesPerFloor = 0; 
            gameState.turnCount = 0;
            gameState.pressure = 0; 
            gameState.catalystAvailable = true;
            gameState.momentumTurns = 0;
            gameState.refluxUses = getPerkLevel('reflux');

            generateBoard();
            generateGoals();
            
            gameState.currentPerkChoices = null;
            gameState.currentShopOffers = null;
            gameState.selectedIdx = null;
            gameState.busy = false;
            gameState.targetMode = null;
            gameState.pipetteMode = false;
            gameState.pendingSkill = null;
            gameState.extractorHeldColor = null;
            
            renderHUD();
            renderBoard();
            
            saveGame(); // SAVE ON NEW FLOOR
        }

        function tryUndo(){
            if (!gameState.history.length) return;
            
            let cost = 5; 
            let isFree = false;
            
            if(gameState.refluxUses > 0){
                isFree = true;
            } else if (gameState.essence < cost){
                ui('ui-essence').classList.add('text-red-500');
                setTimeout(()=>ui('ui-essence').classList.remove('text-red-500'), 500);
                return;
            }

            const prev = gameState.history.pop();
            gameState.tubes = deepCopy(prev.tubes); // Fix: Ensure deep copy on undo
            gameState.turnCount = prev.turnCount;
            gameState.pressure = prev.pressure;
            gameState.hp = prev.hp;
            gameState.secondaryProgress = prev.secondaryProgress;
            gameState.catalystAvailable = prev.catalystAvailable;
            gameState.essence = prev.essence;
            gameState.inventory = {...prev.inventory}; // Fix: Restore inventory
            gameState.tubeCount = prev.tubeCount;
            gameState.capacity = prev.capacity || 4; 
            gameState.momentumTurns = prev.momentumTurns;
            gameState.refluxUses = prev.refluxUses;
            
            gameState.targetMode = null;
            gameState.pendingSkill = null;
            gameState.extractorHeldColor = null;
            
            if(isFree){
                gameState.pressure += 2;
                gameState.refluxUses--;
                showFloatText(0, "Reflux Used (+2 P)", "#a855f7");
            } else {
                gameState.essence -= cost;
            }

            gameState.selectedIdx = null;
            updateTubeLayout();
            renderHUD();
            renderBoard();
            
            saveGame(); // Save state after Undo
        }

        // --- HUD ---
        function renderHUD(){
            setText('ui-floor', `${t('floor')} ${gameState.floor}`);
            setText('ui-essence', `${gameState.essence} ‚ú®`);
            setText('ui-hp', `HP ${gameState.hp}`);
            
            setText('ui-floor-mobile', `${gameState.floor}F`);
            setText('ui-essence-mobile', `${gameState.essence} ‚ú®`);
            const totalLevels = Object.values(gameState.perks).reduce((a,b)=>a+b, 0);
            setText('ui-perks-mobile', `üß¨ ${totalLevels}`);
            setText('ui-hp-mobile', `HP ${gameState.hp}`);

            setText('ui-turn', `${t('turn')} ${gameState.turnCount}`);
            setText('ui-perks', `${t('perks')} ${totalLevels}`);

            setText('ui-goal', gameState.primaryGoal?.text ?? '‚Äî');
            setText('ui-goal-sub', gameState.secondaryGoal?.text ?? '‚Äî');
            
            setText('ui-secondary', `${t('secondary')} ${secondarySucceeded() ? 'COMPLETE' : '‚Äî'}`);
            
            const secondaryEl = ui('ui-secondary');
            if (secondaryEl) {
                secondaryEl.className = secondarySucceeded() 
                    ? "px-4 py-2 rounded-xl glass-panel text-sm font-black tracking-tight uppercase bg-emerald-500/20 text-emerald-300 border border-emerald-500/50"
                    : "px-4 py-2 rounded-xl glass-panel text-sm font-black tracking-tight uppercase bg-black/20 text-white border border-white/5";
            }

            setText('ui-pressure', String(gameState.pressure));
            const pct = Math.round((gameState.pressure / gameState.pressureMax) * 100);
            
            const pBar = ui('ui-pressure-bar');
            if(pBar) {
                pBar.style.width = `${clamp(pct,0,100)}%`;
                 if(gameState.pressure >= gameState.pressureMax - 3){
                    pBar.classList.remove('from-sky-400', 'via-purple-400');
                    pBar.classList.add('bg-rose-600');
                } else {
                    pBar.classList.add('from-sky-400', 'via-purple-400');
                    pBar.classList.remove('bg-rose-600');
                }
            }
            setText('ui-pressure-sub', `${gameState.pressure} / ${gameState.pressureMax}`);
           
            const undoCost = gameState.refluxUses > 0 ? 'FREE' : '5‚ú®';
            if (undoBtn) {
                undoBtn.innerHTML = `<span>‚Ü∫</span> UNDO (${undoCost})`;
                if(gameState.refluxUses <= 0 && gameState.essence < 5 && gameState.history.length > 0){
                    undoBtn.style.opacity = '0.5';
                    undoBtn.style.cursor = 'not-allowed';
                } else if (gameState.history.length === 0){
                    undoBtn.style.opacity = '0.3';
                    undoBtn.style.cursor = 'default';
                } else {
                    undoBtn.style.opacity = '1';
                    undoBtn.style.cursor = 'pointer';
                }
            }
            renderSkills();
        }

        function moveFocus(dx){
            if(!gameState.tubes.length) return;
            const n = gameState.tubeCount;
            if (gameState.focusIdx === null) {
                gameState.focusIdx = 0;
            } else {
                gameState.focusIdx = (gameState.focusIdx + dx + n) % n;
            }
            renderBoard();
        }
        
        // Start Screen Buttons logic
        function updateStartScreenButtons() {
            if (hasSaveData()) {
                continueRunBtn.classList.remove('hidden');
            } else {
                continueRunBtn.classList.add('hidden');
            }
        }

        ui('btn-help').onclick = () => ui('help-screen').classList.replace('hidden', 'flex');
        ui('help-close').onclick = () => ui('help-screen').classList.replace('flex', 'hidden');
        if(undoBtn) undoBtn.onclick = () => tryUndo();
        
        ui('reroll-btn').onclick = () => {
            if((gameState.rerollCoupons||0) > 0){
                gameState.rerollCoupons--;
                showToast(currentLang==='ja'?'„ÇØ„Éº„Éù„É≥„Çí‰ΩøÁî®ÔºÅ':'Coupon used!', 'emerald');
            } else if(gameState.essence >= 5){
                gameState.essence -= 5;
            } else {
                return;
            }

            gameState.currentPerkChoices = null;
            gameState.currentShopOffers = null;

            openPerkScreen(false);
            ui('perk-essence').textContent = `Essence: ${gameState.essence} ‚ú®`;
            refreshRerollUI();
            saveGame(); // Save Reroll cost
        };
        
        ui('start-run-btn').onclick = startNewRun;
        ui('continue-run-btn').onclick = () => {
            startScreen.classList.add('hidden');
            loadGame();
        };

        window.onkeydown = (e) => {
            if(!perkScreen.classList.contains('hidden')) return;
            if(!eventScreen.classList.contains('hidden')) return;
            if(!helpScreen.classList.contains('hidden')) return;

            if (e.key === 'ArrowLeft') moveFocus(-1);
            if (e.key === 'ArrowRight') moveFocus(1);
            
            if (e.key === 'Enter' || e.key === ' ') {
                 if(gameState.focusIdx !== null) handleTubeClick(gameState.focusIdx);
            }
            if (e.key === 'Backspace' || e.key === 'z') tryUndo();
        };

        // Init
        applyLang();
        updateStartScreenButtons();
        
    </script>
</body>
</html>