<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Abyss Alchemy - Water Sort Rogue</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg-color: #020617;
            --tube-border: #334155;
            --tube-bg: rgba(15, 23, 42, 0.4);
            --pour-speed: 0.3s;
            --segment-height: 40px;
            --tube-height: 220px;
            --primary-glow: #38bdf8;
            --rarity-common: #94a3b8;
            --rarity-rare: #3b82f6;
            --rarity-epic: #a855f7;
            --safe-area-bottom: env(safe-area-inset-bottom, 20px);
        }
        .mb-safe {
            margin-bottom: var(--safe-area-bottom);
        }
        .pb-safe {
            padding-bottom: var(--safe-area-bottom);
        }
        body {
            background: radial-gradient(circle at 50% 0%, #0f172a 0%, #020617 100%);
            color: white;
            font-family: 'Inter', system-ui, sans-serif;
            touch-action: manipulation;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            margin: 0;
            user-select: none;
            -webkit-user-select: none;
        }
        .glass-panel {
            background: rgba(15, 23, 42, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(12px);
            border-radius: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .tube {
            width: clamp(40px, 10vw, 56px);
            height: var(--tube-height);
            border: 3px solid var(--tube-border);
            border-top: 2px solid rgba(255,255,255,0.15);
            border-bottom-left-radius: 28px;
            border-bottom-right-radius: 28px;
            position: relative;
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1), box-shadow 0.3s ease, border-color 0.3s ease;
            background: var(--tube-bg);
            margin: 3px;
            z-index: 10; 
            cursor: pointer;
            overflow: visible;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            box-shadow: inset 2px 0 4px rgba(255,255,255,0.05), inset -2px 0 4px rgba(0,0,0,0.2);
            flex-shrink: 0;
            pointer-events: auto; 
        }
        .tube.is-clone {
            z-index: 5;
        }
        .tube.selected, 
        .tube.target-mode {
            z-index: 50 !important; 
        }
        .tube.selected {
            transform: translateY(-15px) scale(1.05);
            border-color: var(--primary-glow);
            box-shadow: 0 0 25px rgba(56, 189, 248, 0.25);
        }
        .water-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            flex-direction: column-reverse;
            padding: 0;
            gap: 0;
            pointer-events: none; 
            width: 100%;
            overflow: hidden;
            border-bottom-left-radius: 25px; 
            border-bottom-right-radius: 25px;
        }
        .tube.target-mode {
            border-color: #a855f7;
            box-shadow: 0 0 20px rgba(168, 85, 247, 0.4);
            animation: pulse-purple 1.5s infinite;
        }
        .tube.source-mode {
            border-color: #fbbf24;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.4);
            animation: pulse-yellow 1.5s infinite;
        }
        @keyframes pulse-purple {
            0%, 100% { box-shadow: 0 0 20px rgba(168, 85, 247, 0.4); }
            50% { box-shadow: 0 0 30px rgba(168, 85, 247, 0.7); }
        }
        @keyframes pulse-yellow {
            0%, 100% { box-shadow: 0 0 20px rgba(251, 191, 36, 0.4); }
            50% { box-shadow: 0 0 30px rgba(251, 191, 36, 0.7); }
        }
        .tube-focused {
            border-color: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 0 4px rgba(255,255,255,0.3);
        }
        .deadlock-glow {
            box-shadow: 0 0 0 4px rgba(244, 63, 94, 0.5) !important;
            border-color: rgba(244, 63, 94, 0.8) !important;
        }
        .water-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            flex-direction: column-reverse;
            padding: 0;
            gap: 0;
            pointer-events: none;
            width: 100%;
            overflow: hidden;
            border-bottom-left-radius: 25px; 
            border-bottom-right-radius: 25px;
        }
        .water-segment {
            width: 100%;
            height: var(--segment-height);
            position: relative;
            transition: height 0.3s ease, opacity 0.3s ease;
        }
        .water-segment::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, 
                rgba(255,255,255,1) 0%,
                rgba(255,255,255,0.1) 20%,
                rgba(255,255,255,0) 25%,
                        rgba(0,0,0,0.5) 50%,
                        rgba(255,255,255,0) 75%,
                rgba(255,255,255,0.1) 90%,
                rgba(255,255,255,0.6) 100%
            );
            opacity: 0.8;
            mix-blend-mode: overlay;
        }
        .water-segment:last-child {
            border-top: 1px solid rgba(255,255,255,0.3);
        }
        .water-segment:last-child::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(255,255,255,0.4);
            filter: blur(2px);
            border-radius: 50%;
            transform: scaleX(0.9);
        }
        @keyframes evaporate {
            0% { 
                transform: scale(1); 
                opacity: 1; 
                filter: brightness(1) blur(0px); 
            }
            50% { 
                filter: brightness(2) blur(2px); 
                background-color: white !important;
            }
            100% { 
                transform: scale(1.5) translateY(-20px); 
                opacity: 0; 
                filter: brightness(3) blur(10px);
            }
        }
        .evaporating .water-segment {
            animation: evaporate 0.8s cubic-bezier(0.4, 0, 0.2, 1) forwards !important;
            pointer-events: none;
        }
        .lang-btn{
            padding: 6px 10px;
            font-weight: 800;
            font-size: 12px;
            border-radius: 12px;
            opacity: 0.55;
            transition: all .2s;
        }
        .lang-btn.active{ opacity: 1; background: rgba(56,189,248,0.15); border: 1px solid rgba(56,189,248,0.35); }
        .perk-card {
            transition: all 0.25s ease;
            border: 1px solid rgba(255,255,255,0.06);
            position: relative;
            overflow: hidden;
        }
        .perk-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            border-color: rgba(56,189,248,0.35);
        }
        .rarity-common{ border-left: 8px solid var(--rarity-common); }
        .rarity-rare{ border-left: 8px solid var(--rarity-rare); }
        .rarity-epic{ border-left: 8px solid var(--rarity-epic); }
        .skill-btn {
            position: relative;
            transition: all 0.2s;
            filter: grayscale(0.8);
            opacity: 0.7;
        }
        .skill-btn:not(:disabled):hover {
            filter: grayscale(0);
            opacity: 1;
            transform: translateY(-2px);
            z-index: 50;
        }
        .skill-btn.pending {
            filter: grayscale(0);
            opacity: 1;
            border-color: #fbbf24;
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.4);
            background: rgba(251, 191, 36, 0.1);
            animation: pulse-btn 1s infinite;
        }
        .skill-btn.active-mode {
            filter: grayscale(0);
            opacity: 1;
            border-color: #a855f7;
            box-shadow: 0 0 15px rgba(168, 85, 247, 0.4);
            background: rgba(168, 85, 247, 0.2);
        }
        .skill-btn.extracting {
            border-color: #22c55e;
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.4);
            background: rgba(34, 197, 94, 0.2);
            animation: pulse-btn 1.5s infinite;
        }
        .skill-btn.active {
            filter: grayscale(0);
            opacity: 1;
            border-color: var(--primary-glow);
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.4);
            background: rgba(56, 189, 248, 0.2);
        }
        @keyframes pulse-btn {
            0% { box-shadow: 0 0 5px currentColor; }
            50% { box-shadow: 0 0 15px currentColor; }
            100% { box-shadow: 0 0 5px currentColor; }
        }
        #global-tooltip {
            position: fixed;
            background: rgba(2, 6, 23, 0.98);
            border: 1px solid rgba(56, 189, 248, 0.3);
            padding: 8px 12px;
            border-radius: 8px;
            pointer-events: none;
            width: max-content;
            max-width: 220px;
            text-align: center;
            box-shadow: 0 4px 25px rgba(0,0,0,0.8);
            backdrop-filter: blur(8px);
            z-index: 0;
            opacity: 0;
            transition: opacity 0.15s ease;
            transform: translateX(-50%);
        }
        #global-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -6px;
            border-width: 6px;
            border-style: solid;
            border-color: rgba(56, 189, 248, 0.3) transparent transparent transparent;
        }
        #btn-undo {
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
            transition: all 0.2s;
        }
        #btn-undo:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.3);
        }
        #btn-undo:active {
            transform: scale(0.95);
        }
        #alert-banner {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(244, 63, 94, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 14px;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #toast-container {
            pointer-events: none;
        }
        .toast-msg {
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(56, 189, 248, 0.3);
            color: white;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            animation: toast-in 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(4px);
        }
        .toast-msg.fade-out {
            animation: toast-out 0.3s forwards;
        }
        @keyframes toast-in {
            from { opacity: 0; transform: translateY(-20px) scale(0.9); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        @keyframes toast-out {
            to { opacity: 0; transform: translateY(-10px); }
        }
        .floating{
            animation: floaty 3.2s ease-in-out infinite;
        }
        @keyframes floaty{
            0%,100%{ transform: translateY(0); }
            50%{ transform: translateY(-10px); }
        }
        #board-scroll-area {
            width: 100%;
            height: 100%;
            overflow-x: scroll;
            overflow-y: hidden;
            display: flex;
            align-items: center; 
            scrollbar-width: none;
            -ms-overflow-style: none;
            cursor: grab;
            mask-image: linear-gradient(to right, transparent 0%, black 20%, black 80%, transparent 100%);
                scroll-behavior: auto !important; 
            overscroll-behavior-x: none;
        }
        #board-scroll-area:active {
            cursor: grabbing;
        }
        #board-scroll-area::-webkit-scrollbar {
            display: none;
        }
        #tubes-container {
            display: flex;
            flex-wrap: nowrap;
            gap: 6px;
            padding: 2px 10px;
            width: max-content; 
            margin: auto; 
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            transform-origin: left center;
        }
        #skills-container {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 0.75rem;
            overflow-x: auto; 
            padding: 0.5rem 1rem; 
            -webkit-mask-image: none;
            mask-image: none;
            position: relative;
            z-index: 30;
            cursor: grab;
            scrollbar-width: auto; 
        }
        #skills-container:active {
            cursor: grabbing;
        }
        #skills-container::-webkit-scrollbar {
            display: block;
            height: 6px;
        }
        #skills-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        #skills-container::-webkit-scrollbar-thumb {
            background: rgba(56, 189, 248, 0.3);
            border-radius: 10px;
        }
        #dev-tests {
            display: none;
        }
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 8px;
        }
        .stat-item {
            padding: 8px;
            border-radius: 8px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.05);
            display: flex;
            flex-direction: column;
        }
        .tube-cap {
            position: absolute;
            top: -10px; 
            left: 50%;
            transform: translate(-50%, -60px); 
            width: 100%;
            height: 25px;
            border: 2px solid #10213b;
            border-radius: 6px 6px 6px 6px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.4);
            z-index: 25;
            opacity: 0;
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s;
            pointer-events: none;
        }
        .tube.capped .tube-cap {
            transform: translate(-50%, 0); 
            opacity: 1;
            background: linear-gradient(90deg, 
                rgba(255,255,255,1) 0%,
                rgba(255,255,255,0.1) 20%,
                rgba(255,255,255,0) 25%,
                        rgba(0,0,0,0.5) 50%,
                        rgba(255,255,255,0) 75%,
                rgba(255,255,255,0.1) 90%,
                rgba(255,255,255,0.6) 100%
            );
        }
        ::-webkit-scrollbar {
            width: 8px;  
            height: 8px; 
        }
        ::-webkit-scrollbar-track {
            background: rgba(2, 6, 23, 0.3); 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(56, 189, 248, 0.2); 
            border: 1px solid rgba(56, 189, 248, 0.3); 
            border-radius: 4px;
            backdrop-filter: blur(4px);
        }
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(56, 189, 248, 0.5); 
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.3); 
        }
        ::-webkit-scrollbar-corner {
            background: transparent;
        }
        @keyframes pulse-void {
            0% { 
                box-shadow: 
                    inset 12px 0 12px -8px #27044a, 
                    inset -12px 0 12px -8px #27044a;
                filter: brightness(1); 
            }
            50% { 
                box-shadow: 
                    inset 20px 0 18px -10px #681d7f, 
                    inset -20px 0 18px -10px #681d7f;
                filter: brightness(1.15); 
            }
            100% { 
                box-shadow: 
                    inset 12px 0 12px -8px #27044a, 
                    inset -12px 0 12px -8px #27044a;
                filter: brightness(1); 
            }
        }
        .water-segment.void-ink {
            background: radial-gradient(circle at 50% 50%, #1e1b4b 0%, #020617 80%, #000000 100%) !important;
            animation: pulse-void 2s infinite linear; 
            position: relative;
            overflow: hidden;
            backface-visibility: hidden;
            border: none;
        }
        .help-bubble {
            position: fixed;
            background: rgba(2, 6, 23, 0.98);
            border: 1px solid rgba(56, 189, 248, 0.3);
            color: white;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            line-height: 1.5;
            text-align: center;
            box-shadow: 0 4px 25px rgba(0,0,0,0.8);
            z-index: 9999;
            pointer-events: none;
            width: max-content;
            max-width: 220px;
            opacity: 0;
            transform: translateX(-50%) translateY(10px);
            transition: opacity 0.2s, transform 0.2s;
        }
        .help-bubble.show {
            opacity: 1; transform: translateX(-50%) translateY(0);
        }
        .help-bubble::after {
            content: ''; position: absolute; left: 50%; margin-left: -6px; border-width: 6px; border-style: solid;
        }
        .bubble-top::after {
            top: 100%; border-color: rgba(56, 189, 248, 0.3) transparent transparent transparent;
        }
        .bubble-bottom::after {
            bottom: 100%; border-color: transparent transparent rgba(56, 189, 248, 0.3) transparent;
        }
        .bubble-left::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 100%;
            margin-top: -6px;
            border-width: 6px;
            border-style: solid;
            border-color: transparent transparent transparent rgba(56, 189, 248, 0.3);
        }
        #help-overlay {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.25); z-index: 9000; display: none;
        }
        .help-bubble.center-fixed {
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) scale(1.1) !important;
            max-width: 280px;
            border-color: rgba(56, 189, 248, 0.6);
            box-shadow: 0 0 40px rgba(0,0,0,0.9);
        }
        .help-bubble.center-fixed::after {
            display: none;
        }
        .bubble-top::after { top: 100%; }
        .bubble-bottom::after { bottom: 100%; transform: rotate(180deg) translateX(50%); }
        * {
            scrollbar-width: thin;
            scrollbar-color: rgba(56, 189, 248, 0.3) rgba(2, 6, 23, 0.3);
        }
    </style>
</head>
<body>
    <div id="help-overlay"></div>
    <div>
        <div id="toast-container" class="fixed top-20 left-1/2 -translate-x-1/2 z-[200] flex flex-col gap-2 w-full max-w-sm px-4"></div>
        <div id="global-tooltip"></div>
        <div id="game-container" class="flex flex-col items-center justify-between h-screen w-screen p-2 md:p-4 overflow-hidden relative">
            <div id="alert-banner">NO MOVES LEFT</div>
            <div id="top-hud" class="w-full max-w-5xl glass-panel p-3 md:p-4 flex items-center justify-between z-[150] shrink-0 mb-2">
                <div class="flex items-center gap-4">
                    <div>
                        <div class="text-[10px] text-slate-400 uppercase tracking-[0.35em]" id="ui-subtitle">Èå¨ÈáëË°ì„ÅÆÊ∑±Ê∑µ</div>
                        <div class="text-xl md:text-2xl font-black tracking-tight leading-none bg-gradient-to-br from-white to-slate-400 bg-clip-text text-transparent" id="ui-title">Abyss Alchemy</div>
                    </div>
                    <div class="hidden md:flex items-center gap-3 ml-4">
                        <span class="px-4 py-2 rounded-xl glass-panel text-xl font-bold border border-white/5" id="ui-floor">FLOOR 1</span>
                        <span class="px-4 py-2 rounded-xl glass-panel text-xl font-bold text-sky-300 border border-white/5" id="ui-essence">‚ú® 0</span>
                        <div class="relative w-32 h-10 rounded-xl border-2 border-rose-500 bg-slate-900/80 overflow-hidden shadow-[0_0_15px_rgba(244,63,94,0.5)] shrink-0">
                        <div id="ui-hp-bar" class="absolute top-0 left-0 h-full bg-rose-600 transition-all duration-300" style="width: 100%;"></div>
                            <div class="absolute inset-0 flex items-center justify-center z-10">
                                <span id="ui-hp-text" class="text-lg font-black text-white drop-shadow-md">HP 3</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="flex items-center gap-2">
                    <button id="btn-mutations" class="w-10 h-10 md:w-auto md:h-auto md:px-4 md:py-2 flex items-center justify-center glass-panel font-bold text-xs uppercase tracking-widest hover:bg-white/5 active:scale-95 transition-all text-sky-300 border-sky-500/30">
                        <span class="md:hidden">üß¨</span><span class="hidden md:inline" id="btn-mutations-text">Skills</span>
                    </button>
                    <button id="btn-retire" class="w-10 h-10 md:w-auto md:h-auto md:px-4 md:py-2 flex items-center justify-center glass-panel font-bold text-xs uppercase tracking-widest hover:bg-white/5 active:scale-95 transition-all text-rose-300 border-rose-500/30">
                        <span class="md:hidden">üè≥Ô∏è</span><span class="hidden md:inline" id="btn-retire-text">Retire</span>
                    </button>
                    <button id="btn-palette" class="w-10 h-10 md:w-auto md:h-auto md:px-4 md:py-2 flex items-center justify-center glass-panel font-bold text-xs uppercase tracking-widest hover:bg-white/5 active:scale-95 transition-all text-yellow-300 border-yellow-500/30">
                        <span class="md:hidden">üé®</span><span class="hidden md:inline" id="btn-palette-text">Pallet</span>
                    </button>
                    <button id="btn-help" class="w-10 h-10 md:w-auto md:h-auto md:px-4 md:py-2 flex items-center justify-center glass-panel font-bold text-xs uppercase tracking-widest hover:bg-white/5 active:scale-95 transition-all">
                        <span class="md:hidden">?</span><span class="hidden md:inline" id="btn-help-text">Help</span>
                    </button>
                </div>
            </div>
            <div id="status-bar" class="w-full max-w-5xl flex gap-2 shrink-0 z-[150] mb-2">
                <div class="flex-1 glass-panel px-4 py-2 border-l-4 border-l-sky-500/50 flex flex-col justify-center gap-1">
                    <div class="text-base font-black tracking-tight text-white" id="ui-goal">‚Äî</div>
                    <div class="text-base font-bold" id="ui-goal-sub">‚Äî</div>
                </div>
                <div class="w-[180px] md:w-[220px] glass-panel px-4 py-2 border-l-4 border-l-rose-500/50">
                    <div class="text-[10px] text-slate-400 uppercase tracking-[0.35em]" id="ui-pressure-label">PRESSURE</div>
                    <div class="flex items-center gap-2 mt-1">
                        <div class="flex-1 h-4 rounded-full bg-slate-800/80 overflow-hidden relative border border-white/5">
                            <div id="ui-pressure-bar" class="h-full rounded-full bg-gradient-to-r from-sky-400 via-purple-400 to-rose-500 transition-all duration-300" style="width:0%"></div>
                        </div>
                        <div class="text-base font-black w-8 text-right" id="ui-pressure">0</div>
                    </div>
                    <div class="text-[10px] text-slate-500 mt-1 text-right" id="ui-pressure-sub">‚Äî</div>
                </div>
            </div>
            <div id="board-area" class="flex-1 w-full relative z-10 overflow-hidden my-2">
                <div id="board-scroll-area">
                    <div id="tubes-container"></div>
                </div>
            </div>
            <div id="skills-container" class="w-full max-w-4xl mb-2 min-h-[70px] shrink-0">
            </div>
            <div id="bottom-hud" class="w-full max-w-5xl glass-panel p-3 md:p-4 shrink-0 z-20 mb-safe">
                <div class="md:hidden flex items-center justify-between mb-3 px-1 gap-2 text-sm font-bold">
                    <span class="text-slate-300 bg-white/5 px-2 py-1 rounded border border-white/10" id="ui-floor-mobile">1F</span>
                    <div class="flex gap-3">
                        <span class="text-sky-300" id="ui-essence-mobile">‚ú® 0</span>
                    </div>
                    <div class="relative w-20 h-6 rounded-lg border border-rose-500 bg-slate-900/80 overflow-hidden shadow-[0_0_10px_rgba(244,63,94,0.4)] shrink-0">
                        <div id="ui-hp-mobile-bar" class="absolute top-0 left-0 h-full bg-rose-600 transition-all duration-300" style="width: 100%;"></div>
                        <div class="absolute inset-0 flex items-center justify-center z-10">
                            <span id="ui-hp-mobile-text" class="text-sm font-black text-white drop-shadow-md leading-none pt-0.5">HP 3</span>
                        </div>
                    </div>
                </div>
                <div class="flex items-center justify-between gap-3 relative">
                    <div class="flex items-center gap-2 md:gap-3 flex-wrap">
                        <span class="px-4 py-2 rounded-xl glass-panel text-sm font-black tracking-tight text-white border border-white/5" id="ui-turn">TURN 0</span>
                    </div>
                                <button id="btn-undo" class="px-4 py-2 rounded-xl font-bold text-xs uppercase tracking-widest text-slate-300 flex items-center gap-2">
                        <span>‚Ü∫</span> UNDO (‚ú®5)
                    </button>
                </div>
            </div>
        </div>
        <div id="event-screen" class="fixed inset-0 z-[140] bg-slate-950/50 hidden items-center justify-center p-6 transition-opacity">
            <div class="glass-panel w-full max-w-2xl p-6 border border-sky-500/20 shadow-2xl shadow-sky-900/20">
                <div class="flex items-end justify-between gap-4">
                    <div>
                        <div class="text-[16px] text-sky-400 uppercase tracking-[0.35em] font-bold" id="event-kicker">EVENT</div>
                        <div class="text-3xl font-black tracking-tight text-white mt-1" id="event-title">‚Äî</div>
                        <div class="text-slate-300 text-sm mt-3 whitespace-pre-line leading-relaxed" id="event-desc">‚Äî</div>
                    </div>
                    <div class="text-right shrink-0">
                        <div class="px-3 py-1 bg-rose-500/10 border border-rose-500/30 rounded text-[10px] text-rose-300 uppercase tracking-[0.2em]">Unavoidable</div>
                    </div>
                </div>
                <div class="grid md:grid-cols-2 gap-4 mt-8" id="event-choices"></div>
            </div>
        </div>
        <div id="start-screen" class="fixed inset-0 z-[200] flex flex-col items-center justify-center bg-slate-950 p-8">
            <div class="absolute top-8 right-8 z-50 flex items-start gap-2">
                <div class="glass-panel p-1 flex items-center gap-1 shrink-0">
                    <button onclick="setLang('en')" id="lang-en" class="lang-btn">EN</button>
                    <button onclick="setLang('ja')" id="lang-ja" class="lang-btn active">JP</button>
                </div>
                <div class="flex flex-col gap-1 shrink-0 w-[130px]"> <div class="glass-panel p-1 flex items-center gap-1 justify-between">
                        <button onclick="setPalette('default')" id="pal-default" class="lang-btn active flex-1 text-center px-0" title="Standard">STD</button>
                        <button onclick="setPalette('vivid')" id="pal-vivid" class="lang-btn flex-1 text-center px-0" title="Vivid / Contrast">VIS</button>
                        <button onclick="setPalette('universal')" id="pal-universal" class="lang-btn flex-1 text-center px-0" title="Universal / Distinct">UNI</button>
                    </div>
                    <div id="palette-preview" class="glass-panel p-[3px] flex gap-[1px] pointer-events-none h-6 w-full overflow-hidden"></div>
                </div>
            </div>
            <div class="text-center mb-16 floating relative">
                <div class="absolute inset-0 bg-sky-500/20 blur-[100px] rounded-full"></div>
                <h1 class="relative text-5xl md:text-7xl font-black tracking-tighter text-transparent bg-clip-text bg-gradient-to-b from-sky-300 via-sky-500 to-indigo-600 drop-shadow-2xl leading-tight">ABYSS<br>ALCHEMY</h1>
                <p id="start-subtitle" class="relative text-sky-200/60 font-medium tracking-[0.5em] uppercase text-xs mt-4">Èå¨ÈáëË°ì„ÅÆÊ∑±Ê∑µ</p>
            </div>
            <div class="flex flex-col gap-3 w-full max-w-xs">
                <button id="continue-run-btn" class="hidden w-full py-4 bg-emerald-600 rounded-2xl font-black text-white uppercase tracking-widest shadow-2xl shadow-emerald-500/20 hover:bg-emerald-500 hover:shadow-emerald-500/40 hover:-translate-y-1 transition-all active:scale-95 active:translate-y-0 flex items-center justify-center gap-2">
                    <span>‚ñ∂</span> <span id="continue-btn-text">„Å§„Å•„Åç„Åã„Çâ</span>
                </button>
                <button id="start-run-btn" class="w-full py-4 bg-sky-600 rounded-2xl font-black text-white uppercase tracking-widest shadow-2xl shadow-sky-500/20 hover:bg-sky-500 hover:shadow-sky-500/40 hover:-translate-y-1 transition-all active:scale-95 active:translate-y-0">
                    Êé¢Á¥¢„ÇíÈñãÂßã
                </button>
            </div>
            <p class="text-slate-600 text-[10px] mt-8 tracking-widest uppercase">Alpha Ver 0.2.26 Bugfix</p>
        </div>
        <div id="perk-screen" class="fixed inset-0 z-[180] bg-slate-950 flex flex-col items-center justify-center p-4 md:p-8 hidden">
            <div class="w-full max-w-6xl h-full max-h-full flex flex-col glass-panel p-0 overflow-hidden relative border border-white/10 shadow-2xl shadow-black/80">
                <div class="flex justify-between items-center p-3 md:p-6 border-b border-white/5 shrink-0 bg-slate-900/40">
                    <div>
                        <h2 id="perk-title" class="text-xl md:text-3xl font-black text-white italic uppercase leading-none">„Éú„Éº„Éä„Çπ</h2>
                        <p id="perk-subtitle" class="text-slate-400 text-[10px] md:text-xs mt-1 uppercase tracking-widest">Âº∑Âåñ„Åæ„Åü„ÅØÁâ©Ë≥á„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
                    </div>
                    <div class="flex items-center gap-2 md:gap-4">
                        <button id="btn-status-perk" class="h-10 px-4 flex items-center justify-center gap-2 glass-panel font-bold text-base uppercase tracking-tight hover:bg-white/5 active:scale-95 transition-all text-sky-300 border-sky-500/30">
                            <span>üß¨</span> <span id="btn-status-perk-text">STATUS</span>
                        </button>
                        <div class="text-base font-bold text-rose-400 bg-rose-900/30 px-3 py-1.5 rounded border border-rose-500/20 whitespace-nowrap flex items-center gap-1" id="perk-hp">
                            <span class="text-xs">‚ù§</span> <span id="perk-hp-val">3 / 3</span>
                        </div>
                        <div class="text-base font-bold text-sky-400 bg-sky-900/30 px-3 py-1.5 rounded border border-sky-500/20 whitespace-nowrap" id="perk-essence">‚ú® 0</div>
                    </div>
                </div>
                <div class="flex-1 flex flex-col md:flex-row min-h-0 overflow-hidden">
                    <div class="flex-1 flex flex-col p-4 md:p-6 overflow-y-auto border-b md:border-b-0 md:border-r border-white/5 bg-slate-900/20">
                        <div class="text-sm font-bold mb-3 text-sky-300 uppercase tracking-widest flex items-center gap-2">
                            <span class="text-[16px]" id="ui-mutations-label">üß¨ „Çπ„Ç≠„É´</span>
                            <span class="text-[10px] text-slate-500 font-normal normal-case">Pick One (Updates every level)</span>
                        </div>
                        <div class="grid gap-3" id="perk-cards">
                        </div>
                    </div>
                    <div class="flex-1 flex flex-col p-4 md:p-6 overflow-y-auto">
                        <div class="flex justify-between items-center mb-3">
                            <div class="text-sm font-bold text-yellow-500 uppercase tracking-widest flex items-center gap-2">
                                <span class="text-[16px]">‚óà Shop</span>
                                <span class="text-[10px] text-slate-500 font-normal normal-case">4 Random Items</span>
                            </div>
                            <button id="reroll-btn" class="px-3 py-1 glass-panel border border-white/10 text-[10px] font-black uppercase tracking-widest hover:bg-white/5 active:scale-95 transition-all hidden"></button>
                        </div>
                        <div class="grid grid-cols-2 md:grid-cols-2 lg:grid-cols-2 gap-3" id="shop-cards">
                        </div>
                    </div>
                </div>
                <div class="p-4 border-t border-white/5 bg-slate-900/40 shrink-0 flex justify-center z-10">
                    <button id="continue-btn" class="w-full max-w-md py-3 bg-indigo-600 rounded-xl font-black text-white text-sm uppercase tracking-widest shadow-lg shadow-indigo-900/40 hover:bg-indigo-500 transition-all active:scale-95">Next Floor</button>
                </div>
            </div>
        </div>
        <div id="help-screen" class="fixed inset-0 z-[210] bg-slate-950/90 backdrop-blur hidden items-center justify-center p-6">
            <div class="glass-panel w-full max-w-2xl p-8 border border-white/10">
                <div class="flex justify-between items-center mb-6">
                    <div>
                        <div class="text-[10px] text-slate-400 uppercase tracking-[0.35em]">HELP</div>
                        <div class="text-3xl font-black tracking-tight">Guide</div>
                    </div>
                    <button id="help-close" class="px-4 py-2 glass-panel font-black text-xs uppercase tracking-widest hover:bg-white/10 active:scale-95 transition-colors">Close</button>
                </div>
                <div class="text-slate-300 text-sm leading-loose whitespace-pre-line font-medium" id="help-text"></div>
            </div>
        </div>
        <div id="mutations-screen" class="fixed inset-0 z-[210] bg-slate-950/90 backdrop-blur hidden items-center justify-center p-6">
            <div class="glass-panel w-full max-w-3xl p-8 border border-white/10 flex flex-col h-[85vh]">
                <div class="flex justify-between items-center mb-6 shrink-0">
                    <div>
                        <div class="text-[10px] text-sky-400 uppercase tracking-[0.35em]" id="mutations-modal-subtitle">STATUS</div>
                        <div class="text-3xl font-black tracking-tight text-white" id="mutations-modal-title">Bonus & Stats</div>
                    </div>
                    <button id="mutations-close" class="px-4 py-2 glass-panel font-black text-xs uppercase tracking-widest hover:bg-white/10 active:scale-95 transition-colors">Close</button>
                </div>
                        <div class="flex-1 overflow-y-auto space-y-8 pr-2">
                    <div>
                        <div class="text-[10px] text-slate-500 uppercase tracking-widest mb-3">Total Parameters</div>
                        <div id="mutations-stats-summary" class="stat-grid">
                        </div>
                    </div>
                    <div>
                        <div class="text-[10px] text-slate-500 uppercase tracking-widest mb-3">Active Bonuses</div>
                        <div id="mutations-list-container" class="grid gap-2">
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="palette-screen" class="fixed inset-0 z-[210] bg-slate-950/90 backdrop-blur hidden items-center justify-center p-6">
            <div class="glass-panel w-full max-w-md p-8 border border-white/10 flex flex-col gap-6">
                <div class="flex justify-between items-center">
                    <div>
                        <div class="text-[10px] text-yellow-400 uppercase tracking-[0.35em]">COLOR</div>
                        <div class="text-3xl font-black tracking-tight text-white" id="palette-modal-title">Color Pallet</div>
                    </div>
                    <button id="palette-close" class="px-4 py-2 glass-panel font-black text-xs uppercase tracking-widest hover:bg-white/10 active:scale-95 transition-colors">Close</button>
                </div>
                <div class="flex flex-col gap-3">
                    <button onclick="setPalette('default'); closeModal('palette-screen');" id="modal-pal-default" class="w-full py-4 glass-panel border border-white/10 hover:bg-white/5 active:scale-95 transition-all flex items-center justify-between px-6 group">
                        <div class="flex flex-col items-start">
                            <span class="text-lg font-black text-white group-hover:text-sky-300 transition-colors">STANDARD</span>
                            <span class="text-[10px] text-slate-400">Basic / Âü∫Êú¨</span>
                        </div>
                        <div class="flex gap-1">
                            <div class="w-3 h-3 rounded-full bg-[#dc2626]"></div>
                            <div class="w-3 h-3 rounded-full bg-[#3b82f6]"></div>
                            <div class="w-3 h-3 rounded-full bg-[#fbbf24]"></div>
                        </div>
                    </button>
                    <button onclick="setPalette('vivid'); closeModal('palette-screen');" id="modal-pal-vivid" class="w-full py-4 glass-panel border border-white/10 hover:bg-white/5 active:scale-95 transition-all flex items-center justify-between px-6 group">
                        <div class="flex flex-col items-start">
                            <span class="text-lg font-black text-white group-hover:text-sky-300 transition-colors">VIVID</span>
                            <span class="text-[10px] text-slate-400">Contrast / „Ç≥„É≥„Éà„É©„Çπ„Éà</span>
                        </div>
                        <div class="flex gap-1">
                            <div class="w-3 h-3 rounded-full bg-[#ff0000]"></div>
                            <div class="w-3 h-3 rounded-full bg-[#0044ff]"></div>
                            <div class="w-3 h-3 rounded-full bg-[#ffcc00]"></div>
                        </div>
                    </button>
                    <button onclick="setPalette('universal'); closeModal('palette-screen');" id="modal-pal-universal" class="w-full py-4 glass-panel border border-white/10 hover:bg-white/5 active:scale-95 transition-all flex items-center justify-between px-6 group">
                        <div class="flex flex-col items-start">
                            <span class="text-lg font-black text-white group-hover:text-sky-300 transition-colors">UNIVERSAL</span>
                            <span class="text-[10px] text-slate-400">Distinct / „É¶„Éã„Éê„Éº„Çµ„É´</span>
                        </div>
                        <div class="flex gap-1">
                            <div class="w-3 h-3 rounded-full bg-[#ff4b00]"></div>
                            <div class="w-3 h-3 rounded-full bg-[#005aff]"></div>
                            <div class="w-3 h-3 rounded-full bg-[#f6aa00]"></div>
                        </div>
                    </button>
                </div>
            </div>
        </div>
        <div id="dev-tests"></div>
    </div>
    <script>
        function clamp(val, min, max){ return Math.min(Math.max(val, min), max); }
        function addPressure(amount) {
            gameState.pressure += amount;
            if (gameState.pressure >= gameState.pressureMax) {
                gameState.pressure = 0;
                return true; // „Ç™„Éº„Éê„Éº„É≠„Éº„ÉâÁô∫Áîü
            }
            return false;
        }
        function applyPressureDamage(visualOnly = false) {
            if (!visualOnly) {
                if (hasPerk('void_shield') && Math.random() < getPerkLevel('void_shield') * 0.15) {
                    showToast("Void Shield!", "#a855f7");
                    return;
                }
                gameState.hp -= 1;
            }
            
            // ÊºîÂá∫ÈñãÂßã
            ui('game-container').classList.add('animate-shake');
            
            // Èªí„Ç§„É≥„ÇØËøΩÂä†
            corruptRandomSegment(); 
            
            const msg = currentLang === 'ja' ? "„Ç™„Éº„Éê„Éº„É≠„Éº„ÉâÔºÅ HP-1" : "Pressure Overload! HP -1";
            showToast(msg, "#ef4444");
            renderHUD();

            // 500msÂæå„Å´„Ç∑„Çß„Ç§„ÇØÊºîÂá∫„ÇíÁµÇ‰∫ÜÔºà„Åì„Åì„Åß„ÅØbusyËß£Èô§„ÅØË°å„Çè„Å™„ÅÑ„ÄÇtryPour„ÅÆfinally„Å´‰ªª„Åõ„ÇãÔºâ
            setTimeout(() => {
                const container = ui('game-container');
                if(container) container.classList.remove('animate-shake');
            }, 500);
        }
        function randInt(n){ return Math.floor(Math.random()*n); }
        function pick(arr){ return arr[randInt(arr.length)]; }
        function deepCopy(x){ return JSON.parse(JSON.stringify(x)); }
        function ui(id){ return document.getElementById(id); }
        function setText(id, text){
            const el = document.getElementById(id);
            if(el) el.textContent = text;
        }
        const tooltipEl = document.getElementById('global-tooltip');
        function showGlobalTooltip(targetEl, title, desc) {
            if(!targetEl || !title) {
                hideGlobalTooltip();
                return;
            }
                tooltipEl.innerHTML = `
                <div class="font-bold text-sky-300 text-xs mb-1">${title}</div>
                <div class="text-slate-300 text-[10px] leading-tight whitespace-pre-wrap">${desc}</div>
            `;
                const rect = targetEl.getBoundingClientRect();
            tooltipEl.style.opacity = '1';
            const ttWidth = tooltipEl.offsetWidth;
            const ttHeight = tooltipEl.offsetHeight;
            let left = rect.left + (rect.width / 2);
            let top = rect.top - ttHeight - 8;
            if (left - (ttWidth/2) < 4) left = 4 + (ttWidth/2);
            if (left + (ttWidth/2) > window.innerWidth - 4) left = window.innerWidth - 4 - (ttWidth/2);
            tooltipEl.style.left = `${left}px`;
            tooltipEl.style.top = `${top}px`;
        }
        function hideGlobalTooltip() {
            tooltipEl.style.opacity = '0';
        }
        function showToast(msg, color='sky'){
            const container = ui('toast-container');
            const el = document.createElement('div');
            el.className = `toast-msg text-${color}-300 border-${color}-500/30`;
            el.innerHTML = `<span>‚óà</span> ${msg}`;
            container.appendChild(el);
            setTimeout(() => {
                el.classList.add('fade-out');
                setTimeout(() => el.remove(), 300);
            }, 3000);
        }
        const SAVE_KEY = 'abyssal_alchemy_save_v1';
        function saveGame() {
            try {
                const data = JSON.stringify(gameState);
                localStorage.setItem(SAVE_KEY, data);
            } catch (e) {
                console.error("Save failed:", e);
                showToast("Save failed (Storage Full?)", "red");
            }
        }
        function loadGame() {
            try {
                const data = localStorage.getItem(SAVE_KEY);
                if (data) {
                    const loadedState = JSON.parse(data);
                                Object.assign(gameState, loadedState);
                    gameState.busy = false; 
                    gameState.selectedIdx = null;
                    gameState.targetMode = null;
                    gameState.pipetteMode = false;
                    gameState.pendingSkill = null;
                    gameState.extractorHeldColor = null;
                    if (!gameState.completedFlags) gameState.completedFlags = [];
                    updateTubeLayout();
                    startScreen.classList.add('hidden');
                                renderHUD();
                    renderBoard(true);
                                if (checkLevelClear()) {
                        openPerkScreen(false);
                    } else {
                        perkScreen.classList.add('hidden');
                    }
                    showToast(currentLang==='ja'?'ÂÜçÈñã„Åó„Åæ„Åó„Åü':'Game Loaded', 'emerald');
                    return true;
                }
            } catch (e) {
                console.error("Load failed:", e);
            }
            return false;
        }
        function clearSave() {
            localStorage.removeItem(SAVE_KEY);
        }
        function hasSaveData() {
            return !!localStorage.getItem(SAVE_KEY);
        }
        const translations = {
            en: {
                subtitle: "Abyss Alchemy",
                startBtn: "New Descent",
                continueBtn: "Continue",
                vitality: "HP",
                floor: "FLOOR",
                essence: "Essence",
                turn: "TURN",
                secondary: "BONUS",
                perks: "PERKS",
                hint: "Select a tube to pour",
                goalTitle: "GOAL",
                pressureTitle: "PRESSURE",
                eventKicker: "Completion Bonus",
                unavoid: "Unavoidable",
                mutationsLabel: "üß¨ Skills",
                helpTitle: "How to play",
                helpText: [
                    "‚Ä¢ Pour water: Click a tube, then click another to pour.",
                    "‚Ä¢ Obsidian (Black Ink): Fill a tube to evaporate them and make it empty!",
                    "‚Ä¢ Pressure: Rises with every move. If it fills, you take 1 Damage.",
                    "‚Ä¢ Survival: No Move limit. Manage your HP and Pressure to survive.",
                    "‚Ä¢ Artifacts: Buy skills in the shop. Use them from the bottom bar.",
                    "‚Ä¢ Undo: Use the button below (Costs 5 Essence).",
                ].join("\n"),
                helpClose: "Close",
                settings: "Settings",
                continue: "Continue",
                shopTitle: "Shop",
                shopSub: "Trade Essence for survival",
                gameOver: "Consumed",
                gameOverSub: "The abyss claims another soul...",
                victory: "Mutation",
                victorySub: "Select a Skill to evolve",
                typeInstant: "Instant",
                typeItem: "Held Item",
                reroll: "Reroll",
                statusBtn: "STATUS",
                retireBtn: "Retire",
                helpBtn: "Help",
                paletteBtn: "Pallet",
                paletteTitle: "Color Pallet",
                close: "Close"
            },
            ja: {
                subtitle: "Èå¨ÈáëË°ì„ÅÆÊ∑±Ê∑µ",
                startBtn: "Êñ∞„Åü„Å™Êé¢Á¥¢",
                continueBtn: "„Å§„Å•„Åç„Åã„Çâ",
                vitality: "HP",
                floor: "ÈöéÂ±§",
                essence: "„Ç®„ÉÉ„Çª„É≥„Çπ",
                turn: "„Çø„Éº„É≥",
                secondary: "Bonus",
                perks: "„Éú„Éº„Éä„Çπ",
                hint: "„ÉÅ„É•„Éº„Éñ„ÇíÈÅ∏Êäû„Åó„Å¶Ê≥®„Åê",
                goalTitle: "ÁõÆÊ®ô",
                pressureTitle: "„Éó„É¨„ÉÉ„Ç∑„É£„Éº",
                eventKicker: "ÂÆåÊàê„Éú„Éº„Éä„Çπ",
                unavoid: "‰∏çÂèØÈÅø",
                mutationsLabel: "üß¨ „Çπ„Ç≠„É´",
                helpTitle: "ÈÅä„Å≥Êñπ",
                helpText: [
                    "„ÉªÊ≥®„ÅêÔºö„ÉÅ„É•„Éº„Éñ„ÇíÈÅ∏Êäû„Åó„ÄÅÂà•„ÅÆ„ÉÅ„É•„Éº„Éñ„Å∏Ê≥®„Åé„Åæ„Åô",
                    "„ÉªÈªí„Ç§„É≥„ÇØÔºöÁ©∫„ÅÆ„ÉÅ„É•„Éº„Éñ„ÇíÊ∫Ä„Åü„Åô„Å®Ëí∏Áô∫„Åó„Å¶Ê∂à„Åà„ÄÅÁ©∫„ÅçÁì∂„Å´„Å™„Çä„Åæ„Åô„ÄÇ",
                    "„Éª„Éó„É¨„ÉÉ„Ç∑„É£„ÉºÔºö1Êâã„Åî„Å®„Å´‰∏äÊòá„Åó„Åæ„Åô„ÄÇÊúÄÂ§ß„Å´„Å™„Çã„Å®HP„Åå1Ê∏õ„Çä„Åæ„Åô„ÄÇ",
                    "„ÉªÁîüÂ≠òÔºöÊâãÊï∞Âà∂Èôê„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇHP„ÅåÂ∞Ω„Åç„Å™„ÅÑÈôê„ÇäÊé¢Á¥¢„ÇíÁ∂ö„Åë„Çâ„Çå„Åæ„Åô„ÄÇ",
                    "„ÉªÈÅìÂÖ∑„Å®ÁßòË°ìÔºö„Ç∑„Éß„ÉÉ„Éó„Åß„Ç¢„Ç§„ÉÜ„É†„ÇíË≥ºÂÖ•„Åó„ÄÅÁîªÈù¢‰∏ãÈÉ®„Åã„Çâ‰ΩøÁî®„Åó„Åæ„Åô",
                    "„Éª„ÇÑ„ÇäÁõ¥„ÅóÔºöÂè≥‰∏ã„ÅÆUNDO„Éú„Çø„É≥„Çí‰ΩøÁî®„Åó„Åæ„ÅôÔºàÊ∂àË≤ªÔºö5„Ç®„ÉÉ„Çª„É≥„ÇπÔºâ",
                    "„Éª„Ç¢„Ç§„ÉÜ„É†Ôºö„Ç¢„Ç§„Ç≥„É≥„Çí1Âõû„Çø„ÉÉ„Éó„ÅßÈÅ∏Êäû(Á¢∫Ë™ç)„ÄÅ2ÂõûÁõÆ„Åß‰ΩøÁî®/„É¢„Éº„ÉâÁßªË°å„Åó„Åæ„Åô„ÄÇ",
                ].join("\n"),
                helpClose: "Èñâ„Åò„Çã",
                settings: "Ë®≠ÂÆö",
                continue: "Ê¨°„Å∏ÈÄ≤„ÇÄ",
                shopTitle: "„Ç∑„Éß„ÉÉ„Éó",
                shopSub: "„Ç®„ÉÉ„Çª„É≥„Çπ„ÇíÊ∂àË≤ª„Åó„Å¶ÂÆâÂÆö„ÇíÂæó„Çã",
                gameOver: "Â•àËêΩ„Å´Âëë„Åæ„Çå„Åü",
                gameOverSub: "Ê∑±Ê∑µ„ÅØ„Åæ„Åü‰∏Ä„Å§È≠Ç„ÇíÂñ∞„Çâ„Å£„Åü...",
                victory: "Â†±ÈÖ¨",
                victorySub: "ÈÄ≤Âåñ„Åô„Çã„Çπ„Ç≠„É´„ÇíÈÅ∏Êäû„Åô„Çã",
                typeInstant: "Âç≥ÊôÇÂÆüË°å",
                typeItem: "ÊâÄÊåÅ„Ç¢„Ç§„ÉÜ„É†",
                reroll: "„É™„É≠„Éº„É´",
                statusBtn: "„Çπ„ÉÜ„Éº„Çø„Çπ",
                retireBtn: "„É™„Çø„Ç§„Ç¢",
                helpBtn: "„Éò„É´„Éó",
                paletteBtn: "„Éë„É¨„ÉÉ„Éà",
                paletteTitle: "„Ç´„É©„Éº„Éë„É¨„ÉÉ„Éà",
                close: "Èñâ„Åò„Çã"
            }
        };
        let currentLang = 'ja';
        function updateStartScreenButtons(){
        const hasSave = hasSaveData();
        const cbtn = ui('continue-run-btn');
        if (cbtn) cbtn.classList.toggle('hidden', !hasSave);
        setText('start-run-btn', t('startBtn'));
        setText('continue-btn-text', t('continueBtn'));
        }
        function setLang(lang){
            currentLang = lang;
            document.getElementById('lang-en').classList.toggle('active', lang==='en');
            document.getElementById('lang-ja').classList.toggle('active', lang==='ja');
            applyLang();
            updateStartScreenButtons();
            renderHUD();
            localStorage.setItem('abyss_alchemy_lang', lang);
        }
        function t(key){
            return translations[currentLang]?.[key] ?? translations.en[key] ?? key;
        }
        function applyLang(){
            setText('start-subtitle', t('subtitle'));
            setText('start-run-btn', t('startBtn'));
            setText('continue-btn-text', t('continueBtn'));
            setText('ui-subtitle', t('subtitle'));
            setText('ui-title', translations.en.subtitle);
            setText('ui-goal-title', t('goalTitle'));
            setText('help-text', t('helpText'));
            setText('help-close', t('helpClose'));
            setText('ui-mutations-label', t('mutationsLabel'));
            setText('btn-status-perk-text', t('statusBtn'));
            setText('btn-retire-text', t('retireBtn'));
            setText('btn-help-text', t('helpBtn'));
            setText('btn-palette-text', t('paletteBtn'));
            setText('palette-modal-title', t('paletteTitle'));
            setText('palette-close', t('close'));
            const btnText = currentLang === 'ja' ? '„Çπ„Ç≠„É´' : 'Skills';
            const mutationBtnLabel = document.getElementById('btn-mutations-text');
            if(mutationBtnLabel) mutationBtnLabel.textContent = btnText;
            const modalTitle = document.getElementById('mutations-modal-title');
            if(modalTitle) modalTitle.textContent = currentLang === 'ja' ? '„Éú„Éº„Éä„Çπ„Éª„Çπ„ÉÜ„Éº„Çø„Çπ' : 'Bonus & Stats';
            const modalSub = document.getElementById('mutations-modal-subtitle');
            if(modalSub) modalSub.textContent = currentLang === 'ja' ? '„Çπ„ÉÜ„Éº„Çø„Çπ' : 'STATUS';
        }
        const btnStatusPerk = ui('btn-status-perk');
        if (btnStatusPerk) {
            btnStatusPerk.onclick = (e) => {
                e.stopPropagation();
                openMutationsScreen();
            };
        }
        function initSkillScroll() {
            const sc = ui('skills-container');
            let isDown = false;
            let startX;
            let scrollLeft;
            sc.addEventListener('mousedown', (e) => {
                isDown = true;
                sc.classList.add('active');
                startX = e.pageX - sc.offsetLeft;
                scrollLeft = sc.scrollLeft;
            });
            sc.addEventListener('mouseleave', () => {
                isDown = false;
            });
            sc.addEventListener('mouseup', () => {
                isDown = false;
            });
            sc.addEventListener('mousemove', (e) => {
                if (!isDown) return;
                e.preventDefault();
                const x = e.pageX - sc.offsetLeft;
                const walk = (x - startX) * 2; 
                sc.scrollLeft = scrollLeft - walk;
            });
        }
        initSkillScroll();
        const COLOR_POOL = [
            { key: 'R', name:{en:'Crimson', ja:'Á¥Ö'}, hex:'#dc2626' }, 
            { key: 'B', name:{en:'Azure', ja:'Ëíº'}, hex:'#3b82f6' },
            { key: 'Y', name:{en:'Amber', ja:'Áê•ÁèÄ'}, hex:'#fbbf24' },
            { key: 'W', name:{en:'Ivory', ja:'Ë±°Áâô'}, hex:'#e2e8f0' },
            { key: 'K', name:{en:'Obsidian', ja:'Èªí'}, hex:'#1f273a' },
            { key: 'G', name:{en:'Emerald', ja:'Áø†'}, hex:'#22c55e' }, 
            { key: 'P', name:{en:'Amethyst', ja:'Á¥´'}, hex:'#a855f7' }, 
            { key: 'O', name:{en:'Orange', ja:'Ê©ô'}, hex:'#f97316' }, 
            { key: 'T', name:{en:'Teal', ja:'ÈùíÁ∑ë'}, hex:'#06b6d4' }, 
            { key: 'M', name:{en:'Pink', ja:'Ê°É'}, hex:'#d946ef' }, 
        ];
        const PALETTES_DATA = {
            default:   ['#dc2626','#3b82f6','#fbbf24','#e2e8f0','#1f273a','#22c55e','#a855f7','#f97316','#06b6d4','#d946ef'],
            vivid:     ['#ff0000','#0044ff','#ffcc00','#ffffff','#000000','#00ff00','#9900ff','#ff6600','#00ffff','#ff00cc'],
            universal: ['#ff4b00','#005aff','#f6aa00','#f2f2f2','#222222','#03af7a','#990099','#d67b24','#4dc4ff','#ff99ff']
        };
        let currentPalette = 'default';
        function setPalette(mode) {
            if (!PALETTES_DATA[mode]) return;
            currentPalette = mode;
            ['default', 'vivid', 'universal'].forEach(m => {
                const btn = document.getElementById(`pal-${m}`);
                if(btn) btn.classList.toggle('active', m === mode);
            });
            ['default', 'vivid', 'universal'].forEach(m => {
                const modalBtn = document.getElementById(`modal-pal-${m}`);
                if(modalBtn) {
                    if(m === mode) {
                        modalBtn.classList.add('border-sky-500', 'bg-sky-500/10');
                        modalBtn.classList.remove('border-white/10');
                    } else {
                        modalBtn.classList.remove('border-sky-500', 'bg-sky-500/10');
                        modalBtn.classList.add('border-white/10');
                    }
                }
            });
            const colors = PALETTES_DATA[mode];
            COLOR_POOL.forEach((item, index) => {
                if (colors[index]) {
                    item.hex = colors[index];
                }
            });
            const previewEl = document.getElementById('palette-preview');
            if (previewEl) {
                previewEl.innerHTML = '';
                colors.forEach(c => {
                    const rect = document.createElement('div');
                    rect.style.backgroundColor = c;
                    rect.className = 'flex-1 h-full shadow-sm rounded-[1px]';
                    previewEl.appendChild(rect);
                });
            }
            const container = document.getElementById('tubes-container');
            if (container && container.children.length > 0) {
                document.querySelectorAll('.water-container').forEach(el => {
                    delete el.dataset.lastState;
                });
                renderBoard(); 
            }
            renderSkills();
            localStorage.setItem('abyss_alchemy_palette', mode);
            const modeName = mode === 'default' ? 'Standard' : (mode === 'vivid' ? 'Vivid' : 'Universal');
            showToast(`Color Mode: ${modeName}`, 'sky');
        }
        function closeModal(id) {
            const el = document.getElementById(id);
            if(el) el.classList.replace('flex', 'hidden');
        }
        const btnPalette = ui('btn-palette');
        if(btnPalette){
            btnPalette.onclick = (e) => {
                e.stopPropagation();
                setPalette(currentPalette); 
                ui('palette-screen').classList.replace('hidden', 'flex');
            };
        }
        const btnPaletteClose = ui('palette-close');
        if(btnPaletteClose){
            btnPaletteClose.onclick = (e) => {
                e.stopPropagation();
                closeModal('palette-screen');
            };
        }
        function initPalette() {
            const saved = localStorage.getItem('abyss_alchemy_palette');
            if (saved && PALETTES_DATA[saved]) {
                setPalette(saved);
            } else {
                setPalette('default');
            }
        }
        const PERKS = {
            catalyst: {id:'catalyst',name:{en:'Catalyst', ja:'Ëß¶Â™íÂèçÂøú'},rarity:'epic',desc:{en:'Completing a tube reduces Pressure by [4 + Lv].', ja:'Ëâ≤„ÇíÂÆåÊàê„Åï„Åõ„Çã„Å®„Éó„É¨„ÉÉ„Ç∑„É£„Éº„Åå [4 + Lv] ‰∏ã„Åå„Çã„ÄÇ'},            },
            efficiency: {id:'efficiency',name:{en:'Efficiency', ja:'ÊäΩÂá∫ÂäπÁéá'},rarity:'common',desc:{en:'Tube completion has [Lv x 20]% chance to grant +1 Essence.', ja:'Ëâ≤ÂÆåÊàêÊôÇ„ÄÅ[Lv x 20]% „ÅÆÁ¢∫Áéá„Åß +1 „Ç®„ÉÉ„Çª„É≥„Çπ„ÇíÁç≤Âæó„ÄÇ'},            },
            transmutation: {id:'transmutation',name:{en:'Transmutation', ja:'Áâ©Ë≥™Â§âÊèõ'},rarity:'rare',desc:{en:'Start each floor with [Lv] random items.', ja:'ÈöéÂ±§ÈñãÂßãÊôÇ„ÄÅ[Lv] ÂÄã„ÅÆ„É©„É≥„ÉÄ„É†„Ç¢„Ç§„ÉÜ„É†„ÇíÁç≤Âæó„Åô„Çã„ÄÇ'},            },
            momentum: {id:'momentum',name:{en:'Momentum', ja:'ÊÖ£ÊÄßÂæã'},rarity:'common',desc:{en:'After completing a tube, Pressure does not rise for [Lv] turns.', ja:'„ÉÅ„É•„Éº„ÉñÂÆåÊàêÂæå„ÄÅ[Lv] „Çø„Éº„É≥„ÅÆÈñì„ÄÅ„Éó„É¨„ÉÉ„Ç∑„É£„Éº„Åå‰∏äÊòá„Åó„Å™„ÅÑ„ÄÇ'},            },
            reflux: {id:'reflux',name:{en:'Reflux', ja:'ÈÄÜÊµÅÂà∂Âæ°'},rarity:'common',desc:{en:'First [Lv] undos each floor are free (Pressure +2 instead).', ja:'ÂêÑÈöéÂ±§„ÄÅÊúÄÂàù„ÅÆ [Lv] Âõû„ÅÆUndo„ÅØ„Ç®„ÉÉ„Çª„É≥„ÇπÁÑ°Êñô„ÄÇ'},            },
            steady_hand: {id:'steady_hand',name:{en:'Steady Hand', ja:'ÂÆâÂÆö„Åó„ÅüÊâã'},rarity:'rare',desc:{en:'Pressure does not rise for the first [Lv x 3] turns of a floor.', ja:'ÈöéÂ±§ÈñãÂßã„Åã„Çâ [Lv x 3] „Çø„Éº„É≥„ÅÆÈñì„ÄÅ„Éó„É¨„ÉÉ„Ç∑„É£„Éº„Åå‰∏äÊòá„Åó„Å™„ÅÑ„ÄÇ'},            },
            overflow: {id:'overflow',name:{en:'Overflow', ja:'„Ç™„Éº„Éê„Éº„Éï„É≠„Éº'},rarity:'common',desc:{en:'Pressure max +[Lv x 4].', ja:'„Éó„É¨„ÉÉ„Ç∑„É£„Éº„ÅÆÊúÄÂ§ßË®±ÂÆπÈáè„Åå +[Lv x 4] „Åï„Çå„Çã„ÄÇ'},            },
            purification: {id:'purification',name:{en:'Purification', ja:'ÊµÑÂåñ‰ΩúÁî®'},rarity:'epic',desc:{en:'Clearing Obsidian reduces Pressure by [2 + Lv] and grants [1 + Lv] Essence.', ja:'Èªí„Ç§„É≥„ÇØÊ∂àÊªÖÊôÇ„ÄÅ„Éó„É¨„ÉÉ„Ç∑„É£„Éº-[2 + Lv]„ÄÅ„Ç®„ÉÉ„Çª„É≥„Çπ+[1 + Lv]„ÄÇ'},            },
            scavenger: {id:'scavenger',name:{en:'Scavenger', ja:'„Çπ„Ç´„Éô„É≥„Ç∏„É£„Éº'},rarity:'rare',desc:{en:'[10 + Lv x 5]% chance to find item on new floor.', ja:'ÈöéÂ±§ÁßªÂãïÊôÇ„ÄÅ[10 + Lv x 5]% „ÅÆÁ¢∫Áéá„Åß„Ç¢„Ç§„ÉÜ„É†„ÇíÊãæ„ÅÜ„ÄÇ'},            },
            recycler: {id:'recycler',name:{en:'Recycler', ja:'„É™„Çµ„Ç§„ÇØ„É´'},rarity:'epic',desc:{en:'[Lv x 10]% chance to not consume item on use.', ja:'„Ç¢„Ç§„ÉÜ„É†‰ΩøÁî®ÊôÇ„ÄÅ[Lv x 10]% „ÅÆÁ¢∫Áéá„ÅßÊ∂àË≤ª„Åó„Å™„ÅÑ„ÄÇ'},            },
            bargain: {id:'bargain',name:{en:'Bargain', ja:'‰∫§Ê∏âË°ì'},rarity:'common',desc:{en:'Shop prices reduced by [15 + Lv x 5]%.', ja:'„Ç∑„Éß„ÉÉ„Éó‰æ°Ê†º [15 + Lv x 5]% OFF„ÄÇ'},            },
            heavy_mastery: {id:'heavy_mastery',name:{en:'Heavy Mastery', ja:'Â§ßÂÆπÈáè„Éú„Éº„Éä„Çπ'},rarity:'rare',desc:{en:'Clearing 5+ capacity tube reduces Pressure by [2 + Lv].', ja:'ÂÆπÈáè5‰ª•‰∏ä„ÅÆ„ÉÅ„É•„Éº„ÉñÂÆåÊàê„Åß„Éó„É¨„ÉÉ„Ç∑„É£„Éº [2 + Lv] Ê∏õÂ∞ë„ÄÇ'},            },
            void_shield: {id:'void_shield',name:{en:'Void Shield', ja:'ËôöÁ©∫„ÅÆÁõæ'},rarity:'rare',desc:{en:'[Lv x 15]% chance to negate Pressure damage.', ja:'„Éó„É¨„ÉÉ„Ç∑„É£„Éº„ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„ÅüÊôÇ„ÄÅ[Lv x 15]% „ÅßÁÑ°ÂäπÂåñ„Åô„Çã„ÄÇ'},            },
            deep_adapt: {id:'deep_adapt',name:{en:'Deep Adapt', ja:'Ê∑±Â±§ÈÅ©Âøú'},rarity:'epic',desc:{en:'Gain [Lv] Max HP if capacity > 4 at start of floor.', ja:'ÈöéÂ±§ÈñãÂßãÊôÇ„ÄÅÂÆπÈáè5‰ª•‰∏ä„Å™„ÇâÊúÄÂ§ßHP+[Lv]„ÄÇ'},            },
            flow_mastery: {id:'flow_mastery',name:{en:'Flow Mastery', ja:'„Éï„É≠„ÉºÁÜüÁ∑¥'},rarity:'common',desc:{en:'Combo reduces Pressure by [Lv x 2].', ja:'„Ç≥„É≥„ÉúÁô∫ÁîüÊôÇ„ÄÅ„Éó„É¨„ÉÉ„Ç∑„É£„Éº„Åå [Lv x 2] ‰∏ã„Åå„Çã„ÄÇ'},            },
            coupon: {id: 'coupon',name: {en:'Coupon', ja:'„ÇØ„Éº„Éù„É≥Âà∏'},rarity: 'common',desc: {en:'Start each floor with [Lv] free Rerolls.', ja:'ÂêÑÈöéÂ±§ÈñãÂßãÊôÇ„ÄÅÁÑ°Êñô„Åß„É™„É≠„Éº„É´„Åß„Åç„Çã„ÇØ„Éº„Éù„É≥„Çí [Lv] ÊûöÂæó„Çã„ÄÇ'}            },
            crimson_resonance: {id:'crimson_resonance',name:{en:'Crimson Resonance', ja:'Á¥Ö„ÅÆÁÜ±Èáè'},rarity:'rare',desc:{en:'Completing Crimson heals 1 HP but adds [6 - Lv] Pressure.', ja:'Á¥Ö„ÇíÂÆåÊàê„Åï„Åõ„Çã„Å®HP„Åå1ÂõûÂæ©„Åô„Çã„Åå„ÄÅ„Éó„É¨„ÉÉ„Ç∑„É£„Éº„Åå [6 - Lv] ‰∏äÊòá„Åô„Çã„ÄÇ'},            },
            azure_cycle: {id:'azure_cycle',name:{en:'Azure Cycle', ja:'Ëíº„ÅÆÂæ™Áí∞'},rarity:'common',desc:{en:'Azure completion reduces Pressure by [Lv x 3] additional.', ja:'ËíºÂÆåÊàêÊôÇ„ÄÅËøΩÂä†„Åß„Éó„É¨„ÉÉ„Ç∑„É£„Éº„Åå [Lv x 3] Ê∏õÂ∞ë„Åô„Çã„ÄÇ'},            },
            amber_greed: {id:'amber_greed',name:{en:'Amber Alchemy', ja:'Áê•ÁèÄ„ÅÆÈå¨Èáë'},rarity:'rare',desc:{en:'Amber completion grants [Lv x 2] Essence.', ja:'Áê•ÁèÄÂÆåÊàêÊôÇ„ÄÅ„Ç®„ÉÉ„Çª„É≥„Çπ„Çí [Lv x 2] Áç≤Âæó„Åô„Çã„ÄÇ'},            },
            ivory_sanctuary: {id:'ivory_sanctuary',name:{en:'Ivory Sanctuary', ja:'Ë±°Áâô„ÅÆËÅñÂüü'},rarity:'epic',desc:{en:'Ivory completion removes [Lv] Obsidian from random tubes.', ja:'Ë±°ÁâôÂÆåÊàêÊôÇ„ÄÅ„É©„É≥„ÉÄ„É†„Å™„ÉÅ„É•„Éº„Éñ„Åã„ÇâÈªí„Ç§„É≥„ÇØ„Çí [Lv] ÂÄãÈô§Âéª„Åô„Çã„ÄÇ'},            },
            emerald_vitality: {id:'emerald_vitality',name:{en:'Emerald Vitality', ja:'Áø†„ÅÆÊ¥ªÂäõ'},rarity:'common',desc:{en:'Emerald completion halves current Pressure.', ja:'Áø†„ÇíÂÆåÊàê„Åï„Åõ„Çã„Å®ÁèæÂú®„ÅÆ„Éó„É¨„ÉÉ„Ç∑„É£„Éº„ÅåÂçäÂàÜ„Å´„Å™„Çã„ÄÇ'},            },
            amethyst_surge: {id:'amethyst_surge',name:{en:'Amethyst Surge', ja:'Á¥´„ÅÆËÑàÂãï'},rarity:'rare',desc:{en:'Amethyst completion grants +[Lv] free Undo charges.', ja:'Á¥´ÂÆåÊàêÊôÇ„ÄÅÁÑ°ÊñôUndo„ÅÆÂõûÊï∞„Çí [Lv] ÂõûÂ¢ó„ÇÑ„Åô„ÄÇ'},            },
            orange_drive: {id:'orange_drive',name:{en:'Orange Drive', ja:'Ê©ô„ÅÆÊé®ÈÄ≤'},rarity:'common',desc:{en:'Orange completion stops Pressure rise for [Lv x 2] turns.', ja:'Ê©ôÂÆåÊàêÊôÇ„ÄÅ[Lv x 2] „Çø„Éº„É≥„ÅÆÈñì„Éó„É¨„ÉÉ„Ç∑„É£„Éº„Åå‰∏äÊòá„Åó„Å™„Åè„Å™„Çã„ÄÇ'},            },
            teal_equilibrium: {id:'teal_equilibrium',name:{en:'Teal Analysis', ja:'ÈùíÁ∑ë„ÅÆÂàÜÊûê'},rarity:'rare',desc:{en:'Teal completion progresses Secondary Goal by 1.', ja:'ÈùíÁ∑ë„ÇíÂÆåÊàê„Åï„Åõ„Çã„Å®ÂâØÁõÆÊ®ô„ÅÆÈÄ≤Ë°åÂ∫¶„Åå 1 ÈÄ≤„ÇÄ„ÄÇ'},            },
            pink_luck: {id:'pink_luck',name:{en:'Pink Luck', ja:'Ê°É„ÅÆÂπ∏ÈÅã'},rarity:'rare',desc:{en:'Pink completion has [Lv x 10]% chance to drop a random item.', ja:'Ê°ÉÂÆåÊàêÊôÇ„ÄÅ[Lv x 10]% „ÅÆÁ¢∫Áéá„Åß„É©„É≥„ÉÄ„É†„Å™„Ç¢„Ç§„ÉÜ„É†„ÇíÂæó„Çã„ÄÇ'},            }
        };
        const ITEMS = {
            heal: {id: 'heal', type: 'consumable', cost: 8, icon: 'ü©π', name: {en:'Stabilizer', ja:'ÂÆâÂÆöÂâ§'},desc: {en:'Heal +1 HP.', ja:'HP„Çí+1ÂõûÂæ©„Åô„Çã'}},
            panacea: {id: 'panacea', type: 'consumable', cost: 20, icon: 'üíä',name: {en:'Panacea', ja:'‰∏áËÉΩËñ¨'},desc: {en:'Heal +2 HP.', ja:'HP„Çí+2ÂõûÂæ©„Åô„Çã'}            },
            sedative: {id: 'sedative', type: 'consumable', cost: 12, icon: 'üí§',name: {en:'Sedative', ja:'ÈéÆÈùôÂâ§'},desc: {en:'Set Pressure to 0.', ja:'„Éó„É¨„ÉÉ„Ç∑„É£„Éº„Çí0„Å´„Åô„Çã'}            },
            layer_swap: {id: 'layer_swap', type: 'consumable', cost: 12, icon: 'üîó',name: {en:'Layer Swap', ja:'Â±§‰∫§Êèõ'},desc: {en:'Swap top 2 layers.', ja:'‰∏ä2„Å§„ÅÆÂ±§„ÇíÂÖ•„ÇåÊõø„Åà'}            },
            shaker: {id: 'shaker', type: 'consumable', cost: 5, icon: 'üé≤',name: {en:'Shaker', ja:'„Ç∑„Çß„Ç§„Ç´„Éº'},desc: {en:'Shuffle tube.', ja:'‰∏≠Ë∫´„Çí„Ç∑„É£„ÉÉ„Éï„É´'}            },
            cursed_sludge: {id: 'cursed_sludge', type: 'consumable', cost: 6, icon: '‚ö´',name: {en:'Cursed Sludge', ja:'Âë™„ÅÑ„ÅÆÊ≥•'},desc: {en:'Add Obsidian if space.', ja:'Á©∫„Åç„Åå„ÅÇ„Çå„Å∞Èªí„ÇíËøΩÂä†'}            },
            void_salt: {id: 'void_salt', type: 'consumable', cost: 8, icon: 'üßÇ',name: {en:'Void Salt', ja:'ËôöÁÑ°„ÅÆÂ°©'},desc: {en:'Remove top Black.', ja:'‰∏ÄÁï™‰∏ä„ÅÆ„ÄêÈªí„Äë„ÇíÈô§Âéª'}            },
            transfer: {id: 'transfer', type: 'consumable', cost: 10, icon: 'üß¥',name: {en:'Surface Transfer', ja:'Ê∞¥Èù¢ÁßªÈÄÅ'},desc: {en:'Move top 1 segment anywhere.', ja:'‰∏ÄÁï™‰∏ä„ÅÆËâ≤„ÇíÂê∏„ÅÑÂá∫„Åó„Å©„Åì„Å´„Åß„ÇÇÊ≥®ÂÖ•„Åô„Çã'}            },
            vacuum: {id: 'vacuum', type: 'consumable', cost: 14, icon: 'üåÄ',name: {en:'Obsidian Vacuum', ja:'ÈªíÂê∏ÂºïÊ©ü'},desc: {en:'Remove all top Obsidian.', ja:'‰∏ÄÁï™‰∏ä„ÅÆÈªí„Ç§„É≥„ÇØ„ÇíÂÖ®Èô§Âéª'}            },
            midas: {id: 'midas', type: 'consumable', cost: 8, icon: 'üñêÔ∏è',name: {en:'Alchemy Stone', ja:'ÂØæÈªíÂ§âÊàê'},desc: {en:'Obsidian > Essence.', ja:'‰∏ÄÁï™‰∏ä„ÅÆÈªí„Çí„Ç®„ÉÉ„Çª„É≥„Çπ„Å´'}            },
            vaporizer: {id: 'vaporizer', type: 'consumable', cost: 7, icon: '‚ô®Ô∏è',name: {en:'Vaporizer', ja:'ÂæÆÈáèËí∏Áô∫'},desc: {en:'Delete top 1 segment.', ja:'‰∏ÄÁï™‰∏ä„ÅÆ1Â±§„ÇíÈô§Âéª'}            },
            sediment: {id: 'sediment', type: 'consumable', cost: 10, icon: '‚è¨',name: {en:'Sediment', ja:'Ê≤àÊÆø'},desc: {en:'Move top to bottom.', ja:'‰∏ÄÁï™‰∏ä„Çí‰∏ÄÁï™‰∏ã„Å∏'}            },
            quantum_pipette: {id: 'quantum_pipette', type: 'consumable', cost: 15, icon: 'üíâ',name: {en:'Quantum Pipette', ja:'ÈáèÂ≠ê„Çπ„Éù„Ç§„Éà'},desc: {en:'Extract bottom color.', ja:'‰∏ÄÁï™‰∏ã„ÅÆËâ≤„ÇíÂê∏„ÅÑÂá∫„Åó„Å©„Åì„Å´„Åß„ÇÇÊ≥®ÂÖ•„Åô„Çã'}            },
            cycle_siphon: {id: 'cycle_siphon', type: 'consumable', cost: 10, icon: '‚è´',name: {en:'Cycle Siphon', ja:'Âæ™Áí∞„Çµ„Ç§„Éï„Ç©„É≥'},desc: {en:'Move bottom to top.', ja:'‰∏ÄÁï™‰∏ã„Çí‰∏ÄÁï™‰∏ä„Å∏'}            },
            inverter: {id: 'inverter', type: 'consumable', cost: 6, icon: 'üîÑ',name: {en:'Gravity Coil', ja:'ÈáçÂäõÂèçËª¢Ê©ü'},desc: {en:'Invert contents.', ja:'‰∏≠Ë∫´„Çí‰∏ä‰∏ãÂèçËª¢'}            },
            separator: {id: 'separator', type: 'consumable', cost: 12, icon: 'üå™Ô∏è',name: {en:'Separator', ja:'ÈÅ†ÂøÉÂàÜÈõ¢Ê©ü'},desc: {en:'Sort tube contents.', ja:'‰∏≠Ë∫´„ÇíÊï¥ÁêÜ„Åô„Çã'}            },
            summon_vial: {id: 'summon_vial', type: 'consumable', cost: 20, icon: 'üß™',name: {en:'Extra Vial', ja:'‰∫àÂÇôË©¶È®ìÁÆ°'},desc: {en:'Add empty tube.', ja:'Á©∫„ÅÆ„ÉÅ„É•„Éº„Éñ„Çí1„Å§ËøΩÂä†'}            },
        };
        const INSTANT_ITEMS = [
            { id:'dark_pact',   type:'stat', cost:0, name:{en:'Dark Pact', ja:'Èªí„ÅÆÂ•ëÁ¥Ñ'},  desc:{en:'HP-2, +20 Ess', ja:'HP-2, +20„Ç®„ÉÉ„Çª„É≥„Çπ'}, apply(gs){     if(gs.hp > 2){        gs.hp -= 2; gs.essence += 20;         showToast('Power at a cost...', 'purple');     } else {        showToast('Too weak...', 'red');    }}             },
            { 
                id:'mystery_box', 
                type:'stat', 
                cost:8, 
                name:{en:'Mystery Box', ja:'Á¶èË¢ã'},    
                desc:{en:'Random Item', ja:'„É©„É≥„ÉÄ„É†„Ç¢„Ç§„ÉÜ„É†'}, 
                apply(gs){ 
                    const keys = Object.keys(ITEMS).filter(k => ITEMS[k].type === 'consumable');
                    const availableKeys = keys.filter(k => (gs.inventory[k] || 0) < 3);
                    if (availableKeys.length > 0) {
                        const gift = pick(availableKeys);
                        if(!gs.inventory[gift]) gs.inventory[gift] = 0;
                        gs.inventory[gift]++;
                        showToast(`Got ${ITEMS[gift].name[currentLang==='ja'?'ja':'en']}!`, 'yellow');
                    } else {
                        showToast(currentLang==='ja' ? '„Åô„Åπ„Å¶„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÅåÊúÄÂ§ßÊï∞„Åß„Åô' : 'All items at max capacity!', 'rose');
                        gs.essence += 8; 
                    }
                } 
            }
        ];
        const SHOP_POOL = [
            ...INSTANT_ITEMS,
            ...Object.values(ITEMS).map(i => ({ id: `buy_${i.id}`, type: 'item', ref: i }))
        ];
        const gameState = {
            floor: 1,
            essence: 0,
            hp: 3,
            maxHp: 3,
            turnCount: 0, 
            capacity: 4,
            tubeCount: 0,
            selectedIdx: null,
            tubes: [],
            busy: false,
            perks: {},
            inventory: {}, 
            pressure: 0,
            pressureMax: 7,
            catalystAvailable: true,
            refluxUses: 0,
            momentumTurns: 0,
            history: [],
            primaryGoal: null,
            secondaryGoal: null,
            secondaryProgress: 0,
            focusIdx: null, 
            currentPerkChoices: null,
            currentShopOffers: null,
            pipetteMode: false,
            targetMode: null, 
            pendingSkill: null, 
            extractorHeldColor: null, 
            rerollCoupons: 0,
            pendingPerkId: null,
            completedFlags: [],
        };
        const tubesContainer = ui('tubes-container');
        const boardArea = ui('board-area');
        const boardScrollArea = ui('board-scroll-area');
        const skillsContainer = ui('skills-container');
        const startScreen = ui('start-screen');
        const perkScreen = ui('perk-screen');
        const perkCards = ui('perk-cards');
        const shopCards = ui('shop-cards');
        const continueBtn = ui('continue-btn');
        const rerollBtn = ui('reroll-btn');
        const helpScreen = ui('help-screen');
        const mutationsScreen = ui('mutations-screen');
        const eventScreen = ui('event-screen');
        const eventChoices = ui('event-choices');
        const devTests = ui('dev-tests');
        const alertBanner = ui('alert-banner');
        const undoBtn = ui('btn-undo');
        const continueRunBtn = ui('continue-run-btn');
        function getPerkLevel(id){ return gameState.perks[id] || 0; }
        function hasPerk(id){ return (gameState.perks[id] || 0) > 0; }
        function getPerkDesc(id, level=1){
            const def = PERKS[id];
            let txt = currentLang==='ja' ? def.desc.ja : def.desc.en;
            txt = txt.replace(/\[Lv\]/g, level);
            txt = txt.replace(/\[4 \+ Lv\]/g, 4 + level);
            txt = txt.replace(/\[6 \- Lv\]/g, 6 - level);
            txt = txt.replace(/\[Lv x 20\]/g, level * 20);
            txt = txt.replace(/\[Lv x 3\]/g, level * 3);
            txt = txt.replace(/\[Lv x 4\]/g, level * 4);
            txt = txt.replace(/\[2 \+ Lv\]/g, 2 + level);
            txt = txt.replace(/\[1 \+ Lv\]/g, 1 + level);
            txt = txt.replace(/\[10 \+ Lv x 5\]/g, 10 + level * 5);
            txt = txt.replace(/\[Lv x 10\]/g, level * 10);
            txt = txt.replace(/\[15 \+ Lv x 5\]/g, 15 + level * 5);
            txt = txt.replace(/\[Lv x 15\]/g, level * 15);
            txt = txt.replace(/\[Lv x 2\]/g, level * 2);
            return txt;
        }
        function tubeTop(t){ return t.length ? t[t.length-1] : null; }
        function tubeFree(t){ return gameState.capacity - t.length; }
        function getBoardCounts(){
            const counts = {};
            gameState.tubes.forEach(t => t.forEach(c => counts[c] = (counts[c]||0)+1));
            return counts;
        }
        function isCompleteTube(t, counts = null) {
            if (!t || t.length === 0) return false;
            const c = t[0];
            if (c === 'K') {
                return t.length >= gameState.capacity && t.every(x => x === 'K');
            }
            if (!counts) counts = getBoardCounts();
            if (!t.every(x => x === c)) return false;
            const total = counts[c] || 0;
            return t.length >= Math.min(gameState.capacity, total);
        }
        function colorMeta(key){ return COLOR_POOL.find(c => c.key===key); }
        function colorName(key){ const m=colorMeta(key); return currentLang==='ja' ? m.name.ja : m.name.en; }
        function generateGoals(){
            const flat = gameState.tubes.flat();
            const presentColors = new Set(flat);
            presentColors.delete('K'); 
            const colors = [...presentColors];
            const roll = Math.random();
            if (roll < 0.65) { 
                gameState.primaryGoal = { type: 'completeAll' };
            } else if (roll < 0.90) { 
                const maxN = colors.length;
                const n = clamp(Math.floor(maxN / 1.5), 1, maxN);
                gameState.primaryGoal = { type:'completeN', n:n };
            } else { 
                const c = pick(colors);
                gameState.primaryGoal = { type:'completeColor', color:c };
            }
                const sroll = Math.random();
            const par = 14 + Math.floor(gameState.floor / 2) + 5; 
            if (sroll < 0.5){
                gameState.secondaryGoal = { type:'speed', limit: par };
            } else {
                gameState.secondaryGoal = { type:'combo', need:2 };
            }
            gameState.secondaryProgress = 0;
            renderHUD();
        }
        function checkPrimaryGoal(){
            const counts = getBoardCounts();
            if (gameState.primaryGoal.type === 'completeAll') { 
                        const flat = gameState.tubes.flat();
                const colorsOnBoard = new Set(flat.filter(c => c !== 'K')).size;
                                return countCompletedTubes(counts) >= colorsOnBoard;
            }
            if (gameState.primaryGoal.type === 'completeN') {
                return countCompletedTubes(counts) >= gameState.primaryGoal.n;
            }
            if (gameState.primaryGoal.type === 'completeColor'){
                return gameState.tubes.some(t => isCompleteTube(t, counts) && t[0] === gameState.primaryGoal.color);
            }
            if (gameState.primaryGoal.type === 'survive') return false; 
            return false;
        }
        function checkLevelClear(){
            const counts = getBoardCounts();
            if (checkPrimaryGoal()) return true;
            const allClean = gameState.tubes.every(t => t.length === 0 || (isCompleteTube(t, counts) && t[0] !== 'K'));
            if (allClean) return true;
            return false;
        }
        function onLevelClear(){
            if (gameState.busy) return;
            gameState.busy = true;

            const baseReward = 6;
            const floorBonus = Math.floor((gameState.floor - 1) / 2);
            const subGoalBonus = secondarySucceeded() ? 4 : 0;
            const totalGained = baseReward + floorBonus + subGoalBonus;
            
            gameState.essence += totalGained;
            
            renderHUD(); 
            renderBoard();
            
            const msg = currentLang === 'ja' 
                ? `ÈöéÂ±§„ÇØ„É™„Ç¢! ‚ú®+${totalGained} (Âü∫Êú¨:${baseReward}${floorBonus > 0 ? ` ÈöéÂ±§:+${floorBonus}` : ''}${subGoalBonus > 0 ? ` „Çµ„ÉñÁõÆÊ®ô:+${subGoalBonus}` : ''})`
                : `Floor Cleared! ‚ú®+${totalGained} (Base:${baseReward}${floorBonus > 0 ? ` Floor:+${floorBonus}` : ''}${subGoalBonus > 0 ? ` SubGoal:+${subGoalBonus}` : ''})`;
                
            showToast(msg, subGoalBonus > 0 ? 'emerald' : 'sky');
            
            saveGame();
            
            setTimeout(() => {
                gameState.busy = false;
                openPerkScreen(false);
            }, 1500);
        }
        function checkSecondaryGoalOnComplete(){
            if (!gameState.secondaryGoal) return;
            if (gameState.secondaryGoal.type === 'speed'){
                if (gameState.turnCount <= gameState.secondaryGoal.limit){
                    gameState.secondaryProgress = 1; 
                }
            } else if (gameState.secondaryGoal.type === 'combo'){
                gameState.secondaryProgress += 1;
                if(hasPerk('flow_mastery') && gameState.secondaryProgress >= 2){
                    const lv = getPerkLevel('flow_mastery');
                    gameState.pressure = Math.max(0, gameState.pressure - (lv * 2));
                    showFloatText(0, `Flow! -${lv*2} Pressure`, '#38bdf8');
                }
            }
        }
        function secondarySucceeded(){
            if (!gameState.secondaryGoal) return false;
            if (gameState.secondaryGoal.type === 'speed') return gameState.secondaryProgress >= 1;
            if (gameState.secondaryGoal.type === 'combo') return gameState.secondaryProgress >= gameState.secondaryGoal.need;
            return false;
        }
        function isDeadlocked(){
            for(let i=0; i<gameState.tubes.length; i++){
                if(gameState.tubes[i].length === 0) continue; 
                for(let j=0; j<gameState.tubes.length; j++){
                    if(i===j) continue;
                    const check = canPour(i, j);
                    if(check.ok) return false; 
                }
            }
            return true; 
        }
        function generateBoard() {
            const floor = gameState.floor;
            gameState.tubeCount = Math.min(10, 6 + Math.floor((floor - 1) / 2));
            const numColors = gameState.tubeCount - 2;
            const safeNumColors = Math.min(numColors, COLOR_POOL.length);
            const pool = COLOR_POOL.slice(0, Math.min(COLOR_POOL.length, safeNumColors + (floor > 5 ? 1 : 0))).map(c => c.key);
            
            const colors = [];
            let colorFailsafe = 0;
            while (colors.length < safeNumColors) {
                const c = pick(pool);
                if (!colors.includes(c)) colors.push(c);
                colorFailsafe++;
                if (colorFailsafe > 100) break;
            }

            const tubes = Array.from({ length: gameState.tubeCount }, () => []);
            for (let i = 0; i < colors.length; i++) {
                for (let j = 0; j < gameState.capacity; j++) {
                    tubes[i].push(colors[i]);
                }
            }

            let shuffleMoves = 0;
            const targetMoves = gameState.capacity * colors.length * 8; 
            let failsafe = 0;

            while (shuffleMoves < targetMoves && failsafe < 4000) {
                failsafe++;
                const fromIdx = randInt(gameState.tubeCount);
                const toIdx = randInt(gameState.tubeCount);
                if (fromIdx === toIdx) continue;
                const fromTube = tubes[fromIdx], toTube = tubes[toIdx];
                if (fromTube.length === 0 || toTube.length >= gameState.capacity) continue;
                const color = fromTube[fromTube.length - 1];
                let sameColorCount = 0;
                for (let i = fromTube.length - 1; i >= 0; i--) {
                    if (fromTube[i] === color) sameColorCount++; else break;
                }
                const moveAmount = 1 + randInt(Math.min(sameColorCount, gameState.capacity - toTube.length));
                for (let m = 0; m < moveAmount; m++) toTube.push(fromTube.pop());
                shuffleMoves++;
            }

            const emptyTubeTargetCount = 2;
            const emptyIndices = [];
            for (let i = gameState.tubeCount - emptyTubeTargetCount; i < gameState.tubeCount; i++) emptyIndices.push(i);

            emptyIndices.forEach(targetIdx => {
                while (tubes[targetIdx].length > 0) {
                    const color = tubes[targetIdx].pop();
                    let placed = false;
                    const checkOrder = Array.from({ length: gameState.tubeCount }, (_, i) => i).sort(() => Math.random() - 0.5);
                    for (let i of checkOrder) {
                        if (emptyIndices.includes(i)) continue;
                        if (tubes[i].length < gameState.capacity) { tubes[i].push(color); placed = true; break; }
                    }
                    if (!placed) { tubes[targetIdx].push(color); break; }
                }
            });

            const boardCounts = {};
            tubes.forEach(t => t.forEach(c => boardCounts[c] = (boardCounts[c] || 0) + 1));
            for (let i = 0; i < tubes.length; i++) {
                if (tubes[i].length === 0) continue;
                let attempts = 0;
                // ÈÄöÂ∏∏Ëâ≤„ÅÆ„ÅøÂàùÊúüÈÖçÁΩÆ„ÅßÂÆåÊàê„Åó„Å™„ÅÑ„Çà„ÅÜ„Å´Â¥©„Åô
                while (isCompleteTube(tubes[i], boardCounts) && tubes[i][0] !== 'K' && attempts < 50) {
                    attempts++;
                    const targetIdx = randInt(gameState.tubeCount);
                    if (targetIdx !== i && tubes[targetIdx].length < gameState.capacity) {
                        tubes[targetIdx].push(tubes[i].pop());
                    }
                }
            }
            gameState.tubes = tubes;
            updateTubeLayout();
        }
        function updateTubeLayout(){
            const cap = gameState.capacity;
            let segHeight = 45; 
            if(cap >= 8) segHeight = 38;
            else if(cap >= 6) segHeight = 40;
            else if(cap >= 5) segHeight = 42;
            const tubeHeight = (segHeight * cap) + 40;
            document.documentElement.style.setProperty('--segment-height', `${segHeight}px`);
            document.documentElement.style.setProperty('--tube-height', `${tubeHeight}px`);
        }
        const CLONE_PADDING = 10; 
        function renderBoard(resetScroll = false){
            const slider = document.getElementById('board-scroll-area');
            const currentScrollPos = slider ? slider.scrollLeft : 0;
            const deadlocked = isDeadlocked();
            if (alertBanner) {
                if (deadlocked) {
                    alertBanner.textContent = currentLang === 'ja' ? '1„Å§„ÇÇÂãï„Åã„Åõ„Å™„ÅÑ...' : 'NO MOVES LEFT';
                    alertBanner.style.opacity = '1';
                } else {
                    alertBanner.style.opacity = '0';
                }
            }
            const counts = getBoardCounts();
            const totalTubes = gameState.tubes.length;
            if (totalTubes === 0) return;
            const renderList = [];
            for(let i = 0; i < CLONE_PADDING; i++) {
                let idx = (totalTubes - CLONE_PADDING + i) % totalTubes;
                if (idx < 0) idx += totalTubes;
                renderList.push({ idx: idx, isClone: true, key: `clone-pre-${i}` });
            }
            for(let i = 0; i < totalTubes; i++) renderList.push({ idx: i, isClone: false, key: `real-${i}` });
            for(let i = 0; i < CLONE_PADDING; i++) {
                const idx = i % totalTubes; 
                renderList.push({ idx: idx, isClone: true, key: `clone-post-${i}` });
            }
            const existingTubes = Array.from(tubesContainer.children);
            const existingMap = new Map();
            existingTubes.forEach(el => {
                if (el.dataset.renderKey) existingMap.set(el.dataset.renderKey, el);
            });
            const newlyCompleted = new Set();
            const processedKeys = new Set();
            renderList.forEach((item, loopIndex) => {
                const i = item.idx;
                const segments = gameState.tubes[i];
                if (!segments) return;
                processedKeys.add(item.key);
                let tube = existingMap.get(item.key);
                if (!tube) {
                    tube = document.createElement('div');
                    tube.className = 'tube';
                    const cap = document.createElement('div');
                    cap.className = 'tube-cap';
                    tube.appendChild(cap);
                    const water = document.createElement('div');
                    water.className = 'water-container';
                    tube.appendChild(water);
                }
                tube.onclick = (e) => {
                    if(isDragging) return;
                    handleTubeClick(item.idx); 
                };
                if (item.isClone) {
                    tube.classList.add('is-clone');
                } else {
                    tube.classList.remove('is-clone');
                }
                const currentChildAtPos = tubesContainer.children[loopIndex];
                if (currentChildAtPos !== tube) {
                    tubesContainer.insertBefore(tube, currentChildAtPos);
                }
                tube.dataset.idx = String(i);
                tube.dataset.renderKey = item.key;
                const setClass = (cls, on) => on ? tube.classList.add(cls) : tube.classList.remove(cls);
                setClass('clone-tube', item.isClone); // Êóß„ÇØ„É©„Çπ„ÇÇÂøµ„ÅÆ„Åü„ÇÅÁ∂≠ÊåÅ
                setClass('selected', i === gameState.selectedIdx);
                setClass('tube-focused', gameState.focusIdx !== null && i === gameState.focusIdx);
                setClass('deadlock-glow', deadlocked);
                const isCompletedNow = (segments.length > 0 && segments[0] !== 'K' && isCompleteTube(segments, counts));
                if (isCompletedNow) {
                    if (gameState.completedFlags[i]) {
                        tube.classList.add('capped');
                    } else {
                        newlyCompleted.add(i);
                    }
                    tube.style.boxShadow = `0 0 20px ${colorMeta(segments[0]).hex}`;
                    tube.style.borderColor = `rgba(255,255,255,0.8)`;
                } else {
                    gameState.completedFlags[i] = false;
                    tube.classList.remove('capped');
                    tube.style.boxShadow = '';
                    tube.style.borderColor = '';
                }
                const isTwoStepSkill = ['extractor', 'transfer', 'quantum_pipette'].includes(gameState.targetMode);
                let isTarget = false;
                if (isTwoStepSkill && gameState.extractorHeldColor) {
                    isTarget = segments.length < gameState.capacity;
                } else if (gameState.targetMode) {
                    isTarget = !(gameState.targetMode === 'extractor' && segments.length === 0);
                }
                setClass('target-mode', isTarget);
                setClass('source-mode', gameState.targetMode === 'extractor' && segments.length > 0);
                const water = tube.querySelector('.water-container');
                const currentStateStr = JSON.stringify(segments);
                if (water.dataset.lastState !== currentStateStr) {
                    water.innerHTML = '';
                    segments.forEach(key => {
                        const c = colorMeta(key)?.hex || '#64748b';
                        const seg = document.createElement('div');
                        seg.className = 'water-segment';
                        if (key === 'K') {
                            seg.classList.add('void-ink');
                        } else {
                            seg.style.backgroundColor = c;
                        }
                        water.appendChild(seg);
                    });
                    water.dataset.lastState = currentStateStr;
                }
            });
            while (tubesContainer.children.length > renderList.length) {
                tubesContainer.lastChild.remove();
            }
            if (newlyCompleted.size > 0) {
                setTimeout(() => {
                    newlyCompleted.forEach(idx => {
                        const targets = document.querySelectorAll(`.tube[data-idx="${idx}"]`);
                        targets.forEach(t => t.classList.add('capped'));
                        gameState.completedFlags[idx] = true;
                    });
                }, 100);
            }
            renderSkills();
            requestAnimationFrame(() => {
                adjustBoardScale();
                if (resetScroll) {
                    initInfiniteScroll();
                } else {
                    if(slider) slider.scrollLeft = currentScrollPos;
                }
            });
        }
        function adjustBoardScale() {
            if (!boardArea || !tubesContainer) return;
            tubesContainer.style.transform = 'none';
                const availableH = boardArea.clientHeight;
            const contentH = tubesContainer.scrollHeight;
            const targetH = availableH * 0.95; 
                let scale = targetH / contentH;
            scale = Math.min(Math.max(scale, 0.3), 1.5);
                tubesContainer.style.transform = `scale(${scale})`;
        }
        window.addEventListener('resize', () => {
            requestAnimationFrame(adjustBoardScale);
        });
        function renderSkills(){
            skillsContainer.innerHTML = '';
                const isHoldingColor = gameState.extractorHeldColor !== null;
            Object.keys(gameState.inventory).forEach(key => {
                const count = gameState.inventory[key];
                if(count > 0 || ITEMS[key].type === 'tool'){
                    const def = ITEMS[key];
                    const btn = document.createElement('button');
                                            const isCurrentActiveTool = (key === 'pipette' && gameState.pipetteMode) || (gameState.targetMode === key);
                    btn.disabled = isHoldingColor && !isCurrentActiveTool;
                    btn.className = 'skill-btn w-12 h-12 glass-panel flex items-center justify-center text-xl rounded-full border border-white/10 shrink-0';
                    if (btn.disabled) {
                        btn.classList.add('opacity-20', 'grayscale', 'pointer-events-none');
                    }
                    btn.dataset.id = key; 
                    const name = currentLang==='ja' ? def.name.ja : def.name.en;
                    const desc = currentLang==='ja' ? def.desc.ja : def.desc.en;
                    let badgeHtml = '';
                    if(def.type === 'consumable'){
                        badgeHtml = `<span class="absolute -top-1 -right-1 bg-sky-500 text-[10px] font-bold px-1.5 rounded-full text-white pointer-events-none">${count}</span>`;
                    }
                    btn.innerHTML = `${def.icon}${badgeHtml}`;
                    if (key === 'pipette' && gameState.pipetteMode) btn.classList.add('active');
                    if (gameState.pendingSkill === key) btn.classList.add('pending');
                    if (gameState.targetMode === key) btn.classList.add('active-mode');
                                if (['extractor', 'transfer', 'quantum_pipette'].includes(gameState.targetMode) && key === gameState.targetMode) {
                        if(gameState.extractorHeldColor) {
                            btn.classList.add('extracting');
                            btn.innerHTML = `<div style="width:16px;height:16px;border-radius:50%;background:${colorMeta(gameState.extractorHeldColor).hex};border:2px solid white;"></div>` + badgeHtml;
                        } else {
                            btn.classList.add('active-mode');
                        }
                    }
                                btn.onclick = () => activateSkill(key);
                    btn.onmouseenter = () => showGlobalTooltip(btn, name, desc);
                    btn.onmouseleave = () => {
                        if(gameState.pendingSkill){
                           const pBtn = document.querySelector(`.skill-btn[data-id="${gameState.pendingSkill}"]`);
                           if(pBtn) {
                               const pDef = ITEMS[gameState.pendingSkill];
                               const pName = currentLang==='ja' ? pDef.name.ja : pDef.name.en;
                               const pDesc = currentLang==='ja' ? pDef.desc.ja : pDef.desc.en;
                               showGlobalTooltip(pBtn, pName, pDesc);
                               return;
                           }
                        }
                        hideGlobalTooltip();
                    };
                    skillsContainer.appendChild(btn);
                }
            });
        }
        function activateSkill(key){
            if(gameState.busy) return;
                    if (gameState.extractorHeldColor !== null) {
                showToast(currentLang==='ja'?'ÈÖçÁΩÆ„ÇíÂÆå‰∫Ü„Åï„Åõ„Å¶„Åè„Å†„Åï„ÅÑ':'Finish placing the color first', 'rose');
                return;
            }
            const def = ITEMS[key];
                    if (gameState.pendingSkill === key) {
                gameState.pendingSkill = null; 
                hideGlobalTooltip();
                                if(key === 'heal' || key === 'panacea'){
                     if(gameState.inventory[key] > 0){
                         if(gameState.hp >= gameState.maxHp){
                             showToast(currentLang==='ja'?'HP„ÅØÊ∫Ä„Çø„É≥„Åß„Åô':'HP is full', 'yellow');
                             return; 
                         }
                         gameState.inventory[key]--;
                         const healAmount = (key === 'panacea') ? 2 : 1;
                         gameState.hp = Math.min(gameState.maxHp, gameState.hp + healAmount);
                         saveGame();
                         renderHUD();
                         showToast(currentLang==='ja'?'HPÂõûÂæ©ÔºÅ':'HP Restored!', 'emerald');
                     }
                     return;
                }
                if(key === 'summon_vial'){
                     if(gameState.inventory[key] > 0){
                         gameState.inventory[key]--;
                         gameState.tubeCount++;
                         gameState.tubes.push([]);
                         saveGame();
                         renderBoard();
                         showToast(currentLang==='ja'?'Á©∫„ÅçÁì∂„ÇíËøΩÂä†ÔºÅ':'Extra Tube Added!', 'purple');
                     }
                     return;
                }
                if(key === 'sedative'){
                     if(gameState.inventory[key] > 0){
                         gameState.inventory[key]--;
                         gameState.pressure = 0;
                         saveGame();
                         renderHUD();
                         showToast("Sedative Active!", 'purple');
                     }
                     return;
                }
                                if(def.type === 'tool' && key === 'pipette'){
                    gameState.pipetteMode = !gameState.pipetteMode;
                    gameState.targetMode = null; 
                } else if (def.type === 'consumable'){
                    gameState.targetMode = key;
                    gameState.pipetteMode = false;
                    showToast(currentLang==='ja' ? "ÂØæË±°„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ" : "Select target", 'sky');
                }
                        renderSkills();
                renderBoard();
                return;
            }
                gameState.pendingSkill = key;
            gameState.targetMode = null; 
            showToast(currentLang==='ja'?'„ÇÇ„ÅÜ‰∏ÄÂ∫¶„Çø„ÉÉ„Éó„Åó„Å¶‰ΩøÁî®':'Tap again to use', 'yellow');
                renderSkills();
            renderBoard();
        }
        function cancelInteraction() {
            if (!gameState.extractorHeldColor || gameState.extractorSourceIdx === null) return;
            const srcIdx = gameState.extractorSourceIdx;
            const color = gameState.extractorHeldColor;
            const skillKey = gameState.targetMode;
            if (skillKey === 'quantum_pipette' || gameState.pipetteMode) {
                gameState.tubes[srcIdx].unshift(color);
            } else {
                gameState.tubes[srcIdx].push(color);
            }
            gameState.extractorHeldColor = null;
            gameState.extractorSourceIdx = null;
            gameState.busy = false;
            showToast(currentLang === 'ja' ? '„Ç≠„É£„É≥„Çª„É´' : 'Canceled', 'sky');
            renderHUD();
            renderBoard();
        }
        function saveHistory() { pushHistory(); }
        async function handleTubeClick(idx) {
            if (gameState.busy) return;
            if (gameState.extractorHeldColor !== null && gameState.extractorSourceIdx === idx) {
                const tube = gameState.tubes[idx];
                const skillKey = gameState.targetMode;
                const isTwoStep = (skillKey === 'transfer' || skillKey === 'quantum_pipette' || gameState.pipetteMode);
                if (isTwoStep) {
                    if (tubeFree(tube) <= 0) {
                        showFloatText(idx, "Full!", "#ef4444");
                        return;
                    }
                    pushHistory();
                    tube.push(gameState.extractorHeldColor);
                    gameState.extractorHeldColor = null;
                    gameState.extractorSourceIdx = null;
                    if (gameState.pipetteMode) {
                        gameState.pipetteMode = false;
                        if(gameState.inventory['pipette'] > 0) gameState.inventory['pipette']--;
                    } else if (gameState.inventory[skillKey] > 0) {
                        let consume = true;
                        if(hasPerk('recycler')) {
                            const lv = getPerkLevel('recycler');
                            if(Math.random() < lv * 0.1) {
                                consume = false;
                                showToast("Recycled!", 'purple');
                            }
                        }
                        if(consume) gameState.inventory[skillKey]--;
                        gameState.targetMode = null;
                    }
                    showFloatText(idx, "Placed!", "#22c55e");
                    saveGame();
                    renderHUD();
                    renderBoard();
                    const counts = getBoardCounts();
                    if(isCompleteTube(tube, counts)) await handleCompletion(idx, tube[0]);
                    renderSkills();
                    return;
                } else {
                    cancelInteraction();
                    return;
                }
            }
            if (gameState.pendingSkill !== null) {
                gameState.pendingSkill = null;
                renderSkills();
            }
            if (['extractor', 'transfer', 'quantum_pipette'].includes(gameState.targetMode)) {
                await handleTwoStepSkill(idx);
                renderSkills();
                return;
            }
            if (gameState.pipetteMode) {
                const tube = gameState.tubes[idx];
                if (!gameState.extractorHeldColor) {
                    if (tube.length === 0) return;
                    const color = tube.shift();
                    gameState.extractorHeldColor = color;
                    gameState.extractorSourceIdx = idx;
                    showToast(currentLang === 'ja' ? 'ÊäΩÂá∫ÂÆå‰∫ÜÔºöÈÖçÁΩÆÂÖà„ÇíÈÅ∏Êäû' : 'Extracted: Select Target', 'emerald');
                    renderSkills();
                    renderBoard();
                } else {
                    if (tube.length >= gameState.capacity) {
                        showFloatText(idx, "Full!", "#ef4444");
                        return;
                    }
                    pushHistory();
                    tube.push(gameState.extractorHeldColor);
                    gameState.extractorHeldColor = null;
                    gameState.extractorSourceIdx = null;
                    gameState.pipetteMode = false;
                    if(gameState.inventory['pipette'] > 0) gameState.inventory['pipette']--;
                    renderHUD();
                    renderBoard();
                    saveGame();
                    const counts = getBoardCounts();
                    if(isCompleteTube(tube, counts)) await handleCompletion(idx, tube[0]);
                    renderSkills();
                }
                return;
            }
            if (gameState.targetMode) {
                await applySkillEffect(idx);
                return;
            }
            const content = gameState.tubes[idx];
            if (gameState.selectedIdx === idx) {
                gameState.selectedIdx = null;
                renderBoard();
                return;
            }
            if (gameState.selectedIdx === null) {
                const counts = getBoardCounts();
                if (content.length === 0) return;
                if (isCompleteTube(content, counts)) return;
                gameState.selectedIdx = idx;
                renderBoard();
            } else {
                await tryPour(gameState.selectedIdx, idx);
            }
        }
        async function tryPour(fromIdx, toIdx) {
            const check = canPour(fromIdx, toIdx);
            if (!check.ok) {
                const content = gameState.tubes[toIdx];
                const counts = getBoardCounts();
                gameState.selectedIdx = (content.length > 0 && !isCompleteTube(content, counts)) ? toIdx : null;
                renderBoard(); 
                return;
            }

            gameState.busy = true;

            try {
                pushHistory();
                
                let pressureImmune = false;
                if (hasPerk('steady_hand') && gameState.turnCount < getPerkLevel('steady_hand') * 3) pressureImmune = true;
                if (gameState.momentumTurns > 0) { gameState.momentumTurns--; pressureImmune = true; }
                
                let isOverloaded = false;
                if (!pressureImmune) {
                    isOverloaded = addPressure(1);
                }
                
                gameState.turnCount += 1;
                await animatePour(fromIdx, toIdx, check.color, check.moveCount);
                
                const from = gameState.tubes[fromIdx], to = gameState.tubes[toIdx];
                for (let i = 0; i < check.moveCount; i++) to.push(from.pop());
                
                const counts = getBoardCounts();
                // Ê≥®„ÅÑ„Å†Âæå„ÅÆ„ÉÅ„É•„Éº„Éñ„ÇíÂç≥Â∫ß„Å´Âà§ÂÆö
                if (isCompleteTube(to, counts)) {
                    await handleCompletion(toIdx, to[0]);
                } else if (gameState.secondaryGoal?.type === 'combo') {
                    gameState.secondaryProgress = 0;
                }

                if (isOverloaded) {
                    applyPressureDamage(false);
                    await new Promise(r => setTimeout(r, 600));
                }

                saveGame();
            } catch (e) {
                console.error("Pour logic error:", e);
            } finally {
                gameState.selectedIdx = null;
                gameState.busy = false;
                renderHUD();
                renderBoard();

                if (gameState.hp <= 0) {
                    clearSave(); 
                    openPerkScreen(true);
                } else if (checkLevelClear()) {
                    onLevelClear();
                }
            }
        }
        async function handleTwoStepSkill(idx) {
            const tube = gameState.tubes[idx];
            const skillKey = gameState.targetMode;
            if (!gameState.extractorHeldColor) {
                if (tube.length === 0) {
                    showFloatText(idx, "Empty!", "#ef4444");
                    return;
                }
                gameState.busy = true;
                let color;
                if(skillKey === 'quantum_pipette'){
                    color = tube.shift(); 
                } else {
                    color = tube.pop();    
                }
                gameState.extractorHeldColor = color;
                gameState.extractorSourceIdx = idx;
                showFloatText(idx, "Extracted!", "#22c55e");
                renderBoard(); 
                gameState.busy = false;
                showToast(currentLang==='ja' ? "ÈÖçÁΩÆÂÖà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ" : "Select destination", 'emerald');
            } 
            else {
                const canIgnoreColor = (skillKey === 'transfer' || skillKey === 'quantum_pipette');
                if (!canIgnoreColor && tube.length > 0 && tube[tube.length-1] !== gameState.extractorHeldColor) {
                    showFloatText(idx, "Mismatch!", "#ef4444");
                    return;
                }
                if (tubeFree(tube) <= 0) {
                    showFloatText(idx, "Full!", "#ef4444");
                    return;
                }
                pushHistory();
                gameState.busy = true;
                tube.push(gameState.extractorHeldColor);
                const heldColor = gameState.extractorHeldColor; // ÂÆåÊàê„ÉÅ„Çß„ÉÉ„ÇØÁî®„Å´‰øùÊåÅ
                gameState.extractorHeldColor = null;
                gameState.extractorSourceIdx = null;
                if (gameState.inventory[skillKey] > 0) {
                    let consume = true;
                    if(hasPerk('recycler')){
                        const lv = getPerkLevel('recycler');
                        if(Math.random() < lv * 0.1){
                            consume = false;
                            showToast("Recycled!", 'purple');
                        }
                    }
                    if(consume) gameState.inventory[skillKey]--;
                }
                gameState.targetMode = null; 
                showFloatText(idx, "Placed!", "#22c55e");
                renderBoard();
                const counts = getBoardCounts();
                if(isCompleteTube(tube, counts)){
                    await handleCompletion(idx, heldColor);
                }
                gameState.busy = false;
                saveGame();
                renderHUD();
                renderBoard();
                renderSkills();
                if (checkLevelClear()) {
                    onLevelClear();
                }
            }
        }
        async function applySkillEffect(idx){
            const skillKey = gameState.targetMode;
            const tube = gameState.tubes[idx];
            if(!skillKey || !gameState.inventory[skillKey] || gameState.inventory[skillKey] <= 0) return;
            let success = false;
            let consume = true;
            if(hasPerk('recycler')){
                const lv = getPerkLevel('recycler');
                if(Math.random() < lv * 0.1) consume = false;
            }
            gameState.busy = true;
            try {
                if(skillKey === 'inverter'){
                    if(tube.length < 2) showFloatText(idx, "Too Empty!", "#ef4444");
                    else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        tube.reverse(); showFloatText(idx, "Inverted!", "#a855f7"); success = true;
                    }
                } else if (skillKey === 'void_salt'){
                    if(tube.length === 0) showFloatText(idx, "Empty!", "#ef4444");
                    else {
                        if(tube[tube.length-1] !== 'K') showFloatText(idx, "Not Black!", "#ef4444");
                        else {
                            pushHistory(); if(consume) gameState.inventory[skillKey]--;
                            tube.pop(); showFloatText(idx, "Voided!", "#a855f7"); success = true;
                        }
                    }
                } else if (skillKey === 'separator'){
                    if(tube.length < 2) showFloatText(idx, "No need!", "#ef4444");
                    else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        const counts = {}; tube.forEach(c => counts[c] = (counts[c]||0)+1);
                        const newTube = []; Object.keys(counts).sort().forEach(c => { for(let i=0; i<counts[c]; i++) newTube.push(c); });
                        gameState.tubes[idx] = newTube; showFloatText(idx, "Separated!", "#a855f7"); success = true;
                    }
                } else if (skillKey === 'cycle_siphon'){
                     if(tube.length === 0) showFloatText(idx, "Empty!", "#ef4444");
                     else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        const bottom = tube.shift(); tube.push(bottom);
                        showFloatText(idx, "Cycled!", "#a855f7"); success = true;
                     }
                } else if (skillKey === 'sediment'){ 
                     if(tube.length < 2) showFloatText(idx, "No need!", "#ef4444");
                     else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        const top = tube.pop(); tube.unshift(top); 
                        showFloatText(idx, "Sunk!", "#a855f7"); success = true;
                     }
                } else if (skillKey === 'layer_swap'){ 
                    if(tube.length < 2) showFloatText(idx, "Need 2+", "#ef4444");
                    else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        const t1 = tube[tube.length-1]; const t2 = tube[tube.length-2];
                        tube[tube.length-1] = t2; tube[tube.length-2] = t1;
                        showFloatText(idx, "Swapped!", "#a855f7"); success = true;
                    }
                } else if (skillKey === 'vacuum'){ 
                    if(tube.length === 0) showFloatText(idx, "Empty!", "#ef4444");
                    else if(tube[tube.length-1] !== 'K') showFloatText(idx, "Obsidian Only!", "#ef4444");
                    else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        while(tube.length > 0 && tube[tube.length-1] === 'K') tube.pop();
                        showFloatText(idx, "Vacuumed!", "#a855f7"); success = true;
                    }
                } else if (skillKey === 'midas'){ 
                    if(tube.length === 0) showFloatText(idx, "Empty!", "#ef4444");
                    else if(tube[tube.length-1] !== 'K') showFloatText(idx, "Obsidian Only!", "#ef4444");
                    else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        tube.pop(); gameState.essence += 2; 
                        showFloatText(idx, "Transmuted! (‚ú®+2)", "#fbbf24"); success = true;
                    }
                } else if (skillKey === 'shaker'){
                    if(tube.length < 2) showFloatText(idx, "No need!", "#ef4444");
                    else {
                        const original = JSON.stringify(tube);
                        const hasDiverseColors = new Set(tube).size > 1;
                        if (!hasDiverseColors) {
                            showFloatText(idx, "Same colors!", "#ef4444");
                        } else {
                            pushHistory(); if(consume) gameState.inventory[skillKey]--;
                            let failsafe = 0;
                            while(failsafe < 100) {
                                for (let i = tube.length - 1; i > 0; i--) { 
                                    const j = Math.floor(Math.random() * (i + 1)); 
                                    [tube[i], tube[j]] = [tube[j], tube[i]]; 
                                }
                                if(JSON.stringify(tube) !== original) break;
                                failsafe++;
                            }
                            showFloatText(idx, "Shaken!", "#a855f7"); success = true;
                        }
                    }
                } else if (skillKey === 'cursed_sludge'){ 
                    if(tube.length >= gameState.capacity) showFloatText(idx, "Full!", "#ef4444");
                    else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        tube.push('K'); showFloatText(idx, "Cursed!", "#0f172a"); success = true;
                    }
                } else if (skillKey === 'vaporizer'){
                    if(tube.length === 0) showFloatText(idx, "Empty!", "#ef4444");
                    else {
                        pushHistory(); if(consume) gameState.inventory[skillKey]--;
                        tube.pop(); showFloatText(idx, "Vaporized!", "#94a3b8"); success = true;
                    }
                }
            } catch(e) {
                console.error(e);
                gameState.busy = false;
            }
            if(success){
                gameState.targetMode = null; 
                renderHUD(); 
                renderBoard(); 
                saveGame();
                const counts = getBoardCounts();
                if(isCompleteTube(gameState.tubes[idx], counts)) {
                    await handleCompletion(idx, gameState.tubes[idx][0]);
                    renderHUD(); 
                    renderBoard();
                }
            }
            gameState.busy = false;
        }
        function canPour(fromIdx, toIdx){
            if (fromIdx === toIdx) return {ok:false};
            const from = gameState.tubes[fromIdx], to = gameState.tubes[toIdx];
            if (!from.length || tubeFree(to) <= 0) return {ok:false};
            const top = tubeTop(from), toTop = tubeTop(to);
            if (toTop && toTop !== top) return {ok:false};
            let count = 1;
            if(!gameState.pipetteMode) { for (let i=from.length-2;i>=0;i--) if (from[i] === top) count++; else break; }
            return {ok:true, color: top, moveCount: Math.min(count, tubeFree(to))};
        }
        function pushHistory(){
            gameState.history.push({
                tubes: deepCopy(gameState.tubes), 
                turnCount: gameState.turnCount, 
                pressure: gameState.pressure, 
                hp: gameState.hp,
                secondaryProgress: gameState.secondaryProgress, 
                catalystAvailable: gameState.catalystAvailable, 
                essence: gameState.essence,
                inventory: {...gameState.inventory}, 
                tubeCount: gameState.tubeCount, 
                capacity: gameState.capacity,
                momentumTurns: gameState.momentumTurns, 
                refluxUses: gameState.refluxUses,
                completedFlags: [...gameState.completedFlags] 
            });
            if (gameState.history.length > 50) gameState.history.shift();
        }
        async function handleCompletion(tubeIdx, colorKey) {
            // „ÇØ„É≠„Éº„É≥„ÇíÂê´„ÇÄ„Åô„Åπ„Å¶„ÅÆ„ÉÅ„É•„Éº„ÉñË¶ÅÁ¥†„ÇíÂèñÂæó
            const tubeEls = document.querySelectorAll(`.tube[data-idx="${tubeIdx}"]`);
            
            if (colorKey === 'K') {
                gameState.busy = true; 
                showFloatText(tubeIdx, "Purged!", "#94a3b8");
                
                if (hasPerk('purification')) {
                    const lv = getPerkLevel('purification');
                    gameState.pressure = Math.max(0, gameState.pressure - (2 + lv));
                    gameState.essence += (1 + lv);
                }

                // Ëí∏Áô∫„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÈñãÂßã
                tubeEls.forEach(el => {
                    el.classList.add('evaporating');
                });

                // CSS„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÅÆÂÆå‰∫Ü„ÇíÂæÖÊ©ü
                await new Promise(r => setTimeout(r, 800));

                // „Éá„Éº„Çø„ÅÆÂâäÈô§
                gameState.tubes[tubeIdx] = []; 
                gameState.completedFlags[tubeIdx] = false;
                
                // „ÇØ„É©„ÇπËß£Èô§„Å®„Ç≠„É£„ÉÉ„Ç∑„É•„ÇØ„É™„Ç¢
                tubeEls.forEach(el => {
                    el.classList.remove('evaporating');
                    const water = el.querySelector('.water-container');
                    if (water) delete water.dataset.lastState;
                });

                gameState.busy = false;
                renderHUD();
                renderBoard(); 
                if (checkLevelClear()) onLevelClear(); 
                return; 
            }

            // ÈÄöÂ∏∏Ëâ≤„ÅÆÂÆåÊàêÂá¶ÁêÜ
            renderBoard();
            if (hasPerk('catalyst') && gameState.catalystAvailable) {
                const lv = getPerkLevel('catalyst'); 
                gameState.pressure = Math.max(0, gameState.pressure - (4 + lv));
                gameState.catalystAvailable = false; 
            }
            if (hasPerk('efficiency') && Math.random() < getPerkLevel('efficiency') * 0.20) {
                gameState.essence += 1;
            }
            if (hasPerk('heavy_mastery') && gameState.capacity >= 5) {
                const lv = getPerkLevel('heavy_mastery'); 
                gameState.pressure = Math.max(0, gameState.pressure - (2 + lv));
            }
            if (hasPerk('momentum')) gameState.momentumTurns = getPerkLevel('momentum'); 
            
            checkSecondaryGoalOnComplete(); 
            renderHUD(); 
            saveGame(); 
            
            await showCompletionEvent(colorKey);
            renderHUD(); 
            renderBoard();
            
            if (checkLevelClear()) {
                onLevelClear();
            }
        }
        function countCompletedTubes(counts=null){
            if(!counts) counts = getBoardCounts();
            return gameState.tubes.filter(t => isCompleteTube(t, counts) && t[0] !== 'K').length;
        }
        function corruptRandomSegment() {
            const candidates = [];
            for (let i = 0; i < gameState.tubes.length; i++) {
                if (gameState.tubes[i].length < gameState.capacity) {
                    candidates.push(i);
                }
            }
            if (!candidates.length) return;
            const idx = pick(candidates);
            gameState.tubes[idx].push('K');
            showFloatText(idx, "CORRUPTED!", "#ef4444");
            renderBoard();
        }
        function showFloatText(tubeIdx, text, color = "#38bdf8") {
            // ÁîªÈù¢ÂÜÖ„ÅßÊúÄ„ÇÇ‰∏≠Â§Æ„Å´Ëøë„ÅÑ„ÄÅÊ≠£„Åó„ÅÑ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆ„ÉÅ„É•„Éº„Éñ„ÇíÂèñÂæó
            const targetEl = tubeCenterEl(tubeIdx);
            if (!targetEl) return;

            const rect = targetEl.getBoundingClientRect();
            const float = document.createElement('div');
            
            float.textContent = text;
            float.style.position = 'fixed';
            
            // „ÉÅ„É•„Éº„Éñ„ÅÆ‰∏≠Â§Æ„Å´ÈÖçÁΩÆ
            float.style.left = (rect.left + rect.width / 2) + 'px';
            float.style.top = rect.top + 'px';
            float.style.transform = 'translateX(-50%)'; // Ëá™Ë∫´„ÅÆÂπÖ„ÅÆÂçäÂàÜ„Å†„ÅëÂ∑¶„Å´„Åö„Çâ„Åó„Å¶‰∏≠Â§ÆÊèÉ„Åà
            
            float.style.color = color;
            float.style.fontWeight = 'black';
            float.style.fontSize = '18px'; // Â∞ë„ÅóÂ§ß„Åç„Åè„ÄÅÂ§™„Åè„Åó„Å¶Ë¶ñË™çÊÄßÂêë‰∏ä
            float.style.zIndex = '300'; // ‰ªñ„ÅÆUI„Çà„ÇäÂâçÈù¢„Å´
            float.style.pointerEvents = 'none';
            float.style.textShadow = '0 0 10px rgba(0,0,0,0.9), 0 2px 4px black';
            float.style.whiteSpace = 'nowrap';

            // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥: translateX(-50%)„ÇíÁ∂≠ÊåÅ„Åó„Å§„Å§‰∏äÊòá
            float.animate([
                { transform: 'translate(-50%, 0)', opacity: 1 },
                { transform: 'translate(-50%, -50px)', opacity: 0 }
            ], { 
                duration: 1200, 
                easing: 'cubic-bezier(0.2, 0.8, 0.2, 1)' 
            });

            document.body.appendChild(float);
            setTimeout(() => float.remove(), 1200);
        }
        function tubeCenterEl(idx) {
            const els = ui('tubes-container').querySelectorAll(`.tube[data-idx="${String(idx)}"]`);
            if (els.length === 0) return null;
            
            const slider = ui('board-scroll-area');
            const sliderRect = slider.getBoundingClientRect();
            const centerX = sliderRect.left + sliderRect.width / 2;

            let closest = els[0];
            let minDist = Infinity;

            els.forEach(el => {
                const rect = el.getBoundingClientRect();
                const elCenterX = rect.left + rect.width / 2;
                const dist = Math.abs(centerX - elCenterX);
                if (dist < minDist) {
                    minDist = dist;
                    closest = el;
                }
            });
            return closest;
        }
        function animatePour(fromIdx, toIdx, colorKey, count){
            return new Promise((resolve) => {
                const primaryFrom = tubeCenterEl(fromIdx);
                const primaryTo = tubeCenterEl(toIdx);
                if (!primaryFrom || !primaryTo){ resolve(); return; }
                const isRight = primaryTo.getBoundingClientRect().left > primaryFrom.getBoundingClientRect().left;
                const fromEls = document.querySelectorAll(`.tube[data-idx="${fromIdx}"]`);
                const toEls = document.querySelectorAll(`.tube[data-idx="${toIdx}"]`);
                fromEls.forEach(fromEl => {
                    const fromWater = fromEl.querySelector('.water-container');
                    const shrinkSegments = [];
                    for(let i=0; i<count; i++) {
                        if(fromWater.children.length > i) {
                            shrinkSegments.push(fromWater.children[fromWater.children.length - 1 - i]);
                        }
                    }
                    fromEl.style.transition = 'transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1)';
                    fromEl.style.transform = `translateY(-10px) rotate(${isRight ? 45 : -45}deg)`;
                    fromEl.style.zIndex = 50;
                    setTimeout(() => {
                        shrinkSegments.forEach(seg => { 
                            if(seg) { 
                                seg.style.height = '0px'; 
                                seg.style.opacity = '0'; 
                                seg.style.borderTop = 'none'; 
                            } 
                        });
                    }, 50);
                });
                setTimeout(() => {
                    toEls.forEach(toEl => {
                        const toWater = toEl.querySelector('.water-container');
                        for(let i=0; i<count; i++){
                            const newSeg = document.createElement('div'); 
                            newSeg.className = 'water-segment'; 
                            if (colorKey === 'K') {
                                newSeg.classList.add('void-ink');
                            }
                            newSeg.style.backgroundColor = colorMeta(colorKey).hex;
                            newSeg.style.height = '0px'; 
                            newSeg.style.opacity = '0.5'; 
                            toWater.appendChild(newSeg); 
                            void newSeg.offsetWidth;
                            newSeg.style.height = 'var(--segment-height)'; 
                            newSeg.style.opacity = '1';
                        }
                    });
                }, 50);
                setTimeout(() => { 
                    fromEls.forEach(fromEl => {
                        fromEl.style.transform = ''; 
                        fromEl.style.zIndex = ''; 
                    });
                    resolve(); 
                }, 400); 
            });
        }
        function showCompletionEvent(colorKey){
            return new Promise((resolve) => {
                const name = colorName(colorKey);
                const titleText = currentLang==='ja' ? `${name}„ÅÆÂÆâÂÆöÂåñ` : `${name} Stabilized`;
                const desc = currentLang==='ja' ? `${name}„ÇíÂÆåÊàê„Åï„Åõ„Åü„ÄÇ\nÊ∑±Ê∑µ„ÅåÂèçÂøú„Åó„Å¶„ÅÑ„Çã„ÄÇ` : `You completed ${name}.\nThe abyss reacts to your achievement.`;
                        const meta = colorMeta(colorKey);
                let iconHtml = meta ? `<span style="color:${meta.hex}; text-shadow:0 0 15px ${meta.hex}; margin-right:8px; font-size:1.1em;">‚ñ†</span>` : '';
                        ui('event-kicker').textContent = t('eventKicker');
                ui('event-title').innerHTML = iconHtml + titleText; 
                ui('event-desc').textContent = desc;
                const choices = buildEventChoices(colorKey); 
                eventChoices.innerHTML = '';
                choices.forEach(ch => {
                    const card = document.createElement('div');
                                card.className = 'glass-panel perk-card p-4 cursor-pointer hover:bg-white/5 border-l-4 border-l-sky-500 bg-slate-900/90';
                    card.innerHTML = `<div class="text-[16px] text-sky-300 uppercase tracking-[0.35em] mb-1">${ch.kicker}</div><div class="text-xl font-black text-white">${ch.title}</div><div class="text-slate-400 text-xs mt-2 leading-relaxed">${ch.desc}</div>`;
                    card.onclick = () => { ch.apply(); saveGame(); eventScreen.classList.add('hidden'); eventScreen.classList.remove('flex'); resolve(); };
                    eventChoices.appendChild(card);
                });
                eventScreen.classList.remove('hidden'); eventScreen.classList.add('flex');
            });
        }
        function buildEventChoices(colorKey){
            if (colorKey === 'B'){ 
                return [
                    { kicker: currentLang==='ja'?'ÊéíÂá∫':'Vent', title: currentLang==='ja'?'„Éó„É¨„ÉÉ„Ç∑„É£„Éº -4':'Pressure -4', desc: currentLang==='ja'?'ÂÆâÂÖ®„ÇíÁ¢∫‰øù„Åô„Çã':'Release built-up pressure.', apply(){ gameState.pressure = Math.max(0, gameState.pressure-4); } }, 
                    { kicker: currentLang==='ja'?'Áü•Ë≠ò':'Insight', title: currentLang==='ja'?'„Ç®„ÉÉ„Çª„É≥„Çπ +4':'Essence +4', desc: currentLang==='ja'?'„É™„Çπ„ÇØ„ÇíÂèñ„Å£„Å¶ÂØå„ÇíÂæó„Çã':'Gain currency for the shop.', apply(){ gameState.essence += 4; } }
                ]; 
            }
            if (colorKey === 'R'){ 
                return [
                    { 
                        kicker: currentLang==='ja'?'Ê¥ªÂäõ':'Vitality', 
                        title: currentLang==='ja'?'HP +1 / „Éó„É¨„ÉÉ„Ç∑„É£„Éº +3':'HP +1 / Pressure +3', 
                        desc: currentLang==='ja'?'ÂõûÂæ©„Åô„Çã„Åå„Éó„É¨„ÉÉ„Ç∑„É£„Éº„ÅåÂ¢ó„Åà„Çã':'Heal yourself, but strain the system.', 
                        apply(){
                            gameState.hp = Math.min(gameState.maxHp, gameState.hp + 1);
                            addPressure(3);
                        } 
                    }, 
                    { kicker: currentLang==='ja'?'Âπ≥Èùô':'Calm', title: currentLang==='ja'?'„Éó„É¨„ÉÉ„Ç∑„É£„Éº -6':'Pressure -6', desc: currentLang==='ja'?'ÂøÉ„ÇíËêΩ„Å°ÁùÄ„Åë„Çã':'Significantly reduce pressure.', apply(){ gameState.pressure = Math.max(0, gameState.pressure-6); } }
                ]; 
            }
            return [
                { kicker: currentLang==='ja'?'ÊµÑÂåñ':'Purify', title: currentLang==='ja'?'„Éó„É¨„ÉÉ„Ç∑„É£„Éº -2':'Pressure -2', desc: currentLang==='ja'?'Â∞ë„ÅóËêΩ„Å°ÁùÄ„Åè':'Minor relief.', apply(){ gameState.pressure = Math.max(0, gameState.pressure-2); } }, 
                { kicker: currentLang==='ja'?'Ë≤™Ê¨≤':'Greed', title: currentLang==='ja'?'„Ç®„ÉÉ„Çª„É≥„Çπ +3 / „Éó„É¨„ÉÉ„Ç∑„É£„Éº +1':'Essence +3 / Pressure +1', desc: currentLang==='ja'?'Â∞è„Åï„Å™‰ª£ÂÑü„ÅßÂØå„Çí':'Wealth at a cost.', apply(){ gameState.essence += 3; addPressure(1); } }
            ];
        }
        function rarityWeight(r){
        if(r === 'epic') return 0.45;
        if(r === 'rare') return 0.80;
        return 1.00;
        }
        function rollPerkChoices(count=3){
        const ids = Object.keys(PERKS);
        const f = clamp((gameState.floor - 1) / 10, 0, 1);
        const pool = ids.slice();
        const w = pool.map(id=>{
            const r = PERKS[id].rarity;
            let base = rarityWeight(r);
            if(r === 'rare') base += 0.15 * f;
            if(r === 'epic') base += 0.10 * f;
            if(getPerkLevel(id) === 0) base *= 1.10;
            return base;
        });
        const chosen = [];
        while(chosen.length < Math.min(count, pool.length)){
            const total = w.reduce((a,b)=>a+b,0);
            let r = Math.random() * total;
            let idx = 0;
            while(idx < w.length && (r -= w[idx]) > 0) idx++;
            idx = Math.min(idx, w.length-1);
            const perkId = pool[idx];
            chosen.push(PERKS[perkId]);
            pool.splice(idx,1);
            w.splice(idx,1);
        }
        return chosen;
        }
        function generateShopOffers(n=4){
        const entries = [];
        INSTANT_ITEMS.forEach(x => entries.push({kind:'instant', id:x.id}));
        Object.values(ITEMS).forEach(x => entries.push({kind:'item', id:x.id}));
        const pool = entries.slice();
        const picks = [];
        while(picks.length < Math.min(n, pool.length)){
            const p = pool.splice(randInt(pool.length),1)[0];
            picks.push({ ...p, purchased:false });
        }
        return picks;
        }
        function findInstant(id){
        return INSTANT_ITEMS.find(x => x.id === id) || null;
        }
        function refreshRerollUI(){
            if(rerollBtn) {
                const can = (gameState.rerollCoupons > 0) || (gameState.essence >= 5);
                rerollBtn.classList.toggle('hidden', !can);
                const rerollText = t('reroll');
                if(gameState.rerollCoupons > 0){
                    rerollBtn.textContent = `${rerollText} (Coupon x${gameState.rerollCoupons})`;
                }else{
                    rerollBtn.textContent = `${rerollText} (‚ú®5)`;
                }
                rerollBtn.classList.remove('text-[10px]');
                rerollBtn.classList.add('text-sm');
            }
            const pe = ui('perk-essence');
            if(pe) pe.textContent = `‚ú® ${gameState.essence}`;
            const phVal = ui('perk-hp-val');
            if(phVal) {
                phVal.textContent = `${gameState.hp} / ${gameState.maxHp}`;
            }
            const psText = ui('btn-status-perk-text');
            if(psText) {
                psText.textContent = t('statusBtn');
            }
        }
        ui('reroll-btn').onclick = () => {
            if(gameState.rerollCoupons > 0) {
                gameState.rerollCoupons--;
            } else if(gameState.essence >= 5) {
                gameState.essence -= 5;
            } else {
                return;
            }
            gameState.currentShopOffers = null;
            openPerkScreen(false);
            saveGame();
        };
        function buildShopCard(offer){
            let name='', desc='', icon='‚óà', baseCost=0;
            if(offer.kind === 'instant'){
                const inst = findInstant(offer.id);
                if(!inst) return document.createElement('div');
                name = currentLang==='ja' ? inst.name.ja : inst.name.en;
                desc = currentLang==='ja' ? inst.desc.ja : inst.desc.en;
                baseCost = inst.cost;
                icon = '‚ú¶';
            }else{
                const it = ITEMS[offer.id];
                if(!it) return document.createElement('div');
                name = currentLang==='ja' ? it.name.ja : it.name.en;
                desc = currentLang==='ja' ? it.desc.ja : it.desc.en;
                baseCost = it.cost;
                icon = it.icon;
            }
            const currentInventoryCount = gameState.inventory[offer.id] || 0;
            let badgeHtml = '';
            if(offer.kind === 'item' && currentInventoryCount > 0){
                badgeHtml = `<span class="badge-count absolute -top-1 sm:-top-2 -right-1 sm:-right-2 bg-sky-500 text-[10px] sm:text-xs font-bold px-1.5 sm:px-2 py-0.5 rounded-full text-white pointer-events-none shadow-sm z-10">${currentInventoryCount}</span>`;
            }
            const cost = getDiscountedCost(baseCost);
            const affordable = gameState.essence >= cost;
            const isTool = (offer.kind==='item' && ITEMS[offer.id]?.type==='tool');
            const allItemsMax = Object.keys(ITEMS)
                .filter(k => ITEMS[k].type === 'consumable')
                .every(k => (gameState.inventory[k] || 0) >= 3);
            const isAtMax = (offer.kind==='item' && !isTool && currentInventoryCount >= 3) || 
                            (offer.id === 'mystery_box' && allItemsMax);
            const ownedTool = (isTool && currentInventoryCount > 0);
            const disabled = !!offer.purchased || ownedTool || isAtMax || !affordable;
            const card = document.createElement('div');
            card.className = 'shop-card glass-panel perk-card p-3 sm:p-4 flex flex-col gap-2 sm:gap-3 h-full justify-between'; 
            card.dataset.cost = String(cost);
            let priceDisplay = `<div class="text-xl sm:text-2xl font-black text-yellow-400">${cost}</div>`;
            if (hasPerk('bargain') && cost !== baseCost) {
                priceDisplay = `
                    <div class="flex flex-col items-end leading-none">
                        <div class="text-[10px] text-slate-500 line-through decoration-slate-500">${baseCost}</div>
                        <div class="text-xl sm:text-2xl font-black text-yellow-400">${cost}</div>
                    </div>
                `;
            }
            let btnLabel = currentLang==='ja'?'Ë≥ºÂÖ•':'BUY';
            let btnColorClass = '';
            if(offer.purchased) btnLabel = currentLang==='ja'?'Ë≥ºÂÖ•Ê∏à':'BOUGHT';
            else if(ownedTool) btnLabel = currentLang==='ja'?'ÊâÄÊåÅÊ∏à':'OWNED';
            else if(isAtMax) {
                btnLabel = currentLang==='ja'?'ÊúÄÂ§ßÊï∞':'MAX';
                btnColorClass = 'text-rose-500';
            }
            card.innerHTML = `
                <div class="flex items-start justify-between gap-1 sm:gap-2">
                    <div class="flex items-center gap-2 sm:gap-3 min-w-0">
                        <div class="relative w-10 h-10 sm:w-14 sm:h-14 rounded-lg sm:rounded-xl glass-panel flex items-center justify-center text-xl sm:text-3xl shrink-0 border border-white/10 icon-box">
                            ${icon}
                            ${badgeHtml}
                        </div>
                        <div class="text-sm sm:text-lg font-black text-white leading-tight break-words">
                            ${name}
                        </div>
                    </div>
                    <div class="text-right shrink-0">
                        ${priceDisplay}
                    </div>
                </div>
                <div class="flex-1">
                    <p class="text-xs sm:text-base text-slate-300 leading-snug break-words italic">
                        ${desc}
                    </p>
                </div>
                <button class="shop-btn w-full py-2 sm:py-3 rounded-lg sm:rounded-xl font-black text-sm sm:text-lg uppercase tracking-widest border border-white/10 ${btnColorClass} ${disabled?'opacity-30 cursor-not-allowed':'hover:bg-white/10'}">
                    ${btnLabel}
                </button>
            `;
            const btn = card.querySelector('.shop-btn');
            btn.disabled = disabled;
            btn.onclick = () => {
                if(btn.disabled) return;
                const finalCost = getDiscountedCost(baseCost);
                if(gameState.essence < finalCost) return;
                if(offer.kind === 'instant'){
                    gameState.essence -= finalCost;
                    const inst = findInstant(offer.id);
                    if(inst && typeof inst.apply === 'function') inst.apply(gameState);
                    offer.purchased = true;
                } else {
                    const it = ITEMS[offer.id];
                    const currentCount = (gameState.inventory[offer.id] || 0);
                    if(it.type === 'tool') {
                        gameState.essence -= finalCost;
                        gameState.inventory[offer.id] = 1;
                        offer.purchased = true;
                    } else if (currentCount < 3) {
                        gameState.essence -= finalCost;
                        gameState.inventory[offer.id] = currentCount + 1;
                        const newCount = gameState.inventory[offer.id];
                        let badge = card.querySelector('.badge-count');
                        if (!badge) {
                            const iconBox = card.querySelector('.icon-box');
                            badge = document.createElement('span');
                            badge.className = 'badge-count absolute -top-1 sm:-top-2 -right-1 sm:-right-2 bg-sky-500 text-[10px] sm:text-xs font-bold px-1.5 sm:px-2 py-0.5 rounded-full text-white pointer-events-none shadow-sm z-10';
                            iconBox.appendChild(badge);
                        }
                        badge.textContent = newCount;
                        if (newCount >= 3) {
                            btn.textContent = currentLang==='ja'?'ÊúÄÂ§ßÊï∞':'MAX';
                            btn.classList.add('text-rose-500');
                            btn.disabled = true;
                            btn.classList.add('opacity-30', 'cursor-not-allowed');
                        }
                    }
                    showToast(currentLang==='ja'?'Ë≥ºÂÖ•„Åó„Åæ„Åó„Åü':'Purchased', 'yellow');
                }
                saveGame();
                refreshRerollUI();
                renderHUD();
                updateShopButtons();
                if (offer.purchased) {
                    btn.textContent = currentLang==='ja'?'Ë≥ºÂÖ•Ê∏à':'BOUGHT';
                    btn.disabled = true;
                    btn.classList.add('opacity-30', 'cursor-not-allowed');
                }
            };
            return card;
        }
        function generateShareText(){
        const perkList = Object.entries(gameState.perks || {})
            .filter(([_,lv]) => (lv||0)>0)
            .map(([id,lv]) => `${(currentLang==='ja'?PERKS[id].name.ja:PERKS[id].name.en)} Lv.${lv}`)
            .join(', ');
        return `Abyss Alchemy | FLOOR ${gameState.floor} | ESSENCE ${gameState.essence} | ${perkList || 'No Mutations'}`;
        }
        function copyResult(){
        const ta = ui('share-text-area');
        if(!ta) return;
        const txt = ta.value;
        if(navigator.clipboard?.writeText){
            navigator.clipboard.writeText(txt).then(
            ()=>showToast(currentLang==='ja'?'„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü':'Copied', 'emerald'),
            ()=>{ document.execCommand('copy'); showToast(currentLang==='ja'?'„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü':'Copied', 'emerald'); }
            );
        }else{
            ta.select();
            document.execCommand('copy');
            showToast(currentLang==='ja'?'„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü':'Copied', 'emerald');
        }
        }
        function openMutationsScreen() {
            const sum = ui('mutations-stats-summary');
            const list = ui('mutations-list-container');
            let itemsContainer = ui('mutations-items-container');
            if (!itemsContainer) {
                const parent = list.parentElement;
                const wrapper = document.createElement('div');
                wrapper.innerHTML = `
                    <div class="mt-6">
                        <div class="text-[10px] text-slate-500 uppercase tracking-widest mb-3" id="ui-inventory-label">Inventory</div>
                        <div id="mutations-items-container" class="grid grid-cols-2 gap-3"></div>
                    </div>
                `;
                parent.appendChild(wrapper);
                itemsContainer = ui('mutations-items-container');
                const lbl = ui('ui-inventory-label');
                if (lbl) lbl.textContent = currentLang === 'ja' ? 'ÊâÄÊåÅ„Ç¢„Ç§„ÉÜ„É†' : 'Inventory';
            }
            if (!sum || !list) return;
            const totalLevels = Object.values(gameState.perks).reduce((a, b) => a + (b || 0), 0);
            const discount = hasPerk('bargain') ? (15 + getPerkLevel('bargain') * 5) : 0;
            sum.innerHTML = '';
            const stats = [
                { k: 'FLOOR', v: String(gameState.floor) },
                { k: 'HP', v: `${gameState.hp} / ${gameState.maxHp}` },
                { k: 'CAPACITY', v: String(gameState.capacity) },
                { k: 'TUBES', v: String(gameState.tubeCount) },
                { k: 'PRESSURE MAX', v: String(gameState.pressureMax) },
                { k: 'ESSENCE', v: `‚ú® ${gameState.essence}` },
                { k: 'ACTIVE BONUSES', v: String(totalLevels) },
                { k: 'SHOP DISCOUNT', v: `${discount}%` },
                { k: 'REROLL COUPON', v: String(gameState.rerollCoupons || 0) },
            ];
            stats.forEach(s => {
                const d = document.createElement('div');
                d.className = 'stat-item';
                d.innerHTML = `<div class="text-[10px] text-slate-500 uppercase tracking-widest">${s.k}</div><div class="text-lg font-black text-white">${s.v}</div>`;
                sum.appendChild(d);
            });
            list.innerHTML = '';
            const entries = Object.entries(gameState.perks || {}).filter(([_, lv]) => (lv || 0) > 0);
            const perkColorMap = {
                'crimson_resonance': 'R', 'azure_cycle': 'B', 'amber_greed': 'Y',
                'ivory_sanctuary': 'W', 'emerald_vitality': 'G', 'amethyst_surge': 'P',
                'orange_drive': 'O', 'teal_equilibrium': 'T', 'pink_luck': 'M',
                'purification': 'K'
            };
            if (entries.length === 0) {
                list.innerHTML = `<div class="text-slate-500 text-xs italic py-3">${currentLang === 'ja' ? '„Éú„Éº„Éä„Çπ„Å™„Åó' : 'No active bonuses'}</div>`;
            } else {
                entries
                    .sort((a, b) => b[1] - a[1])
                    .forEach(([id, lv]) => {
                        let colorIcon = '';
                        if (perkColorMap[id]) {
                            const cKey = perkColorMap[id];
                            const meta = COLOR_POOL.find(x => x.key === cKey);
                            if (meta) colorIcon = `<span style="color:${meta.hex}; text-shadow:0 0 5px ${meta.hex}; margin-right:4px;">‚ñ†</span>`;
                        }
                        const row = document.createElement('div');
                        row.className = 'glass-panel p-3 border border-white/10';
                        row.innerHTML = `
                        <div class="flex items-center justify-between">
                            <div class="text-sm font-black text-white">${colorIcon}${currentLang === 'ja' ? PERKS[id].name.ja : PERKS[id].name.en}</div>
                            <div class="text-xs font-black text-sky-300">Lv.${lv}</div>
                        </div>
                        <div class="text-[10px] text-slate-400 mt-1 leading-relaxed">${getPerkDesc(id, lv)}</div>
                        `;
                        list.appendChild(row);
                    });
            }
            itemsContainer.innerHTML = '';
            const inventoryKeys = Object.keys(gameState.inventory).filter(k => gameState.inventory[k] > 0);
            if (inventoryKeys.length === 0) {
                itemsContainer.innerHTML = `<div class="text-slate-500 text-xs italic py-3 col-span-2">${currentLang === 'ja' ? '„Ç¢„Ç§„ÉÜ„É†„Å™„Åó' : 'No items'}</div>`;
            } else {
                inventoryKeys.forEach(key => {
                    const count = gameState.inventory[key];
                    const item = ITEMS[key];
                    if (!item) return;
                    const name = currentLang === 'ja' ? item.name.ja : item.name.en;
                    const desc = currentLang === 'ja' ? item.desc.ja : item.desc.en;
                    const card = document.createElement('div');
                    card.className = 'glass-panel p-3 border border-white/10 flex flex-col gap-2 h-full';
                    card.innerHTML = `
                        <div class="flex items-start justify-between gap-2">
                            <div class="flex items-center gap-2 min-w-0">
                                <div class="relative w-10 h-10 rounded-lg glass-panel flex items-center justify-center text-xl border border-white/10 shrink-0">
                                    ${item.icon}
                                </div>
                                <div class="text-sm font-black text-white leading-tight break-words">
                                    ${name}
                                </div>
                            </div>
                            <div class="text-right shrink-0">
                                <span class="bg-sky-500 text-[10px] font-bold px-2 py-0.5 rounded-full text-white">x${count}</span>
                            </div>
                        </div>
                        <div class="flex-1">
                            <p class="text-[10px] text-slate-400 leading-snug break-words italic">
                                ${desc}
                            </p>
                        </div>
                    `;
                    itemsContainer.appendChild(card);
                });
            }
            mutationsScreen.classList.replace('hidden', 'flex');
        }
        function openPerkScreen(isDeath){
            perkScreen.classList.remove('hidden');
            ui('perk-title').textContent = isDeath ? t('gameOver') : t('victory');
            ui('perk-subtitle').textContent = isDeath ? t('gameOverSub') : t('victorySub');
            ui('perk-essence').textContent = `‚ú® Essence: ${gameState.essence}`;
                gameState.pendingPerkId = null;
            perkCards.innerHTML = ''; 
            shopCards.innerHTML = '';
                if(isDeath){
                perkCards.innerHTML = `<div class="flex flex-col gap-4 h-full"><div class="text-sm font-bold text-rose-400 uppercase tracking-widest border-b border-white/10 pb-2">${currentLang==='ja'?'Êé¢Á¥¢Ë®òÈå≤':'Exploration Log'}</div><div class="grid grid-cols-2 gap-4"><div class="glass-panel p-4 flex flex-col items-center justify-center bg-white/5"><div class="text-[10px] text-slate-400 uppercase tracking-widest">FLOOR</div><div class="text-4xl font-black text-white">${gameState.floor}</div></div><div class="glass-panel p-4 flex flex-col items-center justify-center bg-white/5"><div class="text-[10px] text-slate-400 uppercase tracking-widest">ESSENCE</div><div class="text-4xl font-black text-sky-300">${gameState.essence}</div></div></div><div class="mt-auto"><div class="text-[10px] text-slate-500 mb-2 uppercase tracking-widest">Result String</div><textarea id="share-text-area" class="w-full h-24 bg-black/50 border border-white/10 rounded p-2 text-[10px] text-slate-400 font-mono resize-none" readonly>${generateShareText()}</textarea></div></div>`;
                const perkList = Object.entries(gameState.perks).map(([id, lv]) => `<div class="flex justify-between items-center py-2 border-b border-white/5"><span class="text-sm font-bold text-slate-200">${currentLang==='ja'?PERKS[id].name.ja:PERKS[id].name.en}</span><span class="text-xs font-bold text-sky-400">Lv.${lv}</span></div>`).join('');
                shopCards.parentElement.className = "flex-1 flex flex-col p-4 md:p-6 overflow-y-auto"; shopCards.className = "flex flex-col gap-4 h-full";
                shopCards.innerHTML = `<div class="flex-1 overflow-y-auto min-h-[120px]"><div class="text-sm font-bold text-sky-400 uppercase tracking-widest border-b border-white/10 pb-2 mb-2">${currentLang==='ja'?'Áç≤Âæó„Åó„Åü„Çπ„Ç≠„É´':'Acquired Skills'}</div>${perkList || `<div class="text-slate-500 text-xs italic py-4">${currentLang==='ja'?'„Çπ„Ç≠„É´„Å™„Åó':'No mutations'}</div>`}</div><div class="grid grid-cols-2 gap-3 mt-4 shrink-0"><button onclick="copyResult()" class="py-4 bg-indigo-600 rounded-xl font-black text-white uppercase tracking-widest hover:bg-indigo-500 shadow-lg shadow-indigo-900/40 transform transition hover:-translate-y-1">${currentLang==='ja'?'ÁµêÊûú„Çí„Ç≥„Éî„Éº':'Copy Result'}</button><button onclick="startNewRun()" class="py-4 bg-rose-600 rounded-xl font-black text-white uppercase tracking-widest hover:bg-rose-500 shadow-lg shadow-rose-900/40 transform transition hover:-translate-y-1">${currentLang==='ja'?'„É™„Éà„É©„Ç§':'Try Again'}</button></div>`;
                continueBtn.style.display = 'none'; return;
            }
                continueBtn.style.display = 'block'; 
            continueBtn.textContent = t('continue');
            continueBtn.classList.add('opacity-50', 'cursor-not-allowed');
            continueBtn.onclick = () => { 
                if(!gameState.pendingPerkId) {
                    showToast(currentLang==='ja'?'„Çπ„Ç≠„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ':'Select a Mutation!', 'rose');
                    return;
                }
                acquirePerk(gameState.pendingPerkId);
                perkScreen.classList.add('hidden'); 
                nextFloor(); 
            };
                shopCards.parentElement.className = "flex-1 flex flex-col p-4 md:p-6 overflow-y-auto"; shopCards.className = "grid grid-cols-2 md:grid-cols-2 lg:grid-cols-2 gap-3";
            if (!gameState.currentPerkChoices) gameState.currentPerkChoices = rollPerkChoices();
            if (!gameState.currentShopOffers) gameState.currentShopOffers = generateShopOffers();
            gameState.currentPerkChoices.forEach(p => perkCards.appendChild(buildPerkCard(p))); refreshRerollUI();
            gameState.currentShopOffers.forEach(item => shopCards.appendChild(buildShopCard(item))); updateShopButtons();
            saveGame();
        }
        function buildPerkCard(perk){
            const card = document.createElement('div'), owned = getPerkLevel(perk.id), next = owned + 1;
            card.className = `perk-card glass-panel p-3 sm:p-4 cursor-pointer rarity-${perk.rarity} relative hover:bg-white/5 transition-all`;
            const perkColorMap = {
                'crimson_resonance': 'R', 'azure_cycle': 'B', 'amber_greed': 'Y',
                'ivory_sanctuary': 'W', 'emerald_vitality': 'G', 'amethyst_surge': 'P',
                'orange_drive': 'O', 'teal_equilibrium': 'T', 'pink_luck': 'M',
                'purification': 'K', 'void_shield': 'P'
            };
            let colorIcon = '';
            if(perkColorMap[perk.id]){
                const colorKey = perkColorMap[perk.id];
                const colorMeta = COLOR_POOL.find(c => c.key === colorKey);
                if(colorMeta){
                    colorIcon = `<span style="color:${colorMeta.hex}; text-shadow:0 0 8px ${colorMeta.hex}; margin-right:4px; font-size:1.2em;">‚ñ†</span>`;
                }
            }
            card.innerHTML = `
                <div class="flex justify-between items-center mb-2 gap-2">
                    <div class="text-lg sm:text-xl font-black text-white leading-tight truncate">
                        ${colorIcon}${currentLang==='ja'?perk.name.ja:perk.name.en} 
                        <span class="text-xs sm:text-sm text-slate-500 ml-1 font-medium">Lv.${owned}‚Üí${next}</span>
                    </div>
                    <span class="shrink-0 text-[10px] sm:text-xs ${owned>0?'text-emerald-400':'text-sky-400'} font-bold uppercase tracking-tighter">
                        ${owned>0?'UPGRADE':'NEW'}
                    </span>
                </div>
                <div class="text-sm sm:text-base text-slate-300 leading-relaxed">
                    ${getPerkDesc(perk.id, next)}
                </div>
            `;
            card.onclick = () => { 
                gameState.pendingPerkId = perk.id;
                Array.from(perkCards.children).forEach(c => { 
                    c.classList.remove('border-sky-500', 'bg-sky-500/20', 'ring-2', 'ring-sky-500');
                    c.classList.add('border-white/10');
                    c.style.opacity = '0.6';
                }); 
                card.style.opacity = '1'; 
                card.classList.remove('border-white/10');
                card.classList.add('border-sky-500', 'bg-sky-500/20', 'ring-2', 'ring-sky-500');
                continueBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            };
            return card;
        }
        function getDiscountedCost(base) { 
            if(hasPerk('bargain')) return Math.floor(base * (1 - (15+getPerkLevel('bargain')*5)/100)); 
            return base; 
        }
        function updateShopButtons() {
            document.querySelectorAll('.shop-card').forEach(card => {
                const btn = card.querySelector('.shop-btn'); if(btn.disabled && btn.textContent.includes('BOUGHT')) return;
                if(gameState.essence >= parseInt(card.dataset.cost)) { btn.classList.remove('opacity-30', 'cursor-not-allowed'); btn.classList.add('hover:bg-sky-500'); btn.style.pointerEvents = 'auto'; }
                else { btn.classList.add('opacity-30', 'cursor-not-allowed'); btn.classList.remove('hover:bg-sky-500'); }
            });
        }
        function acquirePerk(id){ if(!gameState.perks[id]) gameState.perks[id] = 0; gameState.perks[id]++; if(id === 'overflow') gameState.pressureMax += 4; renderHUD(); saveGame(); }
        function startNewRun(){ 
            clearSave(); 
            startScreen.classList.add('hidden'); 
            Object.assign(gameState, { 
                floor:1, 
                essence:0, 
                hp:3, 
                maxHp:3,
                capacity:4, 
                perks:{}, 
                pressure:0, 
                pressureMax:14, 
                history:[], 
                inventory:{}, 
                catalystAvailable:true, 
                refluxUses:0, 
                momentumTurns:0, 
                rerollCoupons:0 
            }); 
            perkScreen.classList.add('hidden'); 
            nextFloor(true); 
        }
        function nextFloor(isFirst=false){
            if(!isFirst) {
                gameState.floor++; 
                if (gameState.floor >= 8) gameState.capacity = 6; 
                else if (gameState.floor >= 4) gameState.capacity = 5; 
                else gameState.capacity = 4;
                if(hasPerk('scavenger') && Math.random() < (0.10 + getPerkLevel('scavenger')*0.05)) { 
                    const consumableKeys = Object.keys(ITEMS).filter(x => ITEMS[x].type === 'consumable');
                    const availableToPick = consumableKeys.filter(k => (gameState.inventory[k] || 0) < 3);
                    if (availableToPick.length > 0) {
                        const k = pick(availableToPick);
                        gameState.inventory[k] = (gameState.inventory[k] || 0) + 1; 
                        showToast(currentLang === 'ja' ? `${ITEMS[k].name.ja}„ÇíÊãæ„Å£„ÅüÔºÅ` : `Scavenged ${ITEMS[k].name.en}!`, 'emerald'); 
                    }
                }
                if(hasPerk('transmutation')) { 
                    for(let i=0; i<getPerkLevel('transmutation'); i++){ 
                        const consumableKeys = Object.keys(ITEMS).filter(x => ITEMS[x].type === 'consumable');
                        const availableToPick = consumableKeys.filter(k => (gameState.inventory[k] || 0) < 3);
                        if (availableToPick.length > 0) {
                            const k = pick(availableToPick);
                            gameState.inventory[k] = (gameState.inventory[k] || 0) + 1; 
                        }
                    } 
                }
                if(hasPerk('coupon')) gameState.rerollCoupons += getPerkLevel('coupon');
            }
            const baseMaxHp = 3; 
            let bonusHp = 0;
            if(hasPerk('deep_adapt') && gameState.capacity > 4){ 
                bonusHp = getPerkLevel('deep_adapt'); 
            }
            const oldMaxHp = gameState.maxHp;
            gameState.maxHp = baseMaxHp + bonusHp;
            if (gameState.maxHp > oldMaxHp) {
                gameState.hp += (gameState.maxHp - oldMaxHp);
            }
            gameState.hp = Math.min(gameState.hp, gameState.maxHp);
            const defaultPressureMax = 14; 
            const nextPressure = isFirst ? 0 : gameState.pressure;
            Object.assign(gameState, { 
                turnCount:0, 
                pressure: nextPressure, 
                pressureMax: defaultPressureMax, 
                catalystAvailable:true, 
                momentumTurns:0, 
                refluxUses:getPerkLevel('reflux'), 
                currentPerkChoices:null, 
                currentShopOffers:null, 
                selectedIdx:null, 
                busy:false, 
                targetMode:null, 
                pipetteMode:false, 
                pendingSkill:null, 
                extractorHeldColor:null,
                history: [],
                completedFlags: [] 
            });
            if(hasPerk('overflow')) {
                gameState.pressureMax = 14 + (getPerkLevel('overflow') * 4);
            }
            generateBoard(); 
            generateGoals(); 
            renderHUD(); 
            renderBoard(true);
            saveGame();
        }
        function tryUndo(){
            if (!gameState.history.length) return;
            const prev = gameState.history[gameState.history.length - 1];
                let isFree = prev.refluxUses > 0;
            if(!isFree && prev.essence < 5) {
                showToast(currentLang==='ja'?'„Ç®„ÉÉ„Çª„É≥„Çπ‰∏çË∂≥„ÅßÊàª„Çå„Åæ„Åõ„Çì':'Not enough Essence in past state', 'rose');
                return;
            }
            gameState.history.pop();
            Object.assign(gameState, { 
                tubes:deepCopy(prev.tubes), 
                turnCount:prev.turnCount, 
                pressure:prev.pressure, 
                hp:prev.hp, 
                secondaryProgress:prev.secondaryProgress, 
                catalystAvailable:prev.catalystAvailable, 
                essence:prev.essence, 
                inventory:{...prev.inventory}, 
                tubeCount:prev.tubeCount, 
                capacity:prev.capacity||4, 
                momentumTurns:prev.momentumTurns, 
                refluxUses:prev.refluxUses,
                targetMode:null, 
                pendingSkill:null, 
                extractorHeldColor:null, 
                selectedIdx:null,
                completedFlags: prev.completedFlags ? [...prev.completedFlags] : [] 
            });
            if(isFree){ 
                gameState.pressure += 2; 
                gameState.refluxUses--; 
                showFloatText(0, "Reflux Used (+2 P)", "#a855f7"); 
                gameState.history.forEach(h => {
                    if(h.refluxUses > 0) h.refluxUses--;
                });
            } else { 
                gameState.essence -= 5; 
                gameState.history.forEach(h => {
                    h.essence -= 5;
                });
            }
            updateTubeLayout(); 
            renderHUD(); 
            renderBoard(); 
            saveGame();
        }
        function renderHUD(){
            setText('ui-floor', `${t('floor')} ${gameState.floor}`); 
            setText('ui-essence', `‚ú® ${gameState.essence}`); 
            const hpPct = (gameState.hp / gameState.maxHp) * 100;
            const hpStr = `HP ${gameState.hp}`;
            const hpBar = ui('ui-hp-bar');
            if(hpBar) hpBar.style.width = `${clamp(hpPct, 0, 100)}%`;
            setText('ui-hp-text', hpStr);
            const hpMobileBar = ui('ui-hp-mobile-bar');
            if(hpMobileBar) hpMobileBar.style.width = `${clamp(hpPct, 0, 100)}%`;
            setText('ui-hp-mobile-text', hpStr);
            setText('ui-floor-mobile', `${gameState.floor}F`); 
            setText('ui-essence-mobile', `‚ú®${gameState.essence}`); 
                const totalLevels = Object.values(gameState.perks).reduce((a,b)=>a+b, 0); 
            setText('ui-perks-mobile', `üß¨ ${totalLevels}`); 
            setText('ui-turn', `${t('turn')} ${gameState.turnCount}`); 
            const goalEl = ui('ui-goal');
            if (gameState.primaryGoal) {
                const label = currentLang === 'ja' ? "ÁõÆÊ®ôÔºö" : "Goal: ";
                let goalContent = "";
                const type = gameState.primaryGoal.type;
                        if (type === 'completeAll') {
                    goalContent = currentLang === 'ja' ? '„Åô„Åπ„Å¶„ÅÆËâ≤„ÇíÂÆåÊàê' : 'Complete All Colors';
                } else if (type === 'completeN') {
                    const n = gameState.primaryGoal.n;
                    goalContent = currentLang === 'ja' ? `„ÅÑ„Åö„Çå„Åã${n}Ëâ≤„ÇíÂÆåÊàê` : `Complete any ${n} colors`;
                } else if (type === 'completeColor') {
                    const c = gameState.primaryGoal.color;
                    goalContent = currentLang === 'ja' ? `${colorName(c)}„ÇíÂÆåÊàê` : `Complete ${colorName(c)}`;
                    const meta = COLOR_POOL.find(x => x.key === c);
                    if (meta) {
                        const icon = `<span style="color:${meta.hex}; text-shadow:0 0 12px ${meta.hex}; margin-right:4px;">‚ñ†</span>`;
                        goalContent = `${icon}${goalContent}`;
                    }
                }
                goalEl.innerHTML = `<span class="text-slate-400 font-bold mr-1">${label}</span>${goalContent}`;
            } else {
                goalEl.textContent = '‚Äî';
            }
            const goalSubEl = ui('ui-goal-sub');
            if (gameState.secondaryGoal) {
                const isDone = secondarySucceeded();
                const type = gameState.secondaryGoal.type;
                const subLabel = currentLang === 'ja' ? "„Çµ„ÉñÁõÆÊ®ôÔºö" : "Sub Goal: ";
                        let contentText = "";
                if (type === 'speed') {
                    const lim = gameState.secondaryGoal.limit;
                    contentText = currentLang === 'ja' ? `${lim}„Çø„Éº„É≥‰ª•ÂÜÖ„Å´1Êú¨ÂÆåÊàê` : `Complete 1 within ${lim} turns`;
                } else if (type === 'combo') {
                    contentText = currentLang === 'ja' ? 'ÈÄ£Á∂öÂÆåÊàêÔºà„Ç≥„É≥„ÉúÔºâ' : 'Combo: 2 in a row';
                }
                goalSubEl.classList.remove('text-yellow-400', 'text-emerald-400', 'text-slate-500');
                goalSubEl.classList.add(isDone ? 'text-emerald-400' : 'text-yellow-400');
                let statusSuffix = isDone ? (currentLang === 'ja' ? " „ÄêÈÅîÊàê!!„Äë" : " [CLEARED!]") : "";
                let progressInfo = "";
                if (!isDone && type === 'combo') {
                    progressInfo = ` (${gameState.secondaryProgress}/${gameState.secondaryGoal.need})`;
                }
                goalSubEl.innerHTML = `<span class="text-slate-400 font-bold mr-1">${subLabel}</span>${contentText}${progressInfo}${statusSuffix}`;
            } else {
                goalSubEl.textContent = '‚Äî';
                goalSubEl.classList.add('text-slate-500');
            }
                const pressureLabel = ui('ui-pressure-label');
            if (pressureLabel) {
                pressureLabel.textContent = currentLang === 'ja' ? '„Éó„É¨„ÉÉ„Ç∑„É£„Éº' : 'PRESSURE';
            }
                const curP = gameState.pressure;
            const maxP = gameState.pressureMax;
                setText('ui-pressure', String(curP)); 
            const pct = Math.round((curP / maxP) * 100);
            const pBar = ui('ui-pressure-bar'); 
            if(pBar){ 
                pBar.style.width=`${clamp(pct,0,100)}%`; 
                        if(curP >= maxP - 3){ 
                    pBar.classList.remove('from-sky-400'); 
                    pBar.classList.add('bg-rose-600'); 
                } else { 
                    pBar.classList.add('from-sky-400'); 
                    pBar.classList.remove('bg-rose-600'); 
                } 
            }
            setText('ui-pressure-sub', `${curP} / ${maxP}`);
                const undoCost = gameState.refluxUses>0?'FREE':'‚ú®5'; 
            if(undoBtn){ 
                undoBtn.innerHTML=`<span>‚Ü∫</span> UNDO (${undoCost})`;
                const canUndo = gameState.history.length > 0;
                undoBtn.disabled = !canUndo;
                undoBtn.style.opacity = canUndo ? '1' : '0.3';
                undoBtn.style.cursor = canUndo ? 'pointer' : 'not-allowed';
                undoBtn.style.pointerEvents = canUndo ? 'auto' : 'none';
            } 
                renderSkills();
        }
        function moveFocus(dx){ if(!gameState.tubes.length) return; gameState.focusIdx = gameState.focusIdx === null ? 0 : (gameState.focusIdx + dx + gameState.tubeCount) % gameState.tubeCount; renderBoard(); }
        function updateStartScreenButtons(){ continueRunBtn.classList.toggle('hidden', !hasSaveData()); }
        const helpGuides = {
            ja: [
                { desktopId: 'ui-hp-bar', mobileId: 'ui-hp-mobile-bar', text: 'ÁîüÂëΩÂäõ' },
                { desktopId: 'ui-essence', mobileId: 'ui-essence-mobile', text: '„Ç®„ÉÉ„Çª„É≥„ÇπÔºàÈÄöË≤®Ôºâ' },
                { id: 'status-bar', text: 'ÁèæÂú®„ÅÆÁõÆÊ®ô„Åß„Åô„ÄÇÈÅîÊàê„ÅßÈöéÂ±§„ÇØ„É™„Ç¢„ÄÇ', align: 'left' },
                { id: 'center', text: '„ÄêÂü∫Êú¨„É´„Éº„É´„Äë\nÂêå„ÅòËâ≤„ÅãÁ©∫„ÅÆÁì∂„Å´Ê≥®„Åí„Åæ„Åô„ÄÇÊ∫Ä„Åü„Åô„Å®ÂÆåÊàêÔºÅ\n\n„ÄêÈªí„Ç§„É≥„ÇØ„Äë\nÊèÉ„Åà„Çã„Å®Ëí∏Áô∫„Åó„Å¶Ê∂àÊªÖ„Åó„Åæ„Åô„ÄÇ', isCenter: true },
                { id: 'ui-pressure-bar', text: '1Êâã„Åî„Å®„Å´Â¢óÂä†„Åó„ÄÅÊúÄÂ§ß„Åß„ÉÄ„É°„Éº„Ç∏„ÅåÂÖ•„ÇäÈªí„Ç§„É≥„ÇØ„ÅåÂá∫Áèæ„Åô„Çã„ÄÇ' },
                { id: 'skills-container', text: 'ÊâÄÊåÅ„Ç¢„Ç§„ÉÜ„É†„ÄÇ2Âõû„Çø„ÉÉ„Éó„Åß‰ΩøÁî®„ÄÇ' },
                { id: 'btn-undo', text: '„Ç®„ÉÉ„Çª„É≥„Çπ„ÇíÊ∂àË≤ª„Åó„Å¶1ÊâãÊàª„Åó„Åæ„Åô„ÄÇ', position: 'left' }
            ],
            en: [
                { desktopId: 'ui-hp-bar', mobileId: 'ui-hp-mobile-bar', text: 'Vitality.' },
                { desktopId: 'ui-essence', mobileId: 'ui-essence-mobile', text: 'Essence(Money)' },
                { id: 'status-bar', text: 'Current objectives.', align: 'left' },
                { id: 'center', text: '„ÄêBasic Rules„Äë\nPour into same color or empty tubes to complete!\n\n„ÄêObsidian„Äë\nStack to evaporate them.', isCenter: true },
                { id: 'ui-pressure-bar', text: 'Increases per move.\nAt max: Damage & Obsidian spawns.' },
                { id: 'skills-container', text: 'Items. Tap twice to use.' },
                { id: 'btn-undo', text: 'Spend Essence to revert a move.', position: 'left' }
            ]
        };
        let isHelpActive = false;
        function closeHelpGuide() {
            const overlay = ui('help-overlay');
            if (!overlay || overlay.style.display === 'none') return;
            overlay.style.display = 'none';
            document.querySelectorAll('.help-bubble').forEach(b => {
                b.classList.remove('show');
                setTimeout(() => b.remove(), 200);
            });
            isHelpActive = false;
            window.removeEventListener('mousedown', closeHelpGuide);
            window.removeEventListener('touchstart', closeHelpGuide);
        }
        function showTutorialBubbles() {
            if (isHelpActive) return;
            isHelpActive = true;
            const overlay = ui('help-overlay');
            overlay.style.display = 'block';
            const guides = currentLang === 'ja' ? helpGuides.ja : helpGuides.en;
            guides.forEach((guide) => {
                const bubble = document.createElement('div');
                bubble.className = 'help-bubble';
                bubble.style.whiteSpace = 'pre-line';
                bubble.textContent = guide.text;
                document.body.appendChild(bubble);
                if (guide.isCenter) {
                    bubble.classList.add('center-fixed');
                } else {
                    let target = ui(guide.id);
                    if (!target && guide.desktopId && guide.mobileId) {
                        const dEl = ui(guide.desktopId);
                        const mEl = ui(guide.mobileId);
                        target = (dEl && dEl.offsetWidth > 0) ? dEl : mEl;
                    }
                    if (!target) {
                        bubble.remove(); 
                        return;
                    }
                    const rect = target.getBoundingClientRect();
                    if (guide.position === 'left') {
                        const bWidth = bubble.offsetWidth;
                        const bHeight = bubble.offsetHeight;
                        bubble.style.left = (rect.left - bWidth + 100) + 'px';
                        bubble.style.top = (rect.top + (rect.height / 2) - (bHeight / 2)) + 'px';
                        bubble.classList.add('bubble-left');
                    } else {
                        let targetX;
                        if (guide.align === 'left') {
                            targetX = rect.left + Math.min(rect.width / 2, 60);
                        } else {
                            targetX = rect.left + (rect.width / 2);
                        }
                        bubble.style.left = targetX + 'px';
                        if (rect.top < window.innerHeight / 2) {
                            bubble.style.top = (rect.bottom + 12) + 'px';
                            bubble.classList.add('bubble-bottom');
                        } else {
                            bubble.style.top = (rect.top - 50) + 'px'; 
                            bubble.classList.add('bubble-top');
                        }
                        const bRect = bubble.getBoundingClientRect();
                        if (bRect.left < 10) bubble.style.left = (bRect.width / 2 + 10) + 'px';
                        if (bRect.right > window.innerWidth - 10) bubble.style.left = (window.innerWidth - bRect.width / 2 - 10) + 'px';
                    }
                }
                requestAnimationFrame(() => bubble.classList.add('show'));
            });
            setTimeout(() => {
                window.addEventListener('mousedown', closeHelpGuide);
                window.addEventListener('touchstart', closeHelpGuide);
            }, 100);
        }
        window.addEventListener('resize', () => {
            adjustBoardScale();
            if (isHelpActive) closeHelpGuide();
        });
        ui('btn-help').onclick = (e) => {
            e.stopPropagation();
            showTutorialBubbles();
        };
        if(undoBtn) undoBtn.onclick = tryUndo;
        ui('start-run-btn').onclick = startNewRun;
        ui('continue-run-btn').onclick = () => { startScreen.classList.add('hidden'); loadGame(); };
        let isDown = false;
        let startX;
        let dragStartX;
        let isDragging = false; 
        const slider = ui('board-scroll-area');
        slider.addEventListener('mousedown', (e) => {
            isDown = true;
            isDragging = false;
            slider.style.cursor = 'grabbing';
            startX = e.pageX - slider.offsetLeft;
            dragStartX = e.pageX;
        });
        slider.addEventListener('mouseleave', () => {
            isDown = false;
            slider.style.cursor = 'grab';
        });
        slider.addEventListener('mouseup', () => {
            isDown = false;
            slider.style.cursor = 'grab';
        });
        slider.addEventListener('mousemove', (e) => {
            if (!isDown) return;
            e.preventDefault();
            const x = e.pageX - slider.offsetLeft;
            const walk = (x - startX) * 1.5; 
            slider.scrollLeft -= walk; 
            startX = x;
            if(Math.abs(e.pageX - dragStartX) > 5) {
                isDragging = true;
            }
        });
        slider.addEventListener('scroll', () => {
            checkInfiniteScrollLoop();
        });
        function getBoardScale() {
            const boardArea = document.getElementById('board-area');
            const tubesContainer = document.getElementById('tubes-container');
            if (!boardArea || !tubesContainer) return 1;
                const availableH = boardArea.clientHeight;
            const contentH = tubesContainer.scrollHeight;
            if (contentH === 0) return 1;
                const targetH = availableH * 0.95;
            let scale = targetH / contentH;
            return Math.min(Math.max(scale, 0.3), 1.5);
        }
        function initInfiniteScroll() {
            const slider = document.getElementById('board-scroll-area');
            const tubesContainer = document.getElementById('tubes-container');
            const tubeEl = tubesContainer.querySelector('.tube');
            if(!tubeEl) return;
                const style = window.getComputedStyle(tubeEl);
            const marginLeft = parseFloat(style.marginLeft) || 0;
            const marginRight = parseFloat(style.marginRight) || 0;
            const containerStyle = window.getComputedStyle(tubesContainer);
            const gap = parseFloat(containerStyle.gap) || 0;
            const rawItemWidth = tubeEl.offsetWidth + marginLeft + marginRight + gap;
                const scale = getBoardScale();
            const scaledItemWidth = rawItemWidth * scale;
                const totalTubes = gameState.tubes.length;
            const scaledCloneWidth = scaledItemWidth * CLONE_PADDING;
            const centerOfScreen = slider.clientWidth / 2;
            const firstTubeCenter = scaledCloneWidth + (scaledItemWidth / 2);
            const initialScrollPos = firstTubeCenter - centerOfScreen;
                slider.scrollLeft = Math.round(initialScrollPos);
        }
        function checkInfiniteScrollLoop() {
            if(!gameState.tubes.length) return;
            const slider = document.getElementById('board-scroll-area');
            const tubesContainer = document.getElementById('tubes-container');
            const tubeEl = tubesContainer.querySelector('.tube');
            if(!tubeEl) return;
                const style = window.getComputedStyle(tubeEl);
            const marginLeft = parseFloat(style.marginLeft) || 0;
            const marginRight = parseFloat(style.marginRight) || 0;
            const containerStyle = window.getComputedStyle(tubesContainer);
            const gap = parseFloat(containerStyle.gap) || 0;
            const rawItemWidth = tubeEl.offsetWidth + marginLeft + marginRight + gap;
            const scale = getBoardScale();
            const scaledItemWidth = rawItemWidth * scale;
            const totalTubes = gameState.tubes.length;
            const scaledContentWidth = scaledItemWidth * totalTubes;
            const scaledCloneWidth = scaledItemWidth * CLONE_PADDING;
            const currentScroll = slider.scrollLeft;
            const currentCenterPos = currentScroll + (slider.clientWidth / 2);
            if (currentCenterPos > scaledCloneWidth + scaledContentWidth) {
                slider.scrollLeft -= scaledContentWidth;
            } 
            else if (currentCenterPos < scaledCloneWidth) {
                slider.scrollLeft += scaledContentWidth;
            }
        }
        document.addEventListener('mousedown', (e) => {
                const isSkillBtn = e.target.closest('.skill-btn');
            const isHUDControl = e.target.closest('button[id^="btn-"]'); 
                if (!isSkillBtn && !isHUDControl && gameState.pendingSkill !== null) {
                gameState.pendingSkill = null;
                hideGlobalTooltip();
                renderSkills();
            }
                if (isHelpActive) {
                if (!e.target.closest('#btn-help')) {
                    closeHelpGuide();
                }
            }
        });
        window.addEventListener('resize', () => {
            adjustBoardScale();
            if (isHelpActive) closeHelpGuide();
        });
        ui('btn-help').onclick = (e) => {
            e.stopPropagation();
            showTutorialBubbles();
        };
        ui('help-close').onclick = (e) => {
            e.stopPropagation();
            ui('help-screen').classList.replace('flex', 'hidden');
        };
        ui('btn-mutations').onclick = (e) => {
            e.stopPropagation();
            openMutationsScreen();
        };
        ui('mutations-close').onclick = (e) => {
            e.stopPropagation();
            mutationsScreen.classList.replace('flex', 'hidden');
        };
        const btnRetire = ui('btn-retire');
        if(btnRetire){
            btnRetire.onclick = (e) => {
                e.stopPropagation();
                const msg = currentLang === 'ja' 
                    ? "Êé¢Á¥¢„ÇíË´¶„ÇÅ„Åæ„Åô„ÅãÔºü\n(HP„Åå0„Å´„Å™„Çä„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº„Å´„Å™„Çä„Åæ„Åô)" 
                    : "Give up exploration?\n(HP becomes 0 and Game Over)";
                        if(confirm(msg)){
                    gameState.hp = 0;
                    renderHUD();
                    clearSave();
                    openPerkScreen(true);
                }
            };
        }
        if(undoBtn) undoBtn.onclick = (e) => {
            e.stopPropagation();
            tryUndo();
        };
        ui('reroll-btn').onclick = () => {
            if (gameState.rerollCoupons > 0) {
                gameState.rerollCoupons--;
            } else if (gameState.essence >= 5) {
                gameState.essence -= 5;
            } else {
                return;
            }
            gameState.currentShopOffers = null;
            openPerkScreen(false);
            saveGame();
        };
        ui('start-run-btn').onclick = startNewRun;
        ui('continue-run-btn').onclick = () => { startScreen.classList.add('hidden'); loadGame(); };
        document.addEventListener('click', (e) => {
            if (!gameState.extractorHeldColor) return;
            if (!e.target.closest('.tube') && !e.target.closest('.skill-btn')) {
                cancelInteraction();
            }
        });
        window.onkeydown = (e) => {
            if(!perkScreen.classList.contains('hidden') || !eventScreen.classList.contains('hidden') || !helpScreen.classList.contains('hidden') || !mutationsScreen.classList.contains('hidden')) return;
            if (e.key === 'ArrowLeft') moveFocus(-1); 
            if (e.key === 'ArrowRight') moveFocus(1);
            if ((e.key === 'Enter' || e.key === ' ') && gameState.focusIdx !== null) handleTubeClick(gameState.focusIdx);
            if (e.key === 'Backspace' || e.key === 'z') tryUndo();
        };
        function initGameSettings() {
            const savedLang = localStorage.getItem('abyss_alchemy_lang');
            if (savedLang === 'en' || savedLang === 'ja') {
                setLang(savedLang);
            } else {
                setLang('ja'); 
            }
            initPalette();
        }
        initGameSettings();
    </script>
</body>
</html>